\chapter{Artificial Intelligence}

\section{First-Order Logic and Logic Programming}

\begin{defi}[Signature]
$S$ is a \term{signature} if $S$ is a four-tuple \tuple{P,F,r,C} where:
\begin{enumerate}
\item $P$ is a set of \term{predicate symbols} \brak{P_1,P_2,\ldots,P_n},
\item $F$ is a set of \term{function symbols} \brak{F_1,F_2,\ldots,F_m},
\item $r$ is \term{arity} or \term{degree of functions} and relations. For each $P_i$ respectively $F_j$, \fun{r}{P_i} respectively \fun{r}{F_j} is a non-zero natural number denoting the arity of $P_i$ respectively $F_j$,
\item $C$ is a set of \term{constant symbols}.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Alphabet]
An \term{alphabet} $\Sigma$ consists of the following symbols:
\begin{enumerate}
\item Signature $S=\tuple{P,F,r,C}$.
\item \term{Collection of variables} $V$.
\item \term{Operators}: $\neg$ (\term{negation}), $\wedge$ (\term{conjunction}), $\vee$ (\term{disjunction}), $\rightarrow$ (\term{implication}), $\leftrightarrow$ (\term{equivalence}).
\item \term{Quantifiers}: $\forall$ (\term{forall}), $\exists$ (\term{exists}).
\item \term{Parentheses} and \term{punctuation symbols}: $($, $)$ and $,$.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Term]
A \term{term} is defined inductively as follows:
\begin{enumerate}
\item Variable is term.
\item Constant is term.
\item If $f$ is a function symbol ($f\in F$) with arity $m$ and $t_1,t_2,\ldots,t_m$ are terms of $\Sigma$, then \ffun{t_1,t_2,\ldots,t_m} is term of $\Sigma$.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Atom]
If $p$ is predicate symbol with arity $m$ and $t_1,t_2,\ldots,t_m$ are terms of $\Sigma$, then $\fun{p}{t_1,t_2,\ldots,t_m}$ is an \termor{atomic formula}{atom}. An atomic formula is a \term{formula} and all occurrences of variables in an atomic formula are free.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Formula]
A \term{formula} is defined as follows:
\begin{enumerate}
 \item An atom is a formula.
 \item If $H$ and $G$ are formulas, then:
 \begin{enumerate}
  \item $\neg H$ is a formula, the occurrence of variables in $\neg H$ is free respectively bound if it is free respectively bound in $H$,
  \item $H\wedge G$ is a formula, the occurrence of variables in $H\wedge G$ is free respectively bound if it is free respectively bound in $H$ or $G$,
  \item $H\vee G$ is a formula, the occurrence of variables in $H\vee G$ is free respectively bound if it is free respectively bound in $H$ or $G$,
  \item $H\rightarrow G$ is a formula, the occurrence of variables in $H\rightarrow G$ is free respectively bound if it is free respectively bound in $H$ or $G$,
  \item $H\leftrightarrow G$ is a formula, the occurrence of variables in $H\leftrightarrow G$ is free respectively bound if it is free respectively bound in $H$ or $G$.
 \end{enumerate}
 \item If $H$ is a formula and $x$ is a variable, then $\forall x:H$ and $\exists x:H$ are formulas. All occurrences of $x$ are bound.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Literal]
A \term{literal} $L$ is an atom or the negation of an atom.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Clause]
A \term{clause} is a formula such as $\forall\vec{x}:L_1\vee L_2\vee\ldots\vee L_m$ where each $L_i$ is a literal and $\vec{x}=\brak{x_1,x_2,\ldots,x_n}$ are all the variables occurring in $L_1\vee L_2\vee\ldots\vee L_m$.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Horn-clauses]
\term{Horn-clause}s have the form: $\forall x_1,x_2,\ldots,x_n:L_1\wedge L_2\wedge\ldots\wedge L_m\rightarrow L$ where $L,L_1\wedge L_2\wedge\ldots\wedge L_m$ are a literals and $x_1,x_2,\ldots,x_n$ are all variables having free occurrences in $L,L_1\wedge L_2\wedge\ldots\wedge L_m$.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Negation of a dilemma, Conjunction of dilemmas, Disjunction of dilemmas]
For a given set $D$ of dilemmas it is defined:
\begin{enumerate}
 \item A \term{negation of a dilemma} $d=\dilemma{u}$ as a dilemma $\neg d=\negdilemma{u}$;
 \item A \term{disjunction of the dilemmas} $d'=\dilemma{u'}$, $d''=\dilemma{u''}$ as a dilemma $d'\vee d''=\flatbrak{u'\vee u''|\neg\brak{u'\vee u''}}$;%
 \item A \term{conjunction of the dilemmas} $d'=\dilemma{u'}$, $d''=\dilemma{u''}$ as a dilemma $d'\wedge d''=\flatbrak{u'\wedge u''|\neg\brak{u'\wedge u''}}$;%
\end{enumerate}
\cite{conf/fedcsis/Kulikowski12}
\end{defi}

\begin{defi}[Equal certainty relation, Ambivalent dilemma, Equivalent dilemmas, Anti-equivalent dilemmas]
Let $D$ be a set of dilemmas. Then in $D$ a binary relation $\approx^c$ satisfying the conditions of:
\begin{enumerate}
\item Reciprocity: for each $d\in D$ it holds $d\approx^c d$;
\item Symmetry: for any $d',d''\in D$ if $d'\approx^c d''$ then also $d''\approx^c d'$ holds;
\item Reflexivity: for any $d',d''\in D$ if $d'\approx^c d''$ then also $\neg d'\approx^c\neg d''$ holds;
\item Transitivity: for any $d',d'',d'''\in D$ if $d'\approx^c d''$ and $d''\approx^c d'''$ then also $d'\approx^c d'''$ holds;
\item Fixation: for any $d',d''\in D$ if $d'\approx^c\neg d'$ and $d''\approx^c\neg d''$ then also $d'\approx^c d''$ holds,
\end{enumerate}
will be called an \term{equal certainty relation}. Any dilemma satisfying the condition $d\approx^c\neg d$ will be called an \term{ambivalent dilemma}; any dilemmas such that $d'\approx^c d''$ holds will be called \term{equivalent dilemmas}; any dilemmas such that $d'\approx^c\neg d''$ holds will be called \term{anti-equivalent dilemmas}.
\cite{conf/fedcsis/Kulikowski12}
\end{defi}

\begin{defi}[Certainty ranking]
Let $D$ be a set of dilemmas with established equal certainty relation. Then a binary relation $\preceq^c$ described in $D$ and satisfying the conditions of:
\begin{enumerate}
 \item reciprocity: for each $d\in D$ it holds $d\preceq^c d$;
 \item symmetry: for any $d',d''\in D$ $d'\preceq^c d''$ and $d''\preceq^c d'$ hold if and only if $d'\approx^c d''$ holds;
 \item anti-reflexivity: for any $d',d''\in D$ if $d'\preceq^c d''$ then $\neg d''\preceq^c\neg d'$ holds;
 \item transitivity: for any $d',d'',d'''\in D$ if $d'\preceq^c d''$ and $d''\preceq^c d'''$ then also $d'\preceq^c d'''$ holds,
\end{enumerate}
will be called a \term{certainty ranking}.
\cite{conf/fedcsis/Kulikowski12}
\end{defi}

\begin{theo}
Let $D$ be a set of dilemmas with established equal certainty and certainty ranking relations. Then for any $d',d''\in D$:
\begin{enumerate}
\item if $d'\preceq^c d''$ and not $d''\preceq^c d'$ then $d'\vee d''\preceq^c d''$;
\item if $d'\preceq^c d''$ and not $d''\preceq^c d'$ then $d'\wedge d''\preceq^c d'$;
\item if $d'\approx^c d''$ then $d'\vee d''\approx^c d'\wedge d''\approx^c d'\approx^c d''$;
\item if $d'\approx^c d''$ then $d'\wedge d''\approx^c d',d''$;
\item if $d'\approx^c d''$ then $d',d''\approx^c d'\vee d''$
\end{enumerate}
\cite{conf/fedcsis/Kulikowski12}
\end{theo}

\subsection{Logic Programming}

\begin{defi}[Domain declaration for predicate symbol $p$]
A \term{domain declaration for predicate symbol $p$} of arity n is an expression of the following form.
\begin{equation}
\mbox{domain }\fun{p}{a_1,\ldots ,a_n}
\end{equation}
where $a_i$ is either $h$ or $d$. When $a$ is equal to $h$, this means that the $i$-th argument of $p$ ranges over the Herbrand universe. Otherwise, it means that the $i$-th argument is a list of variables which ranges over $d_1$ In the following, the domains $d_i$ are finite and explicit sets of values (i.e constants).
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[Domain set of a logic program]
Let $dl,\ldots ,dn$ the domains appearing in the domain declarations of a logic program $PR$ and different from the Herbrand universe. We note \fun{D}{PR} the set $\accol{d|d\neq\emptyset\wedge d\in 2^{d_i}\accol{1\leq i\leq n}}$ We call it the \term{domain set of the logic program}. The domain set of a logic program contains all domains we possibly need during the computations.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[Range of a term included in a domain]
We say that the \term{range of $t$ is included in a domain $d_t$} denoted $\abs{t}\in d_i$ if $t$ is a constant $\in d_t$ or a $d$-variable $x^{d_t}$ such that $d_t\subseteq d$
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[$d$-substitution]
A $d$-substitution $\theta$ is a finite set of the form $\accol{v_1/t_1,\ldots,v_n/t_n}$ where
\begin{enumerate}
 \item each $v_i$ is either a variable or $d$-variable
 \item $t_i$ is a term distinct from $v_i$,
 \item $v_1,\ldots,v_n$ are all distinct,
 \item if $v_i$ is a $d$-variable $v^{d_i}$, $\abs{t_i}\in d_i$
\end{enumerate}
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[$d$-substitutions agree on a set of variables and $d$-variables]
We say that two \term[$d$-substitutions agree on a set of variables and $d$-variables]{$d$-substitutions $\theta$ and $\lambda$ agree on a set $V$ of variables and $d$-variables}, denoted $\theta=\lambda\abs{V}$ \iffTx{} $x\theta=x\lambda$ for each $x\in V$ where $=$ denotes syntactic equality.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[$d$-instance]
$\theta$ is a \term{$d$-instance} of $\lambda$ in $V$, denoted $\lambda\leq\theta$ \iffTx{} $x\theta=\delta\circ\lambda$ for some $d$-substitution $\delta$.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[$d$-unifier, unifies, more general $d$-unifier, $d$-mgu]
A $d$-substitution $\sigma$ is a \term{$d$-unifier} of some non-empty and finite subset $S=\accol{t_1,\ldots,t_n}$ where $t_i$ and a literal of a term \iffTx{} $t_1\sigma=\ldots=t_n\sigma$, we also say that $\sigma$ \term{unifies} $S$. \term{\fun{UNI}{S}} is the set of all $d$-unifiers of $S$. $\sigma$ is called the \termor{more general $d$-unifier}{$d$-mgu} of $S$ \iffTx for each $\theta\in\fun{UNI}{S}$, $\theta\leq\sigma\abs{\fun{vars}{S}}$ implies $\sigma\leq\theta\abs{\fun{vars}{S}}$ where \fun{vars}{S} is the set of all variable or $d$-variable symbols in $S$.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[Constraint]
Let $p$ be a $n$-ary predicate symbol, $p$ is a \term{constraint} \iffTx for any ground terms either has a successful refutation or has only finitely failed derivations.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[forward checkable literal, forward-variable]
A literal $\pfun{x_1,\ldots,x_n}$ in the resolvent is \term[forward checkable literal]{forward checkable} \iffTx{} $p$ is a constraint and all it's arguments are ground but one which is a $d$-variable. This $d$-variable is called the \term{forward-variable}.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[forward checking inference rule]
Let $G_1$ be the goal $\leftarrow A_1,\ldots,A_{m-1},P,A_{m+1},\ldots A_k$ and $PR$ be a logic program. $G_{i+1}$ is derived from $G_i$ using the mgu $\theta_{i+1}$ via $PR$ if the following conditions hold:
\begin{enumerate}
 \item $P$ is forward checkable and $x^d$ is the forward variable
 \item $d_{\mbox{new}}=\accol{a\in d|PR\vDash P\accol{x/a}}$ and $d_{\mbox{new}}\neq\emptyset$
 \item $\theta_{i+1}$ is
 \begin{enumerate}
  \item $\accol{x^d/e}$ if $d_{\mbox{new}}=\accol{e}$
  \item $\accol{x^d/z^{d_{\mbox{new}}}}$ where $z^d_{\mbox{new}}$ is a new variable otherwise.
 \end{enumerate}
 \item $G_{i+1}$ is the goal $\leftarrow\brak{A_1,\ldots,A_{m-1},A_{m+1},\ldots A_k}\theta_{i+1}$
\end{enumerate}
Such a derivation rule is called the \termabbrev{forward checking inference rule}{FCIR}.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[Efficient computation rule with respect to forward declarations]
A computation rule is \term[Efficient computation rule with respect to forward declarations]{efficient with respect to the forward declarations}, if it selects only a predicate submitted to forward declaration when it is ground or forward checkable and if, whenever the resolvent contains literals submitted to a forward declaration which are either forward-checkable or ground, it selects one of them.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[lookahead checkable literal, lookahead-variable]
A literal $\pfun{t_1,\ldots,t_n}$ in the resolvent is \term[lookahead checkable literal]{lookahead checkable} \iffTx{} $p$ is a constraint and their exists at least one $t_i$ which is a domain-variable and each other argument is either ground or a domain-variable. The domain-variables in $t_1,\ldots,t_n$ are called the \term{lookahead-variable}s.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[lookahead inference rule]
Let $G_1$ be the goal $\leftarrow A_1,\ldots,A_{m-1},P,A_{m+1},\ldots A_k$ and $PR$ be a logic program. $G_{i+1}$ is derived from $G_i$ using the mgu $\theta_{i+1}$ via $PR$ if the following conditions hold:
\begin{enumerate}
 \item $P$ is lookahead checkable and $x_1,\ldots,x_n$ are the lookahead variables whose domains are $d_{x_1},\ldots d_{x_n}$.
 \item For each $x_j^{d_{x_j}}$ let:
 \begin{enumerate}
  \item $d_{z_j}=\accol{y_j\in d_{x_j}|\exists y_1\in d_{x_1},\ldots,y_{j-1}\in d_{x_{j-1}},y_{j+1}\in d_{x_{j+1}},\ldots,y_n\in d_{x_n}\mbox{ such that }PR\vDash P\theta\mbox{ with }\theta=\accol{x_1/y_1,\ldots,x_n/y_n}}$ and $d_{x_j}\neq\emptyset$.
  \item $e_j$ as
  \begin{enumerate}
   \item a new variable of domain $d_{z_j}$ if $d_{z_j}=\abs{\accol{e_1,\ldots,e_l}}>1$.
   \item the constant $e$ if $d_{z_j}$ if $d_{z_j}=\accol{e}$.
  \end{enumerate}
 \end{enumerate}
 \item $\theta_{i+1}=\accol{x_1/z_1,\ldots,x_n/z_n}$
 \item $G_{i+1}$ is the goal
 \begin{enumerate}
  \item $\leftarrow\brak{A_1,\ldots,A_{m-1},A_{m+1},\ldots A_k}\theta_{i+1}$ if at most one $z_i$ is a $d$-variable.
  \item $\leftarrow\brak{A_1,\ldots,A_{m-1},P,A_{m+1},\ldots A_k}\theta_{i+1}$ otherwise.
 \end{enumerate}
\end{enumerate}
Such a derivation rule is called the \termabbrev{lookahead inference rule}{LAIR}.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[Efficient computation rule with respect to the lookahead declarations]
A computation rule is \term[efficient computation rule with respect to the lookahead declarations]{efficient with respect to the lookahead declarations}, if a literal in the resolvent submitted to a lookahead declaration is only selected if either it is lookahead checkable or all its arguments are ground.
\cite{conf/ijcai/Hentenryck87}
\end{defi}

\begin{defi}[\fun{Revise}{M,a}]
Let $a$ be a formula and M a model. \term{\fun{Revise}{M,a}} is the set of models $M'$ such that
\begin{enumerate}
\item \label{reviseIt1} $M'$ and $M$ have the same universe and agree on all functions.
\item \label{reviseIt2} $a$ and the protected formulas of $T$ are true in $M'$.
\item There is no other model $M''$ such that for some $1<i<1$,
\begin{enumerate}
\item $M''$ satisfies (\ref{reviseIt1}) and (\ref{reviseIt2});
\item $M''$ and $M'$. agree on all predicates in strata $1$ through $i-1$; and
\item the differences between M" and M on predicates in stratum $i$ are a proper subset of the differences between $M'$ and $M$ on those predicates.
\end{enumerate}
\end{enumerate}
\cite{conf/ijcai/Winslett89}
\end{defi}

\begin{defi}[Preferred model at the $i$-th stratum]
A model $\calM_1$ is \term[Preferred model at the $i$-th stratum]{preferred to model $\calM_2$ at the $i$-th stratum} (written $\calM_1<_i\calM_2$) \iffTx{}
\begin{enumerate}
\item $\calM_1$ and $\calM_2$ have identical universes;
\item $\calM_1$ and $\calM_2$ agree on all predicates and functions, except possibly those of $S_i$ and $V_i$;
\item For all predicates $P$ in stratum $S_t$, and for all $\bar{x}$ such that $\fun{P}{\bar{x}}$ is true in $\calM_1$, $\fun{P}{\bar{x}}$ is true in $\calM_2$; and
\item For some predicate $P$ in stratum $S_i$ and some $\bar{x}$, $\fun{P}{\bar{x}}$ is false in $\calM_1$ and true in $\calM_2$.
\end{enumerate}
\cite{conf/ijcai/Winslett89}
\end{defi}

\begin{defi}[Abductive problem, Background theory of the abductive problem, Abducible set of the abductive problem, Goal of the abductive problem, Solution of an abductive problem, Minimal solution of an abductive problem]
The triple $\tuple{\Pi,A,g}$ is an \term{abductive problem} \iffTx{} $\Pi$ is a set of propositional Horn Clauses (called the \term{background theory of the abductive problem}), $A$ a set of propositions (called the \term{abducible set of the abductive problem}) and $g$ is a proposition (called the \term{goal of the abductive problem}). The set of propositions $\Delta$ is a \term[solution of an abductive problem]{solution of the abductive problem} $\tuple{\Pi,A,g}$ \iffTx{}
\begin{enumerate}
\item $\Delta\subseteq A$
\item $\Delta\cup\Pi\vdash g$
\item $\Delta\cup\Pi$ is consistent
\item $\brak{a\in A \wedge \Delta+\Pi\vdash a}\rightarrow a\in\Delta$
\end{enumerate}
$\Delta$ is a \term[Minimal solution of an abductive problem]{minimal solution of} $\tuple{\Pi,A,g}$ \iffTx{} it is a solution of $\tuple{\Pi,A,g}$ and no subset of $\Delta$ is a solution of $\tuple{\Pi,A,g}$.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Only-if set, \fun{only-if}{T,S}, \fun{only-if}{T}, \fun{props}{T}]
Let the clauses $p\leftarrow Q_1,p\leftarrow Q_2,\ldots,p\leftarrow Q_k$. where $Q_1,Q_2,\ldots,O_k$ are conjunctions of propositions, be all the clauses in $\Pi$ which have $p$ at their head. Let $n_{c_1},n_{c_2},...,n_{c_k}$ be the names of these clauses. Then the \term{only-if set} of p with respect to $\Pi$ is $\accol{\neg p\vee n_{c_1}\vee n_{c_2}\vee\ldots\vee n_{c_k},n_{c_1}\rightarrow Q_1,n_{c_2}\rightarrow Q_2,\ldots,n_{c_k}\rightarrow Q_k}$. For at set of propositions $S$ and the Horn clause theory $T$, we use \term{\fun{only-if}{T,S}} to denote the union of only-if sets of all the propositions in $S$ with respect to $T$. We use \term{\fun{only-if}{T}} to denote \fun{only-if}{T,\fun{props}{T}} where \term{\fun{props}{T}} is the set of all propositions in $T$.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Truth-assignment, Model]
Let $C$ be a propositional clausal theory. $S$ the set of propositions in $C$, and $M$ a set of propositions. Then the \term{truth-assignment} induced by $M$ is the assignment of true to all propositions in $S$ which are in $M$. and false to those propositions in $S$ which are not in $M$. $M$ is a \term{model} of $C$ \iffTx{} the truth assignment induced by $M$ satisfies all the clauses in $C$.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Model which minimizes, Minimization with respect to]
Let $C$ be a propositional clausal theory. and $A$ a set of propositions. Then $M$ is a \term[model which minimizes]{model of $C$ which minimizes $A$} \iffTx{}
\begin{enumerate}
 \item $M$ is a model of $C$
 \item There is no other model $M'$ of $C$ such that $M'\cap A\subseteq M\cap A$
\end{enumerate}
We say that $\Delta$ is a \term[minimization with respect to]{minimization of $A$ with respect to $C$} \iffTx{} there is a model $M$ of $C$ which minimizes $A$ and $\Delta=M\cap A$
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Unit refutable]
A propositional clausal theory $C$ is \term{unit refutable} \iffTx{}, for every set of unit clauses $U$, if $C\cup U$ is inconsistent. then the empty clause is unit-derivable from $C\cup U$.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Connection graph]
Given a set of clauses $C$. the \term{connection graph} of $C$ is the graph obtained by drawing a link between each complimentary pair of literals in the set.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Chain]
Given the set of clauses $C$, the sequence $\flatbrak{\brak{x_1,e_1,y_1},\brak{x_2,e_2,y_2},\ldots,\brak{x_n,e_n,y_n}}$ of $c$-triples is a \term{chain} in $C$ \iffTx{} for all $k$, $e_k$ is a clause in $C$ and $y_k=\neg x_{k+1}$.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Tied chain]
$\flatbrak{\brak{x_1,e_1,y_1},\brak{x_2,e_2,y_2},\ldots,\brak{x_n,e_n,y_n}}$ is a \term{tied chain} in $C$ \iffTx{} it is a chain in $C$ and $x_1=y_n$.
\cite{conf/ijcai/Eshghi93}
\end{defi}

\begin{defi}[Subgoal clause]
Let $C$ be a set of clauses. Let $T$ be a connection tableau for $C$. Let $s_1,s_2,\ldots,s_n$, $n\geq 1$ be the subgoals of $T$ Then we call $s_1\vee s_2\vee\ldots\vee s_n$ the \term{subgoal} clause of $T$.
\cite{conf/ijcai/Fuchs99}
\end{defi}

\begin{defi}[Query tableau, Query clause]
Let $\calC$ be a set of clauses. Let $T$ be a connection tableau for $\calC$. Let $\calS\subseteq \calC$ be a set of start clauses. Let $S$ be the clause below the unlabeled root of $T$. If $S$ is an instance of a clause from $\calS$ we call$T$ a \term{query tableau} (\wrtTx{} $\calS$) and the subgoal clause of $T$ a \term{query clause} (\wrtTx{} $S$).
\cite{conf/ijcai/Fuchs99}
\end{defi}

\begin{defi}[Lemma tableau, Lemma clause]
Let $\calC$ be a clause set. Let $T$ be a connection tableau for $\calC$. Let $C=s_1\vee s_2\vee\ldots\vee s_n$ be the subgoal clause of $T$. Let $\calH$ be the set of subgoals which are immediate successors of the root. If $\calH\neq\emptyset$ we call $T$ a \term{lemma tableau}. Then, let $s+i$, $1\leq i\leq n$, be the element of $\calH$ which is left-most in $T$. We call the contrapositive $s_i\leftarrow\neg s_1\wedge\neg s_2\wedge\ldots\wedge\neg s_{i-1}\wedge\neg s_{i+1}\wedge\ldots\wedge\neg s_n$ of $C$ the \term{lemma clause} of $T$.
\cite{conf/ijcai/Fuchs99}
\end{defi}

\begin{defi}[Legal global instances]
Given an open global system $\frakG=\accol{\tuple{\varphi_1,v_1},\tuple{\varphi_2,v_2},\ldots,\tuple{\varphi_n,v_n}}$, the set of \term{legal global instances} is $\fun{Linst}{\frakG}=\accol{D\mbox{ instance of }\calR|v_i\subseteq\fun{\varphi_i}{D},i=1,\ldots,n}$.
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Certain answer]
Given an open global system $\frakG$ and a query $\fun{Q}{X}$ to the system, a tuple $t$ is a \term{certain answer} to $Q$ in $\frakG$ if for every global instance $D\in\fun{Linst}{\frakG}$, it holds $D\vDash\funf{Q}{t}$. We denote with $\fun{Certain_{\frakG}}{Q}$ the set of certain answers to $Q$ in $\frakG$.
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Minimal legal global instance, Minimal legal global instances]
Given a global system, $\frakG$, an instance $D$ is \term[Minimal legal global instance]{minimal} if $D\in\fun{Linst}{\frakG}$ and is minimal \wrtTx{} set inclusion, i.e. there is no other instance in \fun{Linst}{\frakG} that is a proper subset of $D$ (as a set of atoms). We denote by $\fun{Mininst}{\frakG}$ the \term[Minimal legal global instances]{set of minimal legal global instances of $\frakG$ \wrtTx{} set inclusion}.
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Consistent global system]
A global system $\frakG$ is \term[Consistent global system]{consistent} \wrtTx{} $IC$. if for all $D\fun{Mininst}{\frakG}$, $D\vDash IC$.
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Minimal answer, Minimal answers]
The ground tuple $\bar{a}$ is a \term{minimal answer} to a query $Q$ posed to $\frakG$ if for every $D\in\fun{Miminst}{\frakG}$, $\bar{a}\in\fun{Q}{D}$, where $\fun{Q}{D}$ is the answer set for $Q$ in $D$. The set of \term{minimal answers} is denoted by $\fun{Minimal_{\frakG}}{Q}$.
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Database distance]
Let $D,D'$ be database instances over the same schema and domain. The \term[database distance]{distance} $\fun{\Delta}{D,D'}$, between $D$ and $D'$ is the symmetric difference $\fun{\Delta}{D,D'}=\brak{\fun{\Sigma}{D}\setminus \fun{\Sigma}{D'}}\cup\brak{\fun{\Sigma}{D'}\setminus\fun{\Sigma}{D}}$
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Database order relation]
For database instances $D,D',D''$, we define $D'\term[Database order relation $\leq_D$]{\leq_D} D''$ if $\fun{\Delta}{D,D'}\subseteq\fun{\Delta}{D,D''}$
\cite{conf/ijcai/BravoB03}
\end{defi}

\begin{defi}[Repair of a global system]
Let $\frakG$ be a global system and $IC$ a set of global $IC$'s. A \term[repair of a global system]{repair} of $\frakG$ \wrtTx{} $IC$ is a global database instance $D'$. such that $D'\vDash IC$ and $D'$ is $\leq_D$-minimal for some $D\in\fun{Mininst}{\frakG}$.
\cite{conf/ijcai/BravoB03}
\end{defi}

%defintion 7

\section{Knowledge Representation}

\begin{defi}[Belief change scenario]
A \term{belief change scenario} is a triple $B=\tuple{K,R,C}$, where $K$, $R$ and $C$ are sets of formula over a fixed propositional language $\calLcalP$. Informally, $K$ is a \term{knowledge base} which is to be modified in such a way that the resulting knowledge base includes all elements from $R$ and does not include any element from $C$. The modified knowledge base corresponding to $B$ will be denoted by $K\dotplus R\dotminus C$.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}[Belief change extension, Unique (inconsistent) belief change extension]
Let $B=\tuple{K,R,C}$ be a belief change scenario over $\calLcalP$. Define a new set $\calP'$ of atoms, isomorphic with $\calP$, given by $\calP'=\accol{p':p\in\calP}$. Let $K'$ be a knowledge base obtained from $K$ by replacing any $p\in\calP$ by $p'\in\calP'$. Let $EQ$ be a maximal (with respect to set inclusion) set of equivalences $\accol{p\Leftrightarrow p'|p\in\calP}$ such that $\fun{Th}{K'\cup EQ\cup R}\cap\brak{C\cup\bot}=\emptyset$. The set $\fun{Th}{K'\cup EQ\cup R}\cap\calLcalP$ is called a \term{belief change extension} of $B$. If there is no such set $EQ$, then $B$ is inconsistent and $\calLcalP$ is a \term{unique (inconsistent) belief change extension} of $B$.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}[Class of all belief change extensions]
Let $\accol{E_i}_{i\in I}$ be the \term{class of all belief change extensions} of $B=\tuple{K,R,C}$. Then
\begin{equation}
K\dotplus R\dotminus C=\displaystyle\bigcap_{i\in I}E_i
\end{equation}
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}[Knowledge base, Observation, Defeasible statement, Domain axiom]
A \term{knowledge base} is a triple $KB=\tuple{OB,DS,DA}$, where $OB$, $DS$ and $DA$ are finite sets of formulas. These sets are referred to as \term{observation}s, \term{defeasible statement}s and \term{domain axiom}s, respectively.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}[Revision formula, Revision]
Let $KB=\tuple{OB,DS,DA}$ be a knowledge base and suppose that $\alpha$ is a \term{revision formula} representing a new observation. A \term{revision} of $KB$ by $\alpha$, written $KB\ast\alpha$, is a new knowledge base given by $\tuple{OB_1,DS,DA}$, where $OB_1=OB\oplus\accol{\alpha}\ominus\accol{\neg DA\hat{}}$. Here $\accol{\alpha}\ominus\accol{\neg DA\hat{}}$ is a finite representation of the modified knowledge base corresponding to belief change scenario $\tuple{OB,\accol{\alpha},\accol{\neg DA\hat{}}}$.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}[Belief set corresponding to]
Let $KB=\tuple{OB,DS,DA}$ be a knowledge base. A \term{belief set corresponding to} $KB$, written $B_{KB}$, is given
by $DS\dotplus\brak{OB\cup DA}$.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}[Prioritized belief revision of $KB$ by $\alpha$]
Let $KB=\tuple{OB,DS,DA}$ be a knowledge base and $\alpha$ be a revision formula. Let $OB_1=OB\oplus\accol{\alpha}\ominus\accol{\neg DA\hat{}}$. The \term{prioritized belief revision of $KB$ by $\alpha$} with respect to priorities $DS_1<DS_2<\ldots<DS_n$, written $KB\ast^{\flatbrak{DS_1<DS_2<\ldots<DS_n}}\alpha$, is the formula
\begin{equation}
DS_1\dotplus\brak{DS_2\oplus\ldots\brak{DS_n\oplus (OB_1\cup DA)\ldots}}.
\end{equation}
\cite{}
\end{defi}

\begin{defi}[Finite representation of the modified knowledge base corresponding to belief change scenario]
Let $KB=\tuple{OB,DS,DA}$ and suppose that $\alpha$ is a revision formula representing a domain axiom. The revised knowledge base is defined by $KB\ast\alpha=\tuple{OB1,DS,DA\cup\accol{α}}$, where $OB_1=OB\oplus\accol{\top}\ominus\accol{\neg\brak{DA\cup\accol{\alpha}}\hat{}}$. Here $OB\oplus\accol{\top}\ominus\accol{\neg\brak{DA\cup\accol{\alpha}}\hat{}}$ is a \term{finite representation of the modified knowledge base corresponding to belief change scenario}, $\tuple{OB,\accol{\top},\accol{\neg\brak{DA\cup\accol{\alpha}}\hat{}}}$.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\begin{defi}
Let $KB=\tuple{OB,DS,DA}$ and suppose that $\alpha$ is a revision formula representing a defeasible statement. The revised knowledge base is defined by $KB\ast\alpha=\tuple{OB,DS_1,DA}$, where $DS_1=DS\oplus\accol{\alpha}$.
\cite{conf/fedcsis/KorpusikLM12}
\end{defi}

\section{Machine Learning and Probabilistic Reasoning}

\begin{defi}[Learning algorithm for a meta-domain]%Problem: SxG??
Formally, an algorithm $A$ is a \term{learning algorithm for a meta-domain} $M$ in a hypothesis space $H$ with respect to a set of problem distributions $T$, if for any domain $D\in M$, any choice of a problem distribution $P$ in $T$, and any target problem solver $f\in H$,
\begin{enumerate}
\item $A$ takes as input the specification of a domain $D\in M$, an error parameter $E$, and a confidence parameter $\sigma$,
\item $A$ may call \alg{SolvedProblem}, which returns examples $\brak{x,\ffun{x}}$ for $D$, where $x$ is chosen with probability $\Pfun{x}$ from $S\times G$. The number of oracle calls of $A$ and its running time must be polynomial in the maximum problem size and the length of its input.
\item For all $D\in M$ and distributions $P\in T$, with probability at least $\brak{1-\delta}A$ outputs a program $f'$ that approximates $f$ in the sense that
\begin{equation}
\displaystyle\sum_{x\in\Delta}{\Pfun{x}}\leq\epsilon
\end{equation}
where $\Delta=\accol{x | f'\mbox{ fails on }x\mbox{ while }f\mbox{ succeeds}}$.
\item There is a polynomial $R$ such that, for a maximum problem size $n,\frac{1}{\epsilon},|frac{1}{\delta}$, maximum length $I$ and maximum step length $r$ of any solution output by \alg{SolvedProblem}, and an upper bound $t$ on the running times of programs in $D$ on inputs of size $n$, if $A$ outputs $f'$, the run time of $f'$ is bounded by $\fun{R}{n,l,r,t,\frac{1}{\epsilon},\frac{1}{\delta}}$
\end{enumerate}
\cite{conf/ijcai/Tadepalli91}
\end{defi}

\begin{defi}[Satisfying a spare solution space bias]
A problem solver $f$ for a domain $D$ and a problem distribution $P$ \term[Satisfying a sparse solution space bias]{satisfies a sparse solution space bias} if there is a set of operator sequences $m_f$ such that, on any problem $x\in D$ such that $\Pfun{x}>0$, $\ffun{x}\in m_f$ and $\abs{m_f}$ is bounded by a polynomial $Q$ in the problem size $n$.
\cite{conf/ijcai/Tadepalli91}
\end{defi}

\begin{defi}[Satisfying a macro table bias]
A problem solver $f$ \term[Satisfying a macro table bias]{satisfies a macro table bias} for a domain $D$ in $M$ if there is a feature ordering $O=\brak{l,\ldots,n}$ such that,
\begin{enumerate}
 \item $D$ is serially decomposable for $O$, and
 \item $f$ constructs all its solutions using a macro table $M$ as follows: for each feature $i$ from $1$ to $n$, macros $M_{j,i}$ are successively applied, where $j$ is the value of feature $i$ in the state before applying the macro.
\end{enumerate}
\cite{conf/ijcai/Tadepalli91}
\end{defi}

\begin{defi}[Beliefs in Conjoint Analysis]
We allow weighted beliefs with a weight parameter coming from \ocinterval{0}{1} where $1$ means full truth degree (complete certainty, the perfect belief), while a value $\alpha\in\oointerval{0}{1}$ describe a regular belief that can be doubted.
\begin{enumerate}
 \item \term{Regular belief}s such as:
 \begin{equation}
(\fun{A_1}{a_1}\wedge\ldots\wedge\fun{A_t}{a_t}):\alpha
 \end{equation}
 \item \term{Indifference belief}s such as:
 \begin{equation}
 \left(L\leftrightarrow R\right):1
 \end{equation}
 Indifference beliefs are always have full truth because we claim that if the respondent would distinguish degrees of truth then she is able to express preference.
 \item \term{Negative belief}s such as:
 \begin{equation}
 \left(\neg F\right):1
 \end{equation}
\end{enumerate}
where $A_i$ are attribute predicates and $L$, $R$, $F$ are regular atom conjunctions. Again, it is obvious in conjoint to don't ask user to express thoughts on negative information. As such there are no real negative beliefs such as $F:0$. Moreover, the reader may notice that we adopt the intuitionistic logic approach i.e., there is no assumption on any kind of law of excluded middle, as we don't necessarily assume $F:0\Leftrightarrow\left(\neg F\right):1$.
\cite{conf/fedcsis/GiurcaSB12}
\end{defi}

\subsection{Agent Systems, Decision Making and Q-Learning}

\begin{defi}[Sequence of decision elements, decision element, participation, positive set, neutral set, negative set, rate of return, degree of secure of rate $Z$, date of knowledge]
The structure decision $P$ of finite set of decision elements $E=\accol{e_1,e_2,\ldots,e_Y}$ is called as \term{sequence of decision elements}: $P=\tuple{\accol{EW^+},\accol{EW^{\pm}},\accol{EW^-},Z,SP,DT}$, Where:
\begin{enumerate}
 \item $EW^+=\tuple{e_0,pe_0},\tuple{e_q,pe_q},\ldots,\tuple{e_p,pe_p}$; couple $\tuple{e_x,pe_x}$, where $e_x\in E$ and $pe_x\in\ccinterval{0}{1}$. Denote a \term{decision element} and \term{participation} this element in set $EW^+$; decision element $e_x\in EW^+$ will be denoted as $e_x^+$; The set $EW^+$ is called \term{positive set}, in other words it is a set of decision elements, about which the agent knows that these elements are in the environment.
 \item $EW^{\pm}=\tuple{e_r,pe_r},\tuple{e_s,pe_s},\ldots,\tuple{e_t,pe_t}$; couple $\tuple{e_x,pe_x}$, where $e_x\in E$ and $pe_x\in\ccinterval{0}{1}$. Denote a decision element and participation this element in set $EW^+$; decision element $e_x\in EW^+$ will be denoted as $e_x^{\pm}$; The set $EW^{\pm}$ is called \term{neutral set}, in other words it is a set of decision elements, about which the agent does not know that these elements are in the environment.
 \item $EW^-=\tuple{e_r,pe_r},\tuple{e_s,pe_s},\ldots,\tuple{e_t,pe_t}$; couple $\tuple{e_x,pe_x}$, where $e_x\in E$ and $pe_x\in\ccinterval{0}{1}$. Denote a decision element and participation this element in set $EW^-$; decision element $e_x\in EW^+$ will be denoted as $e_x^-$; The set $EW^{\pm}$ is called a \term{negative set}, in other words it is a set of decision elements, about which the agent knows that these elements are not in the environment.
 \item $Z\in\ccinterval{0}{1}$ -- \term{rate of return}
 \item $SP\in\ccinterval{0}{1}$ -- \term{degree of secure of rate $Z$}
 \item $DT$ -- \term{date of knowledge}.
\end{enumerate}
\cite{conf/fedcsis/Sobieska-KarpinskaH12}
\end{defi}

\begin{defi}[Profile]
Set of decision elements $E=\accol{e_1,e_2,\ldots,e_Y}$ is given. A \term{profile} $A=\accol{A^{(1)},A^{(2)},\ldots,A^{(M)}}$ is called set of $M$ decisions of finite set of decision elements $E$, such that:
\begin{equation}
\group{
A^{(1)}=\tuple{\accol{EW^+}^{(1)},\accol{EW^{\pm}}^{(1)},\accol{EW^-}^{(1)},Z^{(1)},SP^{(1)},DT^{(1)}}\\\\
A^{(2)}=\tuple{\accol{EW^+}^{(2)},\accol{EW^{\pm}}^{(2)},\accol{EW^-}^{(2)},Z^{(2)},SP^{(2)},DT^{(2)}}\\\\
\vdots\\\\
A^{(M)}=\tuple{\accol{EW^+}^{(M)},\accol{EW^{\pm}}^{(M)},\accol{EW^-}^{(M)},Z^{(M)},SP^{(M)},DT^{(M)}}
}
\end{equation}
\cite{conf/fedcsis/Sobieska-KarpinskaH12}
\end{defi}

\section{Optimization Problems}

\begin{defi}
A \term{neighborhood structure} is a function $\calN:\calS\rightarrow 2^\calS$ that assigns to every $s\in\calS$ a set of neighbors $\fun{\calN}{s}\subseteq\calS$. $\fun{\calN}{s}$ is called the neighborhood of $s$. Often, neighborhood structures are implicitly defined by specifying the changes that must be applied to a solution s in order to generate all its neighbors. The application of such an operator that produces a neighbor $s'\in\fun{\calN}{s}$ of a solution s is commonly called a \term{move}.\cite{alba05}
\end{defi}

\begin{defi}
A \term{locally minimal solution} (or \term{local minimum}) with respect to a neighborhood structure $\calN$ is a solution $\hat{s}$ such that $\forall s\in\neigh{\hat{s}}:\ffun{\hat{s}}\leq\ffun{s}$. We call $\hat{s}$ a \term{strict locally minimum} if $\forall s\in\neigh{\hat{s}}:\ffun{\hats}<\ffun{s}$.\cite{alba05}
\end{defi}

\section{Toxicology}

\begin{defi}[Performance comparison]
The predictive accuracies of two theories are statistically equivalent then the theory with better explanatory power has \term[Performance comparison]{better performance}. Otherwise the one with higher accuracy has better performance.
\cite{conf/ijcai/SrinivasanKMS97}
\end{defi}

