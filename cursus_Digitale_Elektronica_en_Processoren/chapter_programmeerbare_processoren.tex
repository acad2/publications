\chapter{Programmeerbare Processoren}
\chplab{programmableprocessors}
\chapterquote{Mensen hebben met computers gemeen dat ze ook niets bereiken zonder goede programmeurs.}{Toon Verhoeven, Nederlands aforist (??-??)}
\begin{chapterintro}
In dit hoofdstuk bespreken we programmeerbare processoren. Deze processoren verschillen van de niet-programmeren processoren omdat een gebruiker een programma -- een reeks van instructies -- kan uitvoeren op de processor en bijgevolg in grote mate het algoritme die de processor uitvoert zelf kan bepalen. Centrale processoreenheden (CPU's) zijn hiervan slechts een subset van de programmeerbare processoren. We bespreken eerst de hoe een instructie eruitziet en hoe we een schakeling kunnen ontwerpen om deze instructies uit toe voeren. Cruciaal hierbij zijn de verschillende adresseermodi. Vervolgens beschouwen we de twee grote instructie-families: RISC en CISC. We zullen voor beide een instructieset ontwerpen en de verschillende aspecten die hierbij komen kijken bespreken.
\end{chapterintro}
\minitoc[n]
\section{De Programmeerbare Processor}
We zullen in deze sectie het verschil bespreken tussen een niet-programmeerbare processor (zie \chpref{nonprogramming}) en een programmeerbare processor. Algemeen is deze grens eerder vaag. Ook bij een niet programmeerbare processor zullen de controller en het datapad meestal be\"invloed worden door signalen van buiten de schakeling. Sommige technici kunnen door deze invoer te manipuleren de processor een algoritme laten uitvoeren waarvoor de schakeling niet ontworpen was.
\paragraph{}
Een duidelijke grens kunnen we trekken bij de controller. Bij conventie stellen we dat een processor niet-programmeerbaar is wanneer de schakeling wordt aangestuurd met een vaste controller. In het geval we dus een ander algoritme willen uitvoeren zullen we een ander controller moeten implementeren om het uit te voeren. Bij een programmeerbare processor dient men de controller niet aan te passen. De controller beschikt immers over een geheugen waarin het programma geladen kan worden. Door het geheugen aan te passen zal de controller het datapad anders aansturen waardoor een ander algoritme kan worden uitgevoerd. We kunnen dus stellen dat de eindige toestandsautomaat die in de controller werd ge\"implementeerd vast staat, onafhankelijk van het ingeladen programma. Het geheugen waaruit zo'n controller leest noemen we het \termen{programmageheugen}. De gegevens die van de controller naar dit geheugen stuurt worden het \termen{adres}, de \termen{programmateller} of de \termen{program counter (PC)} genoemd. De data van het programmageheugen naar de controller noemen we de \termen{instructie}.
\paragraph{}
Merk op dat de definitie hierbij geen concrete uitspraak doet over hoe een programma of instructie er precies dient uit te zien. De definitie impliceert bijvoorbeeld niet dat de processor elk te beschrijven algoritme moet kunnen uitvoeren. Hierbij kunnen we bijvoorbeeld denken aan een ``Graphical Processing Unit (GPU)''. Een GPU is een programmeerbare processor die gespecialiseerd is in grafische taken. De instructieset is dan ook eerder beperkt tot grafische operaties. Hoewel men dergelijk processoren meestal niet kan programmeren om bijvoorbeeld Dijkstra's algoritme uit te voeren, is de processor wel programmeerbaar.
\paragraph{}
\importtikzfigure{processor-programming}{De structuur van een programmeerbare processor.}
\figref{processor-programming} toont hoe een programmeerbare processor er in grote lijnen uitziet. Merk op dat het enige verschil tussen deze figuur en \figrefpag{processorInformationStreams} de introductie van een programmageheugen is.
\section{Instructies en Velden}
Nu we de structuur van een programmeerbare processor hebben voorgesteld, zullen we in deze sectie de verschillende aspecten en terminologie van een programma bespreken.
\subsection{Programma}
Een algemeen aanvaarde definitie voor een \termen{programma} is een sequentie van instructies. De instructies zijn op zo'n manier bepaald en geordend dat ze samen een complexe (en nuttige) taak uitvoeren. In dit opzicht bevat een sequentie van instructies dus dezelfde informatie als de eindige toestandsmachine van de controller bij een niet-programmeerbare processor.
\subsection{Instructie}
Een instructie is een reeks van bits die de informatie van \'e\'en toestand in het ASM-schema of \'e\'en toestand in de eindige toestandsautomaat van de controller voorstellen. Door pipelining kan een instructie of multicycling kan een instructie echter meerdere klokcycli duren. Dit kan men implementeren door bijvoorbeeld een andere volgende instructie te kiezen. Om een toestand voor te stellen zijn drie types informatie vereist:
\begin{itemize}
 \item De aansturing van het datapad: het bepalen van de stuursignalen naar de verschillende functionele eenheden, registers, tri-state buffers en multiplexers betrokken in het datapad.
 \item \termen{Data-uitwisseling}: sommige instructies bepalen welke informatie er ingeladen of weggeschreven wordt naar (externe) geheugens.
 \item De volgende instructie: de meeste algoritmes bevatten lussen en voorwaardelijke gedeeltes. Deze controle wordt ge\"implementeerd doordat de instructies (impliciet) bepalen wat de volgende instructie zal zijn.
\end{itemize}
Een instructie moet niet elk type informatie expliciet specificeren. We kunnen bijvoorbeeld denken aan het bepalen van de volgende toestand: meestal wordt een programma zo gestructureerd dat de volgende instructie bijna altijd op het volgende adres staat. In dat geval zullen enkel instructies die afwijken van deze regel dit moeten specificeren.
\paragraph{Notatie van een instructie}
Om instructies uit te drukken bestaan er twee typische notaties: de \termen{mnemonische notatie} en de \termen{actie-notatie}. In de mnemonische notatie specificeert men eerst de operatie gevolgd door het doel\footnote{De plaats waar het resultaat zal worden opgeslagen.} en de operanden. Verder worden zowel het doel en de operanden gespecificeerd aan de hand van adressen. Een typische instructie is bijgevolg \verb+add A B C+. Dit voorbeeld is een instructie uit de \verb+80x86+ instructieset. Mnemonische notatie wordt dan ook vaak gebruikt in assembleertalen (\verb+80x86+, ). Actie-notatie specificeert daarentegen eerst het doel, meestal gevolgd door bijvoorbeeld een pijl met daarna de functie en de operand. Een concreet voorbeeld van een instructie volgens deze notatie is \verb/Mem[A] <- Mem[B]+Mem[C]/. Actie-notatie is populair bij hardwarespecificatietalen.
\subsection{Instructieformaat}
De mnemonische notatie en de actie-notatie zijn manieren om instructies voor te stellen zodat ze leesbaar zijn voor mensen. In digitale logica wordt een instructie enkel voorgesteld door een sequentie aan bits. De ontwerper van een processor dient dan ook een \termen{instructieformaat} te specificeren: een beschrijving hoe een sequentie bits een instructie bepaalt. Men kan dit formaat natuurlijk vrij bepalen, maar meestal beoogt men een structurele opbouw: de instructie wordt onderverdeeld in \termen{velden}: groepen van bits waar een betekenis of een subtaak aan wordt toegekend. In de meeste instructieformaten komen volgende velden voor:
\begin{itemize}
 \item \termen{Instructietype}: een groep bits die de klasse van de instructie aangeeft (bijvoorbeeld een sprongbevel, een bewerking, een geprivilegieerde instructie,...)
 \item \termen{Opcode} ofwel \termen{operation code}: een groep bits die de bewerking voorstellen (bijvoorbeeld een optelling, vermenigvuldiging,...)
 \item Adres: een groep bits die de locatie van een operand of een resultaat specificeert. Een adres hoeft echter niet beperkt te zijn tot de locatie in een (extern) geheugen: ook registers en registerbanken kunnen soms worden geadresseerd.
 \item \termen{Adresseermode}: een adresseermode bepaalt hoe het adres gespecificeerd in bits wordt omgezet in een fysisch adres. Zo kan de adresseermode bijvoorbeeld bepalen dat het adres een register uit de registerbank specificeert of dat de adressen indirect\footnote{Bij indirecte adressering leest men de waarde van het geheugen uit op de gegeven locatie. Die waarde bepaalt dan de locatie van de effectieve waarde.} moeten worden berekend.
 \item Constante: bewerkingen zoals een optelling tellen soms een constante op bij een register. In dat geval moet de constante in de instructie worden ingebed.
\end{itemize}
Men dient op te merken dat een veld niet noodzakelijk een vaste lengte heeft of slechts \'e\'enmaal voorkomt. Stel bijvoorbeeld dat de adresseermode bepaalt dat de gegevens uit een registerbank moeten uitgelezen worden, verwachten we dat het adres korter zal zijn dan wanneer we het adres uit een RAM-geheugen halen. Verder zal men bij sommige operaties twee of meer operanden moeten selecteren. In dat geval is het dus mogelijk dat het adresveld meerdere keren voorkomt. Sommige processoren voorzien ook een instructieformaat waarbij men twee of meer bewerkingen kan specificeren die dan parallel worden uitgevoerd. In dat geval komt de opcode dus twee of meer keer voor.
\subsection{Generische Instructiecyclus}
Een processor voert een instructie doorgaans uit in vijf stappen. Deze stappen noemt men de generische instructiecyclus. De stappen zijn:
\begin{enumerate}
 \item Lees de instructie in: het programmageheugen wordt uitgelezen en de instructie wordt in het \termen{instructieregister (IR)} opgeslagen. De programmateller wordt verhoogd.
 \item Bereken de adressen: Op basis van de adresseermodi en de adressen in de instructie worden de echte adressen bepaald. Een adres uit een registerbank zal er dus anders uitzien dan een adres uit het RAM-geheugen.
 \item Lees de operanden: de adressen van de operanden worden uitgelezen en weggeschreven in tijdelijke registers.
 \item Voer de bewerking uit: op basis van de data in de operand-registers en de opcode kan men de relevante bewerking op de relevante data uitvoeren. Het resultaat wordt in een tijdelijk register geplaatst.
 \item Schrijf het resultaat weg: het resultaat wordt weggeschreven in een registerbank of RAM-geheugen (indien dit relevant is voor de bewerking).
\end{enumerate}
Deze cyclus wordt eindeloos herhaald en leent zich meestal erg goed tot pipelining: enkel wanneer de volgende instructie een operand moet inlezen die bepaald wordt door een instructie die kort ervoor is uitgevoerd moet de pipeline worden onderbroken. Men kan een sprongbevel uitvoeren door in de instructie de programmateller aan te passen.
\subsection{Uitvoeringssnelheid}
De uitvoeringssnelheid van een instructie hangt in grote mate af van twee factoren:
\begin{itemize}
 \item De snelheid van het datapad
 \item Het aantal toegangen tot extern geheugen.
\end{itemize}
We kunnen de snelheid van het datapad doorgaans opdrijven door meer hardware te voorzien die bijvoorbeeld bewerkingen in parallel uitvoeren. Het aantal toegangen tot extern geheugen kunnen we dan weer verlagen door kleine en simpele instructies te voorzien waardoor elke instructie maar een beperkt aantal operaties op het geheugen uitvoert.
\paragraph{}
De grootte van een instructie is echter een trade-off. Wanneer we grote instructies voorzien met een groot aantal bits laten we de programmeur toe om een complexe taak in zo'n instructie te specificeren. Bijgevolg verwachten we dat een programma uit een klein aantal van dergelijke instructies zal bestaan. Omdat de instructies echter complex zijn, verwachten we een traag datapad en veel geheugentoegangen. Wanneer de processor enkel simpele instructies aanbiedt kan het datapad deze snel uitvoeren, maar een programma zal een groot aantal instructies bevatten. De complexiteit van een \termen{instructieset} wordt dan ook soms uitgedrukt in het aantal adresvelden.
\subsection{Adresvelden}
In deze subsectie zullen we enkele instructiesets bespreken volgens het aantal adresvelden. Bij de verschillende instructiesets zullen we aantal geheugentoegangen berekenen die nodig zijn om de functie $\brak{a+b}\times\brak{a-b}$ uit te rekenen. Deze operatie wordt doorgaans niet als \'e\'en instructie aangeboden (tenzij bij processoren die taken uitvoeren waarbij deze bewerking zeer regelmatig zou voorkomen). We zullen dan ook uitgaan van een algemene instructieset die de optelling (\termen{Add-instructie}), aftrekking (\termen{Sub-instructie}) en vermenigvuldiging (\termen{Mul-instructie}) voorziet.
\paragraph{}
Alvorens we de instructiesets met elkaar kunnen vergelijken, zullen we eerst enkele aannames moeten maken over hoe gegevens en instructies kunnen worden ingelezen. We zullen uitgaan van een woordlengte\footnote{De woordlengte is het aantal bits die in een geheugen onder \'e\'en adres worden opgeslagen.} $w$. We maken de assumptie dat een instructie zonder geheugenadressen in \'e\'en woord\footnote{Een woord is een sequentie van $w$ bits met $w$ de woordlengte.} kan worden opgeslagen. Het geheugen omvat $2^w$ adressen, bijgevolg telt het geheugen $w\cdot 2^w$ bits en is elk adres voor te stellen met een woord. Een instructie met $k$ geheugenadressen kan dus worden opgeslagen in $k+1$ woorden. We vergelijken de instructiesets op basis van geheugentoegangen. Dit zijn dus het aantal toegangen om de instructie uit te lezen samen met het uitlezen en wegschrijven van gegevens die in de instructie worden gespecificeerd.
\subsubsection{Instructies met 3 adresvelden}
Een instructieset met drie adresvelden bepaalt meestal \'e\'en adres voor het resultaat en twee adressen voor de operanden. Bijvoorbeeld de \verb+Add a b c+ instructie berekent de optelling van de gegevens die op de geheugenplaatsen $b$ en $c$ staan en plaatst het resultaat dus in adres $a$. Om $\brak{a+b}\times\brak{a-b}$ dus uit te rekenen zullen we volgend programma uitvoeren:
\begin{verbatim}
Add c a b
Sub x a b
Mul c c x
\end{verbatim}
Per instructie voorzien we dus $4+3$ geheugentoegangen. $4$ instructietoegangen per instructie, $2$ leesoperaties voor de operanden en $1$ schrijfoperatie. Omdat we $3$ instructies uitvoeren vereist het programma dus $21$ geheugentoegangen. We kunnen echter opmerken dat in de laatste instructies we tweemaal hetzelfde adres vermelden. Dit soort instructies vormen dan ook de argumentatie om soms instructies met twee adresvelden te gebruiken.
\subsubsection{Instructies met 2 adresvelden}
Instructiesets met twee adresvelden zijn vrij populair. \verb+80x86+ is een voorbeeld van zo'n instructieset. In zo'n instructieset vertegenwoordigen het eerste en tweede adresveld de adressen van de operanden en het eerste veld ook het adres van het resultaat. Het eerste adres wordt bijgevolg overschreven.
\paragraph{}
Een probleem bij dit mechanisme is dat we soms na de bewerking de operanden willen kunnen hergebruiken om andere operaties uit te voeren. Zo willen we na het berekenen van $a+b$ nog over $a$ en $b$ kunnen beschikken om $a-b$ uit te rekenen. We kunnen de waarde kopi\"eren om dit probleem te vermijden. We kunnen de waarde van $x$ kopi\"eren naar adres $y$ met behulp van twee instructies: \verb+Sub y y+ en \verb+Add y x+. De meeste processoren voorzien echter een kopieer instructie: de \termen{Mov-instructie}. Het voordeel van deze instructie is dat naast het ophalen van de instructie slechts twee geheugentoegangen vereist zijn.
\paragraph{}
We kunnen het algoritme dan ook als volgt implementeren:
\begin{verbatim}
Mov c a
Add c b
Mov x a
Sub x b
Mul c x
\end{verbatim}
De Mov-instructie vereist in totaal $5$ geheugentoegangen, de overige instructies vereisen $6$ geheugentoegangen. In totaal vereist het uitvoeren van het algoritme dus $28$ geheugentoegangen. We dienen echter wel op te merken dat de instructies sneller zullen worden uitgevoerd.
\subsubsection{Instructies met 1 adresvelden}
We kunnen de instructieset verder reduceren tot \'e\'en adresveld per instructie. Dit doen we met behulp van een \termen{accumulator (ACC)}. Een accumulator is een speciaal register die dienst doet als zowel de eerste operand en het register waar het resultaat in wordt geplaatst. Men kan deze instructieset dus vergelijken met de eerste instructieset, maar waarbij de eerste operator altijd een vast adres voorstelt. Het voordeel van een accumulator is de implementatie door middel van een register: de accumulator inlezen of resultaten wegschrijven vereist bijgevolg geen geheugentoegang.
\paragraph{}
Ook wanneer we een accumulator gebruiken zullen we soms tussenresultaten tijdelijk in een andere variabele willen opslaan om de waarde later in te lezen. We kunnen hier geen gebruik maken van de Mov-instructie omdat het resultaat altijd vast staat: de accumulator. Daarom worden twee nieuwe instructies ge\"introduceerd: de \termen{Load-instructie} leest het adres uit en plaatst de waarde in de accumulator, de \termen{Store-instructie} schrijft de waarde van de accumulator weg in het opgegeven adres. De Store-instructie is bijgevolg een instructie waar de accumulator geen dienst doet als de ontvanger van het resultaat.
\paragraph{}
We kunnen het algoritme realiseren met volgende code:
\begin{verbatim}
Load a
Add b
Store x
Load a
Sub b
Mul x
Store c
\end{verbatim}
Elke instructie vereist telkens $3$ geheugentoegangen: $2$ om de instructie uit te lezen en $1$ geheugentoegang om het adres uit te lezen of de resultaten weg te schrijven. Omdat het algoritme in $7$ instructies kan worden ge\"implementeerd, zijn er in totaal $21$ geheugentoegangen vereist.
\subsubsection{Instructies zonder adresvelden}
Sommige instructiesets bevatten geen adressen als operanden. In een dergelijk systeem moeten we echter wel een systeem implementeren die zelf de adressen voorstelt.
\paragraph{}
Een populaire methode werkt met een stapelgeheugen. In zo'n systeem beschouwen we een stapel die groeit bij een een Load-instructie. Wanneer een instructie een berekening uitvoert worden de operanden uit de bovenste elementen van de stapel gehaald. Deze elementen worden van de stapel gehaald en het resultaat wordt vervolgens op de stapel gezet. Ook in een dergelijk systeem is er soms nood aan het opslaan van tussenresultaten om deze later te hergebruiken. Ook hiervoor gebruiken we de store operatie. De operatie neemt als argument een adres van de stapel: het aantal elementen onder de top. Ook dit kan men als een adres zien. Men maakt echter meestal de assumptie dat deze waarde niet buitengewoon groot is en de waarde dus in de instructie kan worden meegenomen. Bijgevolg bevat de instructie dus geen adres. Omdat het bovenste gedeelte van de stapel meestal met een registerbank wordt ge\"implementeerd, vereisen de bewerkingen bijgevolg geen geheugentoegangen.
\paragraph{}
We kunnen het algoritme implementeren met volgende instructies:
\begin{verbatim}
Load a
Load b
Add
Load a
Load b
Sub
Mul
Store c
\end{verbatim}
Om de impact te berekenen moeten we opnieuw een onderscheid maken tussen twee soorten instructies: Load- en Store instructies vereisen twee geheugentoegangen ($1$ geheugentoegang om de instructie op te halen en $1$ instructie om het resultaat op te halen of weg te schrijven) de overige instructies vereisen slechts \'e\'en geheugentoegang. In totaal vereist dit programma dus $13$ toegangen tot het geheugen.
\subsubsection{Instructies met registerbank-adressen: dubbele adressering}
Tot slot dienen we nog te vermelden dat een adresveld niet noodzakelijk altijd een geheugenadres moet omvatten. Men kan bijvoorbeeld een bit in dit veld voorzien die bepaalt of het adres een geheugenadres specificeert of het adres van een registerbank. Daarnaast kan de interpretatie van een dergelijk adres ook afhangen van de instructie. Moderne processoren interpreteren bijvoorbeeld vaak de adressen bij bewerkingen als registerbank-adressen en de tweede operand bij een Load- of Store-instructie als een geheugenadres. Vermits een algoritme vooral met tussenresultaten zal rekenen verwachten we een tijdswinst omdat we niet telkens de operanden uit het geheugen moeten uitlezen.
\paragraph{}
Een dergelijke instructieset kan ook instructies met variabele lengte beschouwen. Sommige instructies omvatten immers geen geheugenadressen, andere wel. In dat geval kan de eerste instructie bijvoorbeeld aanleiding geven om het volgende woord in een instructieregister in te lezen, of de instructie meteen uit te voeren.
\paragraph{}
Registeradressen worden meestal voorgesteld met een prefix \verb+R+. In het geval van een dergelijke instructieset ziet het programma er als volgt uit:
\begin{verbatim}
Load R1 a
Load R2 b
Add R3 R1 R2
Sub R4 R1 R2
Mul R5 R3 R4
Store c R5
\end{verbatim}
Bewerking instructies worden voorgesteld in \'e\'en woord en vereisten geen extra geheugentoegang. Bijgevolg vereisen ze \'e\'en geheugentoegang. Load- en Store-bewerkingen vereisen $3$ geheugentoegangen: $2$ bij het inlezen van de instructie en $1$ bij het inlezen of wegschrijven van de data. In totaal vereist het programma dan ook $12$ keer toegang tot het geheugen.
\subsubsection{Besluit}
Er zijn verschillende instructiesets mogelijk met een verschillend aantal adresvelden. Instructies met een groot aantal adresvelden laten compacte programma's toe maar vereisen soms onnodig toegang tot het geheugen. Deze extra belasting komt in twee vormen: het inlezen van de adresvelden van de instructie en het uitlezen of wegschrijven van data in de vermelde geheugenadressen.
\paragraph{}
Een instructieset met minder adresvelden zal minder vaak onnodig toegang tot het geheugen aanvragen. Anderzijds wordt het programma langer waardoor de processor meer instructies uit het geheugen met uitlezen.
\subsection{Adresseermodi}
In de loop der jaren zijn er verschillende manieren ontwikkeld om een geheugenadres te bepalen op basis van een adresveld. Deze methodes noemen we adresseermodi. Adresseermodi hebben als primair doel het aantal bits te reduceren die het adresveld in beslag neemt. Anderzijds laten verschillende adresseermodi soms toe om meer te realiseren per instructie en dus tot compactere programma's te schrijven.
\paragraph{}
Ook in hogere programmeertalen maakt men impliciet gebruik van adresseermodi. We kunnen bijvoorbeeld denken aan arrays. Wanneer men in \verb+Java+ het tiende element van een array \verb+a+ wil uitlezen schrijft men \verb+a[10]+. Impliciet stelt men echter het adres dat tien plaatsen verder dan het begin van het record voor \verb+a+ ligt. Adresseermodi kunnen programma's dus ook leesbaarder maken.
\subsubsection{Impliciete adressering}
\termen{Impliciete adressering} is een adresseermode waarbij een adresveld niet vermeld wordt in de instructie maar door de processor zelf kan worden berekend.
\paragraph{}
Dit is bijvoorbeeld het geval bij processoren met een stapelgeheugen. In een dergelijke instructieset worden de adressen afgeleid uit de toestand van de stapel: de bovenste elementen bevatten de data van de operanden. De processor rekent deze aspecten dus zelf uit.
\paragraph{}
Ook bij processoren die werken met een accumulator is dit het geval: men vermeldt immers de bestemming van de data niet. Dergelijke processoren bieden meestal een instructie aan om de gegevens uit de accumulator te verwijderen: de \termen{CLRA-instructie}.
\subsubsection{Onmiddellijke adressering}
Behalve in het adresveld de plaats in het geheugen te specificeren waar de data moet worden opgehaald, kunnen we ook de data zelf opslaan in een adresveld. Deze vorm van adressering noemen we \termen{onmiddellijke adressering}. Dit is bijvoorbeeld het geval wanneer we werken met constanten.
\subsubsection{Directe adressering}
Meestal lezen we operanden uit met behulp van een adres. Dit adres verwijst ofwel naar een geheugenadres ofwel naar een index van een registerbank. In beide gevallen spreken we over \termen{directe adressering}. Het is meestal voordelig om een registerbank te gebruiken. Dit omwille van twee redenen: een registerbank bevat minder adressen en de toegang is sneller. Omdat een registerbank typisch $8$ tot $256$ registers bevat, is bijgevolg de lengte van een registeradres tussen de $3$ en $8$ bits, terwijl een geheugenadres typisch tussen de $32$ en $64$ bits lang is. We besparen dus ook tijd bij het inladen van de instructie.
\subsubsection{Indirecte adressering}
Soms kennen we de plaats waar de data in het geheugen staat niet expliciet. Stel bijvoorbeeld dat we werken met een heap\footnote{Een heap is een geheugenruimte waar men dynamisch records kan toevoegen en terug verwijderen.}, hangt de plaats waar de data staat meestal af van de manier hoe het programma eerder werd doorlopen. Het adres wordt dan ook ergens anders bewaard in het geheugen of een registerbank.
\paragraph{}
Indirecte adressering is een belangrijke vorm in programma's. Naast werken met een onbekend adres laat het ook toe het adres mee te geven wanneer we bijvoorbeeld een subroutine uitvoeren die een ``pointer'' vereist.
\paragraph{}
\termen{Indirecte adressering} maakt het mogelijk om in \'e\'en instructie de operand in te lezen waarvan het adres ergens in het geheugen staat. In dat geval dienen we dus het adres te specificeren waar het adres staat.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{address-indirect}{Indirecte adressering}
\importtikzsubfigure{address-indirect-register}{Register-indirecte adressering}
\caption{Indirecte adressering}
\end{figure}
\paragraph{}
Tweemaal het geheugen uitlezen in \'e\'en instructie is echter een dure operatie. Daarom zal men de adressen doorgaans in een registerbank opslaan. In dat geval spreken we dan ook van \termen{register-indirecte adressering}.
\subsubsection{Relatieve adressering}
Hedendaagse besturingssystemen ondersteunen doorgaans multiprogramming: het tegelijk uitvoeren van verschillende programma's. Bijgevolg worden verschillende programma's tegelijk in het register geladen. De compiler van een programma weet doorgaans op voorhand niet waar het programma in het geheugen zal worden ingeladen. Wanneer een programma echter een sprongbevel uitvoert, moet het adres van het sprongbevel wijzen naar het correcte adres.
\paragraph{}
Het aangehaalde voorbeeld is \'e\'en van de redenen om \termen{relatieve adressering} toe te passen. Bij relatieve adressering houdt de processor een \termen{basisadres} bij in een impliciet register. Dit basisadres wordt bij het gegeven adres opgeteld om het werkelijke adres te bepalen. Het adresveld wordt in dat geval de \termen{offset} genoemd.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{address-relative}{Relatieve adressering}
\importtikzsubfigure{address-relative-register}{Register-relatieve adressering}
\caption{Relatieve adressering}
\figlab{address-relative-general}
\end{figure}
\paragraph{}
Naast het verzekeren van correcte spronginstructies kan relatieve adressering ook tot kortere instructiewoorden leiden. We kunnen bijvoorbeeld een registerbank voorzien die verschillende basisadressen voorziet. De basisadressen kunnen bijvoorbeeld wijzen naar datastructuren die vaak gebruikt worden. Naast een veld die het register in de registerbank specificeert, dient men een veld te voorzien die de offset vanaf het basisadres voorstelt. Een dergelijke vorm van adressering noemen we \termen{register-relatieve adressering}.
\subsubsection{Ge\"indexeerde adressering}
We kunnen ook de twee velden omdraaien door het basisadres in de instructie onder te brengen en de offset in een impliciet register of een registerbank op te slaan. Deze vormen van adressering noemen we \termen{ge\"indexeerde adressering}. Ge\"indexeerde adressering is vooral interessant voor gegevensstructuren met eigen indexsystemen. We denken hierbij bijvoorbeeld aan arrays, matrices, stapels, wachtrijen,... In het register staat immers de index van de datastructuur zelf. Bij een array is dit bijvoorbeeld $i$ indien we het $i$-de element willen uitlezen.
\paragraph{}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{address-indexed}{Ge\"indexeerde adressering}
\importtikzsubfigure{address-indexed-register}{Register-ge\"indexeerde adressering}
\caption{Ge\"indexeerde adressering}
\figlab{address-indexed-general}
\end{figure}
De structuur van ge\"indexeerde adressen op \figref{address-indexed-general} lijkt sterk op de structuur van relatieve adressen op \figref{address-relative-general}. Het verschil is echter dat een basisadres een volwaardig adres is en dus makkelijk $32$ bits telt. De offset daarentegen telt doorgaans slechts $3$ tot $8$ bits. Bij ge\"indexeerde adressering zijn de instructies dus groter.
\paragraph{}
Ook bij deze vorm van adressering kunnen we gebruik maken van een register bank. In dat geval wordt het adres van de registerbank bepaald door een veld in de instructie. Uit dit adres wordt dan de offset opgeslagen in registerbank berekend. Deze vorm van adressering noemen we naar analogie \termen{register-ge\"indexeerde adressering}.
\subsubsection{Ge\"indexeerde adressering met autoincrement/autodecrement}
Meestal leest men een bepaald element uit een array, matrix,... uit binnen een lus in het programma. De meeste programma's zullen dan ook de volledige array of een significant deel overlopen. Dit gebeurt doorgaans in een logische volgorde van links naar rechts of omgekeerd. Men kan het mechanisme achter ge\"indexeerde adressering uitbreiden met \termen{autoincrement} en/of \termen{autodecrement}. Wanneer we deze adresseringmode toepassen wordt het impliciete register die de offset bijhoudt na het uitvoeren van de opdracht automatisch opgehoogd of verlaagd. Hierdoor kan men bij een volgende instructie meteen het volgende of vorige element in de array uitlezen zonder eerst zelf manueel het register op te hogen. Dit kan voordelig zijn omdat het uitrekenen van de nieuwe waarde voor het offset-register parallel kan gebeuren met het uitvoeren van de instructie zelf.
\paragraph{}
\importtikzfigure{address-index-increment}{Ge\"indexeerde adressering met autoincrement/autodecrement.}
\figref{address-index-increment} illustreert het principe. Op basis van de een de instructie kiest men welke waarde door de multiplexer stroomt, deze waarde wordt bij de originele offset opgeteld en vervolgens in het register ingeladen. Door dezelfde instructie vervolgens daarna uit te voeren, zullen we een ander geheugenadres uitlezen bij het bepalen van de operand.
\paragraph{}
Soms bestaat een array niet uit bytes maar uit bijvoorbeeld long integers (8 bytes). Bij sommige processoren kan men dan ook de staplengte bepalen door deze in een veld in de instructie te specificeren, of weg te schrijven in een speciaal hiervoor bestemd register.
\section{Processorontwerp}
Nu we de belangrijkste aspecten van een instructieset hebben besproken, zullen we het ontwerp van de processor zelf in detail bespreken. We zullen eerst de algemene ontwerpcyclus waarna we het ontwerp bespreken voor de twee grote families van instructiesets: CISC en RISC.
\subsection{RISC en CISC}
In de vorige sectie werden instructiesets vergeleken volgens het aantal adresvelden per instructie. Het aantal adresvelden vormt dan ook de belangrijkste basis om instructiesets in te delen in \'e\'en van de twee families: de \termen{Complex Instruction Set Computer (CISC)} of \termen{Reduced Instruction Set Computer (RISC)}.
\subsubsection{CISC}
In het geval van CISC beschouwt men een grote instructieset met complexe en trage instructies. De instructieset omvat meestal een groot aantal verschillende operaties waarbij men ook een groot aantal adresseermodi voorziet. Dit leidt meestal tot een complex datapad met veel functionele eenheden registers en complexe verbindingen die de datastroom controleren. Het gevolg is dat dergelijke processoren aan een lage klokfrequentie werken. De programma's zijn echter vrij kort en men hoopt meestal snelheidswinst te boeken door de operaties die worden uitgevoerd bij een operatie in parallel op het datapad uit te voeren. Typische CISC instructiesets zijn \verb+System/360+, \verb+PDP-11+, \verb+VAX+, \verb+Motorola 68k+ en \verb+80x86+.
\subsubsection{RISC}
Een RISC processor omvat een kleine instructieset die uit een klein aantal eenvoudige instructies bestaat. Een instructie omvat hoogstens \'e\'en adresveld en meestal zijn slechts enkele adresmodi beschikbaar. Een eenvoudige instructieset leidt echter tot een eenvoudig datapad waardoor men een hoge kloksnelheid kan aanbieden. De programma's zijn vrij lang maar men hoopt meestal om hierdoor neven-operaties die soms ongewild worden uitgevoerd op een CISC processor te vermijden. Typische RISC instructiesets zijn \verb+DEC Alpha+, \verb+ARM+, \verb+SPARC+, en \verb+MIPS+.
\subsubsection{Evolutie}
Men merkt dat er een evolutie is van CISC processoren naar RISC processoren. Deze evolutie werd vooral gepromoot door onderzoek bij IBM dat aantoonde dat meestal een beperkte subset van de aangeboden instructies effectief door programma's werd gebruikt. Dit effect werd ook versterkt door de komst van compilers die er meestal niet in slagen alle aspecten van een CISC instructieset automatisch uit te buiten. Andere aspecten die voor het gebruik van RISC processoren pleiten zijn de grootte van de chip, de energieconsumptie en de kostprijs.
\subsection{Ontwerpcyclus}
\importtikzfigure{processor-design-cycle}{De processorontwerp-cyclus.}
\figref{processor-design-cycle} beschrijft de vijf fases bij het ontwerpen van een processor:
\begin{enumerate}
 \item Ontwerp van de instructiecyclus: in deze fase stelt men een set van mogelijke instructies op, meestal gaan de instructies gepaard met een informele beschrijving van het effect van de instructie.
 \item Instructieset-stroomschema: in deze fases worden per instructie alle betrokken operaties beschreven. De meeste instructies zullen immers verschillende effecten teweegbrengen. Bij de \verb+80x86+-instructieset zal bijvoorbeeld naast de bewerking ook de programmateller worden opgehoogd en zullen bepaalde registers op basis van het resultaat worden aangepast.
 \item Allocatie van het datapad: op basis van de vereiste bewerkingen kunnen we bepalen welke componenten we in het datapad zullen moeten voorzien. Dit omvat een beschrijving van de vereiste registers en functionele eenheden. Indien dit tot een duur datapad leidt kan men beslissen om de instructieset opnieuw te herbekijken en begint men dus terug met fase 1.
 \item Op basis van de beschikbare datapad componenten kan men een ASM-schema opstellen. Doorgaans wordt een instructie niet in \'e\'en klokcyclus uitgevoerd. De verschillenden vereiste operaties worden dus uitgevoerd in verschillende toestanden in het ASM-schema. Dit schema beschrijft dan ook de verschillende registertransfers per klokcyclus.
 \item Ontwerp van de controller en het datapad: op basis van het ASM-schema kunnen we vervolgens een datapad en controller synthetiseren. De methodologie van deze synthese staat beschreven in \chpref{nonprogramming}.
\end{enumerate}
\subsection{Complex Instruction Set Computer (CISC)}
In deze subsectie zullen we het proces doorlopen bij het ontwerpen van een CISC processor.
\subsubsection{Ontwerp Instructieset}
In de eerste stap zullen we een CISC instructieset bepalen. We bepalen eerst de specificaties van het geheugen waarmee de processor werkt. Bij wijze van voorbeeld zullen we een $2^{16}\times 16$-bit geheugen beschouwen. De woordlengte is dus $16$ bit en elk adres kan voorgesteld worden met behulp van $16$ bits. We beschouwen ook een registerbank met $8$ registers. Elk registeradres kan dus voorgesteld worden met $3$ bits.
\paragraph{}
Uit de specificaties van het geheugen kunnen we afleiden dat een adresveld bij voorkeur ook $16$ bit groot is. De rest van de instructie zullen we ook voorstellen met behulp van $16$ bit. We beschouwen vier verschillende types van instructies:
\begin{enumerate}
 \item \termen{Registerinstructies}: instructies die bewerkingen uitvoeren met $1$ of $2$ operanden en $1$ doelregister.
 \item \termen{Verplaatsinstructies}: instructies die de gegevens van een register of geheugenadres kopi\"eren naar een register of geheugenadres.
 \item \termen{Spronginstructies}: instructies die de programmateller aanpassen. Deze instructies bepalen bijgevolg het verloop van het programma.
 \item Overige instructies: dit zijn instructies zoals \termen{No Operation (NOP)}\footnote{De ``No Operation'' is een instructie die geen effect heeft. Deze instructie wordt gebruikt bij pipelining om ruimte op te vullen in de pipeline zodat instructies kunnen wachten tot andere instructies zijn uitgevoerd.}.
\end{enumerate}
We voorzien in een instructie dan ook twee bits om het type voor te stellen. De instructies vereisen hoogstens drie registers. In elke registers zullen we daarom drie velden van telkens $3$ bits voorzien om het doelregister -- \mbox{Bestemming} -- en de twee operandregisters \mbox{Operand 1} en \mbox{Operand 2} voor te stellen. Vermits een instructie $16$ bits telt en we in totaal reeds $11$ bits hebben toegewezen, blijven er $5$ bits over voor de opcode. We hebben bijgevolg een instructieformaat gedefinieerd zoals weergegeven op \figref{cisc-bitstructure-general}.
\importtikzfigure{cisc-bitstructure-general}{De bitstructuur van de CISC instructieset.}
\paragraph{}
Het type en de opcode bepalen samen welke instructie zal worden uitgevoerd. We dienen echter nog bewerkingen toe te kennen aan de verschillende waardes. Hiervoor voorzien we \tblrefs{cisc-registerinstructions,cisc-moveinstructions,cisc-jumpinstructions,cisc-otherinstructions} die de instructies per type beschrijven.
\paragraph{Registerinstructies}
\importtabulartable{cisc-registerinstructions}{De registerinstructies van de CISC-processor (type $00$).}
De registerinstructies worden allemaal uitgevoerd op registeradressen en worden opgedeeld in drie categorie\"en: aritmetische, logische en schuifoperaties. De categorie\"en worden bepaald door de eerste twee bits: wanneer $o_4$ laag is beschouwen we een schuifoperatie, in het andere geval beschouwen we ofwel een aritmetische of logische operatie. Bij een schuifoperatie bepaalt $o_3$ of we naar links of naar rechts schuiven. De overige drie bits bepalen vervolgens het aantal bits waarover we schuiven. In het andere geval bepaalt $o_3$ of we aritmetische (laag) of logische operatie (hoog beschouwen). We delen de aritmetische operaties verder op in optelling/aftrekking-bewerkingen en vermenigvuldiging/deling operaties. $o_2$ deelt de operaties verder in zodat bij bewerkingen met twee operanden $o_1$ laag is en we in het andere geval bewerkingen met \'e\'en operand beschouwen. We beschouwen volgende operaties: optelling, aftrekking, increment, decrement, vermenigvuldiging, deling, \termen{vierkantswortel} en negatie. In het geval van logische bewerkingen bepalen de overige drie bits welke operatie we uitvoeren: AND, NAND, OR, NOR, XOR, XNOR, \termen{mask} en invert. De verschillende instructies worden voorgesteld in \tblref{cisc-registerinstructions} samen met een formele beschrijving van de bewerking.
\paragraph{Verplaatsinstructies}
\importtabulartable{cisc-moveinstructions}{De verplaatsinstructies van de CISC-processor (type $01$).}
Verplaatsinstructies zijn instructies die gegevens tussen het geheugen en de registerbank kopi\"eren. Er zijn in dit geval slechts twee basisinstructies mogelijk: kopi\"eren naar het geheugen (\termen{store}) of kopi\"eren naar de registerbank (\termen{load}). We bepalen dit met behulp van de eerste bit $o_0$. Met de overige vier bits kunnen we vervolgens de adresseermode bepalen. De eerste bit van de adresmodus bepaalt of de instructie een adresveld voorziet. Dit is nuttig omdat de hardware snel moet kunnen beslissen of dit adresveld ook moet worden uitgelezen. Indien $m_3$ dus laag is maken we gebruik van een adresveld, in het andere geval kan men het adres afleiden uit de gegevens in de registervelden. De overige bits bepalen vervolgens de soort adressering: onmiddellijk ($000$), direct ($001$), indirect ($010$), relatief ($011$), ge\"indexeerd ($100$) en registerkopie ($101$). Afhankelijk van het feit of we een adresveld beschouwen is de adressering dan bijvoorbeeld relatief of register-relatief. Verder zijn sommige combinaties niet mogelijk: we kunnen bijvoorbeeld onmogelijk de waarde van een register naar een constante kopi\"eren wanneer we onmiddellijke adressering zouden gebruiken. Wanneer we de verschillende mogelijkheden uitproberen bekomen we de instructieset in \tblref{cisc-moveinstructions}.
\paragraph{Spronginstructies}
\importtabulartable{cisc-jumpinstructions}{De spronginstructies van de CISC-processor (type $10$).}
Doorgaans beschouwt men vier verschillende soorten sprongbevelen:
\begin{itemize}
 \item \termen{Ongeconditioneerde sprong (JMP)}: in dit geval wordt de programmateller gezet op het opgegeven adres.
 \item \termen{Geconditioneerde sprong (CJMP)}: dit is een spronginstructie die enkel wordt uitgevoerd als aan een bepaalde voorwaarde wordt voldaan. Hiervoor houdt de processor een \termen{statusregister} bij. Een bit in het statusregister noemt men meestal een \termen{statusvlag}\footnote{Met het concept vlag introduceert men meestal een terminologie: de vlag is gehesen wanneer de bit op $1$ staat.}. Sommige instructies die we verder zullen beschouwen kunnen op basis van een bepaalde voorwaarde een $0$ of een $1$ naar dat register schrijven. Enkel wanneer het statusregister op $1$ staat wordt de programmateller op het opgegeven adres gezet. In het andere geval wordt de programmateller opgehoogd.
 \item \termen{Subroutine sprong (JSR)}: Wanneer het programma een subroutine wil uitvoeren, wordt het terugkeeradres eerst op een stapel gezet. Dit terugkeeradres is de opgehoogde programmateller. Nadat de stapel is verhoogd wordt de programmateller vervolgens aangepast zodat de processor aan het begin van de subroutine staat.
 \item \termen{Subroutine terugkeer (RTS)}: Eenmaal we de subroutine hebben uitgevoerd is het de bedoeling dat het processor terugkeert naar het stuk code net achter de plaats waar de subroutine werd opgeroepen. Omdat verschillende stukken code een subroutine kunnen oproepen werd daarom dit adres op de stapel geplaatst. Door het adres uit te lezen van de stapel en de stapel met \'e\'en element te reduceren bereikt de processor de correcte toestand.
\end{itemize}
Vermits we slechts vier instructies beschouwen kunnen we de instructies voorstellen met behulp van twee bits. De overige bits zijn dan ook niet relevant. \tblref{cisc-jumpinstructions} beschrijft het formaat van verschillende spronginstructies samen met een formele beschrijving.
\paragraph{Overige instructies}
\importtabulartable{cisc-otherinstructions}{De overige instructies van de CISC-processor (type $11$).}
De voorwaardelijke sprong leest het statusregister uit. Tot nu toe hebben we echter nog geen instructies ge\"introduceerd die de waarde van het statusregister aanpast. Hiervoor voorzien we zes vergelijking-operaties: \termen{groter dan (GT)}, \termen{groter dan of gelijk aan (GE)}, \termen{kleiner dan (LT)}, \termen{kleiner dan of gelijk aan (LE)}, \termen{gelijk aan (EQ)} en \termen{niet gelijk aan (NE)}. Indien aan de voorwaarde wordt voldaan wordt het statusregister op $1$ gezet, in het andere geval op $0$. Soms wenst men ook complexere condities te berekenen. Daarom voorzien we ook twee overige instructies die het statusregister aanpassen: \termen{zet status (SetS)} en \termen{reset status (ClrS)}. Tot slot introduceren we ook twee andere operaties: de no operation (NOP) en \termen{reset register (ClrR)}. No-operation kan worden gebruikt als we werken met pipelining om de pipeline op te vullen met instructies waardoor de instructies na de no operation-instructie wachten tot de instructie ervoor is afgelopen. Het op $0$ zetten van een register is soms nuttig alvorens we bijvoorbeeld de som van een array willen berekenen en vormt een alternatief voor de het inladen van een constante vermits de laatste instructie twee woorden vereist. Het instructieformaat van de overige instructies staat in \tblref{cisc-otherinstructions}.
\paragraph{Machinetaal}
Het binaire patroon van de instructies wordt ook wel de \termen{machinetaal} genoemd. Het is immers een formele beschrijving hoe communicatie met de processor verloopt. Een programmeur kan een programma schrijven in machinetaal door elementen van deze taal in het geheugen in te laden. Zo zal bijvoorbeeld de de instructie $0010000111110000_2$ een optelling realiseren die de som van registers $R6$ en $R0$ berekend en opslaat in register $R7$. We kunnen dit signaal als volgt decoderen:
\begin{equation}
\underbrace{00}_{\mbox{registerbewerking}}\overbrace{10}^{\mbox{aritmetisch}}\underbrace{000}_{\mbox{optelling}}\overbrace{111}^{\mbox{D}=R7}\underbrace{110}_{\mbox{s1}=R6}\overbrace{000}^{\mbox{s2}=R0}
\end{equation}
Deze \termen{interpretatie} van de machinecode wordt op hardware niveau uitgevoerd met behulp van logische poorten in de controller. Om schrijffouten te vermijden zullen programmeurs doorgaans de broncode in hexadecimale cijfers schrijven. Dit maakt de instructies compacter en vermijdt schrijffouten door bijvoorbeeld een $1$ of $0$ te vergeten. De instructie kunnen we dus ook voorstellen als $21\mbox{F}0_{16}$.
\paragraph{Assembleertaal}
Hoewel de hexadecimale voorstelling de meeste schrijffouten voorkomt, vormt dit geen gemakkelijke basis om programma's te schrijven. De hexadecimale code is immers niet makkelijk leesbaar omdat de bits niet altijd in groepen van vier zijn gestructureerd en we bijgevolg niet snel kunnen bepalen of een bepaald binair getal overeenkomt met een optelling. Daarom maakt men meestal gebruik van een \termen{assembleertaal}. Een assembleertaal is een mnemonische voorstelling van de instructie en vormt een \'e\'en-op-\'e\'en relatie met de binaire instructies. \tblrefs{cisc-registerinstructions,cisc-moveinstructions,cisc-jumpinstructions,cisc-otherinstructions} bevatten daarom ook een kolom die het equivalent in een zelf ontwikkelde assembleertaal voorstelt.
\paragraph{Assembleerprogramma}
Een programma geschreven in de assembleertaal naar een equivalent programma in machinetaal gebeurt door een \termen{assembleerprogramma}. Dergelijke programma's werken met een eenvoudige opzoektabel die per mnemonische instructie het binaire equivalent bevat. De meeste assembleerprogramma's bieden bovendien extra gebruiksgemak aan: symbolische adressen en labels.
\paragraph{}
Wanneer we gegevens uit het geheugen lezen of wegschrijven dienen we een adres op te geven. De programmeur moet daarom bijhouden op welke plaats welke data precies staat. De meeste assembleerprogramma's nemen deze taak echter gedeeltelijk over met \termen{symbolische adressen}. Een programmeur gebruikt hierbij een symbolische naam en het programma kent zelf een adres toe. Dit leidt niet alleen tot gebruiksgemak maar voorkomt ook dat programmeurs per ongeluk een fout adres opgeven.
\paragraph{}
Ook wanneer we sprongbevelen uitvoeren dienen we een adres op te geven. Het probleem met expliciete adressen is dat wanneer we een instructie invoegen alle adressen erna opschuiven. Om dit probleem te verhelpen werken assembleerprogramma's met een \termen{label}. Een label is een symbolische markering bij een bepaalde instructie. Wanneer men vervolgens een sprong-instructie invoegt zet de programmeur de symbolische markering op de plaats waar het adres moet staan. Het assembleerprogramma houdt vervolgens zelf bij met welk adres dit label overeenkomt en vervangt de symbolische markering bij sprongbevel door een expliciet adres.
\paragraph{Voorbeeld}
Bij wijze van voorbeeld zullen we een programma beschrijven in zowel een hoog-niveau programmeertaal, de assembleertaal en de machinetaal. Het programma berekent tegelijk het minimum, maximum en de som van 1024 getallen in een array \verb+A+. Wanneer we dit in bijvoorbeeld \verb+Pascal+ implementeren schrijven we volgende code:
\importlisting[Pascal]{pascal-minmaxsum}{Hoog niveau beschrijving van het min-max-sum algoritme.}
In het codefragment in \lstref{pascal-minmaxsum} maken we de assumptie dat een ander deel van het programma waardes in \verb+A+ zal laden. We houden verder drie integers bij: \verb+min+, \verb+max+ en \verb+sum+. Vervolgens overlopen we in een for-lus alle items. Ieder item wordt bij \verb+sum+ opgeteld en ondergaat vervolgens twee testen: indien het getal groter is dan \verb+max+ passen we \verb+max+ aan. Analoog berekenen we \verb+min+. Bijgevolg bevatten op het einde van de lus \verb+min+ en \verb+max+ respectievelijk het minimum en maximum.
\paragraph{}
Het omzetten van dit codefragment naar assembleertaal valt buiten het bereik van deze cursus maar wordt besproken in cursussen over compilerconstructie. We presenteren echter een equivalent programma in assembleertaal in \lstref{asm-minmaxsum}.
\importlisting[ciscasm]{asm-minmaxsum}{Het min-max-sum algoritme in assembleertaal.}
Het codefragment bestaat grofweg uit twee delen: data en programma. \verb+ORG DATA+ en \verb+ORG PROGRAM+ zijn dan ook directieven voor het assembleerprogramma. Het zijn geen instructies die omgezet worden in machinecode maar aanwijzingen om de assembleercode correct om te zetten in machinecode. Onder \verb+ORG DATA+ plaatst men een lijst met variabelen samen met hun datatype. Het is de bedoeling dat het assembleerprogramma ruimte voorziet voor de variabelen en de symbolische adressen in de code vervangt door hun fysieke waarde. Het type van de variabele bepaalt hoeveel adressen er gereserveerd moeten worden in het geheugen. In de micro-assembleertaal beschouwen we twee types: \verb+Word+ en \verb+Array+. Een \verb+Word+ omvat \'e\'en woord en is dus een hoeveelheid data die kan worden binnengehaald met \'e\'en adres. Het assembleerprogramma zal bijgevolg adres $0_{16}$ toekennen aan \verb+min+, $1_{16}$ aan \verb+max+ en $2_{16}$ aan \verb+sum+. In het geval van de processor die we hier ontwikkelen is dat $16$ bit. Een \verb+Array+ duidt op een aantal woorden met het aantal gespecificeerd tussen vierkante haken. Dit betekent dus dat de variabele \verb+A+ zal worden opgeslagen in adressen $3_{16}$ tot $402_{16}$.
\paragraph{}
Na \verb+ORG PROGRAM+ begint het eigenlijke program. De instructies staan dus vanaf adres $403_{16}$ vermits de vorige adressen worden ingenomen door de variabelen. Indien we een nieuwe variabele toevoegen, zal het assembleerprogramma alle adressen automatisch aanpassen. Het programma begint met het zetten van de drie registers waarin we \verb+min+ ($R0$), \verb+max+ ($R1$) en \verb+sum+ ($R2$). Zo laden we de \verb+maxint+ constante in in $R0$ en $0$ in de overige registers. Daarna begint de initialisatie van de for-lus. We gebruiken hiervoor register $R3$ als lus-variabele (\verb+i+). $R4$ gebruiken we als register die de constante bijhoudt om de for-lus te be\"eindigen. Tot slot gebruiken we register $R5$ die het adres bijhoudt van het element die we op dat moment moeten uitlezen. Vanaf het \verb+body+-label beginnen de instructies in de for-lus. Zo laden we eerst de data op de specifieke plaats in de array in register $R6$. De data wordt bij het som-register opgeteld waarna we een eerste test uitvoeren. Indien de waarde kleiner of gelijk is dan het op dat moment geldende maximum, slaan we het aanpassen van de \verb+max+ variabele over. In het andere geval kopi\"eren we het getal naar het \verb+max+-register. In de tweede test vergelijken we de waarde met het minimum. Indien de waarde groter is dan het minimum slaan we het aanpassen van het \verb+min+-register over. Na de twee testen bereiken we het \verb+last+-label: de laatste instructies binnen de for-lus. In dit gedeelte hogen we de lus-teller op samen met adres binnen de array. Vervolgens vergelijken we de for-teller en de eindconditie. Wanneer de teller kleiner is of gelijk aan het einde van de array voeren we de lus opnieuw uit: we springen dus terug naar het \verb+body+-label. In het andere geval is de for-lus afgelopen. Tot slot dienen we nog de waardes binnen het register te kopi\"eren naar de variabelen. Dit doen we met behulp van drie store-instructies. Merk op dat het voorgestelde algoritme niet volledig equivalent is: we slaan immers eerst de waarde van \verb+A[i]+ in een register op in plaats van deze telkens uit te lezen. Het voordeel van deze werkwijze is echter dat we load-instructies en toegang tot het geheugen uitsparen en bijgevolg de snelheid van het programma opdrijven.
\paragraph{}
\importlisting[bin]{bin-minmaxsum}{Het min-max-sum algoritme in machinetaal.}
We kunnen de code in assembleertaal handmatig omzetten in binaire machinetaal. Het resultaat na deze omzetting staat in \lstref{bin-minmaxsum}. In de listing beschouwen we twee formaten: \verb+-- ----- --- --- ---+ beschrijft instructies en \verb+---- ---- ---- ----+ beschrijft adresvelden. In werkelijkheid is er natuurlijk geen verschil bij de instructies. Verder beschouwen we in het bestand don't care bits. Men kan deze bits uiteraard niet voorstellen in een geheugen. In dat geval dienen we gewoon een waarde -- $0$ of $1$ -- in te vullen. Doorgaans kiest een assembleerprogramma $0$. We zien dat een assembleerprogramma zowel de labels als de variabelen vervangt door hun fysische equivalent. Verder worden de verschillende instructies omgezet en de opgegeven registers ingevuld. Samen met deze cursus komt het programma \verb+assembler-cisc.hs+ die in staat is om programma's geschreven in de gegeven assembleertaal om te zetten in de gegeven machinetaal. Men schrijft het programma in de assembleertaal en slaat het op in een bestand. Vervolgens roept men het programma aan met \verb+assembleer-cisc bestand program+. De uitvoer is een binair bestand genaamd \verb+program+ die de equivalente machinecode voorstelt. In \chpref{experiments} ten slotte vindt men terug hoe men de CISC-processor zelf kan realiseren. Op die manier kan men dus zelfgeschreven programma's uitvoeren.
\paragraph{}
\begin{table}[hbt]
\centering
\importtabularsubtable{minmaxsum-program}{Programma.}
\importtabularsubtable{minmaxsum-execution}{Uitvoer.}
\caption{Frequentietabel bij het uitvoeren van het voorbeeldprogramma.}
\tbllab{freq-minmaxsum}
\end{table}
We zullen tot slot op basis van het programma cijfermateriaal berekenen over het aantal uitgevoerde instructies. Dit is nuttig wanneer we bijvoorbeeld een sneller datapad willen ontwikkelen en statistische gegevens nodig hebben in verband met het voorkomen van instructies. Bij het verzamelen van statistische gegevens kunnen we een onderscheid maken tussen enerzijds het programma en de uitvoer. Bij de uitvoer van een programma kunnen sommige instructies immers meermaals worden uitgevoerd. \tblref{minmaxsum-program} toont dan ook het gebruik van instructies in een programma. Wat opvalt is het hoge aantal verplaatsinstructies. Wanneer we de frequentie van de instructies willen berekenen zullen de meeste instructies $1024$ keer in de lus worden uitgevoerd: we denken bijvoorbeeld aan de increment instructies. Een probleem vormen echter de register-kopieer instructies (COPY). De uitvoer van deze instructies hangt immers af van de gegevens in de array. We kunnen echter stellen dat wanneer we reeds $k$ elementen hebben onderzocht, de kans om nog een minimum of maximum te bekomen gelijk is aan:
\begin{equation}
\fun{P_{\mbox{nieuw min/max}}}{k}=\displaystyle\frac{1}{1+k}
\end{equation}
In dat geval verwachten we dat we $15.018$ keer deze instructie zullen moeten uitvoeren. \tblref{minmaxsum-execution} beschrijft de frequentietabel bij de uitvoer. Wat opvalt is dat het aandeel aan verplaatsinstructies significant lager is. Dit is typisch: buiten de lussen voert men vooral instructies uit die gegevens inladen en wegschrijven. Binnen de lussen voert men meestal rekenwerk uit.
\subsubsection{Instructieset-stroomschema}
Na het opstellen van een instructieset volgt de volgende stap: het opstellen van een \termen{instructieset-stroomschema} ofwel \termen{Instruction Set Flowchart}. Een dergelijk stroomschema is een visuele voorstelling van alle instructies samen met de bijbehorende registertransfers. Meestal wordt dit schema dan ook gebruikt om later de \termen{instructiedecoder} te ontwikkelen: een onderdeel van de controller die de instructie omzet in de juiste stuursignalen voor het datapad.
\paragraph{}
Bij het defini\"eren van de instructieset hebben we verondersteld dat we beschikken over:
\begin{itemize}
 \item een geheugen (Mem)
 \item een registerbank (RF)
 \item een programmateller (PC)
 \item een instructieregister (IR)
 \item een statusvlag (Status)
\end{itemize}
\paragraph{}
Het stroomschema kent twee concepten: instructieblokken en beslissingsblokken. Een instructieblok wordt voorgesteld door een rechthoek terwijl een beslissingsblok wordt voorgesteld door een driehoek. Op het bovenste hoekpunt wordt de variabele gezet die betrokken is in de beslissing of een booleaanse expressie. Op de basis van de driehoek worden vervolgens de verschillende resultaten van de variabele of booleaanse expressie geplaatst en vertrekt vanuit elk resultaat een pijl. Men leest een stroomschema dan ook door de relevante pijl te volgen.
\paragraph{}
De beschrijving van een stroomschema lijkt op dat van een ASM-schema maar verschilt op enkele punten. Zo omvat een stroomschema geen concrete toestanden: we doen geen uitspraak over wat precies in welke klokcyclus moet worden afgehandeld, soms zullen bewerkingen in het stroomschema dus verder onderverdeeld worden. Verder kent een stroomschema wel een sequenti\"ele volgorde toe aan instructies. Instructies die vermeld staan in eenzelfde blok worden conceptueel na elkaar uitgevoerd\footnote{Dit hoeft echter niet te betekenen dat de opdrachten ook effectief na elkaar moeten worden uitgevoerd. Indien beide instructies niet interfereren bijvoorbeeld kan men de instructies omdraaien of tegelijk uitvoeren.}. In een ASM-schema worden alle instructies in een blok tegelijk uitgevoerd. Stel bijvoorbeeld dat men in een blok volgende instructies tegenkomt:
\begin{equation}
\begin{array}{l}
a\leftarrow a+1\\
b\leftarrow\mbox{Mem}[a]
\end{array}
\end{equation}
In het geval deze instructies in een ASM-schema staat zal $b$ de waarde van het geheugen inlezen dat op het adres van de oude waarde van $a$ staat. In het geval van een stroomschema wordt de waarde op het adres ernaast uitgelezen.
\paragraph{}
Een stroomschema voor een instructieset omvat alle mogelijke instructies die kunnen worden uitgevoerd. Centraal staat doorgaans een instructieblok die beschrijft hoe de instructie wordt opgehaald en de programmateller wordt opgehoogd. Vanuit dit blok worden de stroom vervolgens opgedeeld op basis van mogelijke instructies. Elke vertakking voert vervolgens de instructie uit en keert terug naar het centrale blok zodat de volgende instructie kan worden opgehaald.
\paragraph{}
\importtikzfigure{flowchart-cisc}{Het instructieset-stroomschema van de CISC processor.}
\figref{flowchart-cisc} toont het stroomschema van alle 44 instructies in \'e\'en afbeelding. De verschillende types instructies zijn in verschillende richtingen opgebouwd. Centraal zien we een instructieblok met twee instructies: $\texttt{IR}\leftarrow\texttt{Mem[PC]}$ laadt de instructie op het adres van de programmateller in het instructieregister en $\texttt{PC}\leftarrow\texttt{PC}$ hoogt de instructieteller op. Na het inladen van de instructie vertakt de stroom zich aan de hand van de data in het instructieregister. Allereerst maken we op basis van $\mbox{IR}_{15}$\footnote{Met deze notatie bedoelen we de $15$-de bit van het instructieregister.} en $\mbox{IR}_{14}$ een onderscheid tussen de verschillende types. Eenmaal voldoende vertakt beschrijft een instructieblok de concrete uitvoer van de bewerking. Het stroomdiagram toont ook details die niet in de tabellen met de instructies vermeld staan. We denken hierbij bijvoorbeeld aan het inlezen van het adresveld. In het geval de instructie gepaard gaat met een adresveld wordt wordt dit ook uitgelezen met $\texttt{Mem[PC]}$\footnote{Merk op dat alvorens we deze instructie bereiken, de programmateller al is opgehoogd. Bijgevolg staat de programmateller op dat moment op het adresveld.} waarna de programmateller nogmaals wordt opgehoogd. Na het uitvoeren van de instructies komen de verschillende stromen terug samen bij het instructieblok die de volgende instructie inleest.
\subsubsection{Allocatie datapadcomponenten}
Nadat per instructie een formele beschrijving werd opgesteld met betrekking tot de verschillende operaties, bestudeert men in een volgende fases het datapad. Op basis van de uitgevoerde bewerkingen, kunnen we immers de vereiste hardware vastleggen. Zo vereist het stroomdiagram vijf soorten geheugen:
\begin{itemize}
 \item 	Een extern geheugen \texttt{Mem}: $2^{16}\times 16$ ofwel $128\mbox{ kiB}$ met $1$ lees/schrijfpoort.
 \item Een registerbank \texttt{RF}: $2^3\times 16$ met $2$ leespoorten en $1$ schrijfpoort.
 \item Een statusvlag \texttt{Status}
 \item Een instructieregister \texttt{IR}
 \item Een programmateller \texttt{PC}
\end{itemize}
De laatste twee registers behoren echter tot de controller en zullen we in deze stap niet beschouwen. We kunnen verder voor elke operatie een functionele eenheid voorzien. Anderzijds zal elke klokcyclus er hoogstens \'e\'en instructie actief zijn. Alle bewerkingen die moeten worden uitgevoerd kunnen we uitvoeren met drie algemene functionele eenheden:
\begin{itemize}
 \item Aritmetische Logische Eenheid (ALU)
 \item Vergelijker
 \item $16$-bit bidirectionele schuifoperator.
\end{itemize}
We maken de assumptie dat de ALU alle basisbewerkingen (ADD, SUB, MUL, DIV, ROOT, NEG, AND, NAND, OR, NOR, XOR, XNOR, MASK en INV) kan uitvoeren, dat de vergelijker iedere conditie (GT, GE, LT, LE, EQ en NE) met betrekking tot twee registers kan uitrekenen en dat het schuifregister de twee schuifinstructies (ASR, ASL) kan uitvoeren. Instructies die niet onder het type registerinstructies vallen voeren doorgaans geen bewerkingen uit behalve de optelling. In dat geval is de ALU echter vrij waardoor dit geen probleem vormt.
\paragraph{}
In deze fase is het echter de bedoeling te onderzoeken of we de snelheid niet kunnen opdrijven door extra hardware te voorzien. Wanneer men echter aanpassingen aanbrengen aan het datapad zal men ook de instructieset moeten herzien.
\paragraph{}
Wanneer we de snelheid willen opdrijven zullen we dit altijd doen ter hoogte van het kritisch pad. Het heeft immers weinig zin andere instructies sneller uit te voeren wanneer de kloksnelheid onder druk staat van een andere instructie. We hebben reeds vermeld dat geheugen doorgaans een bottleneck vormt dus is het meestal interessant vooral naar instructies te kijken met een groot aantal geheugentoegangen.
\paragraph{}
Op basis van het stroomdiagram kunnen we opmerken dat impliciete adressering het meeste geheugenoproepen kent. De instructie vereist immers volgende bewerking:
\begin{equation}
\texttt{RF[d]}\leftarrow\texttt{Mem[Mem[Mem[PC]]]}
\end{equation}
Dit komt bijgevolg neer op $4$ geheugentoegangen (inclusief het inlezen van de instructie). Stel dat het RAM-geheugen een toegangstijd heeft van $50~\mbox{ns}$, dan vereist de instructie dus minstens $200~\mbox{ns}$. Indien we dus de volledige instructie in \'e\'en klokcyclus uitvoeren, dan is de maximale klokfrequentie bijgevolg:
\begin{equation}
f_{\mbox{max}}=\displaystyle\frac{1}{4\cdot 50~\mbox{ns}}=5~\mbox{MHz}
\end{equation}
We kunnen de impliciete adressering onmogelijk versnellen met de gegeven toegangstijd. Anderzijds impliceert het uitvoeren van de instructie in \'e\'en klokcyclus dat alle instructies in $200~\mbox{ns}$ worden uitgevoerd, ook registeroperaties die geen geheugenoperaties vereisen. Dit betekent dat het uitvoeren van het voorbeeldprogramma $2\ 052\ 800~\mbox{ns}$ vereist.
\paragraph{}
We kunnen een multicycling transformatie uitvoeren waarin instructies worden uitgesmeerd zodat per klokcyclus er \'e\'en geheugentoegang wordt uitgevoerd. In dat geval is een klokcyclus ongeveer $50~\mbox{ns}$ lang. Wanneer we dus een LOAD instructie uitvoeren met behulp van impliciete adressering zal dit nog steeds $200~\mbox{ns}$ vereisen. Anderzijds zullen bijvoorbeeld registeroperaties in $1$ klokcyclus worden uitgevoerd. Uit \tblref{minmaxsum-execution} kunnen we echter afleiden dan het grootste deel van de instructies enkel toegang tot het geheugen vereisen om de instructie in te laden. De uitvoertijd van het programma zal dus ongeveer verviervoudigen.
\paragraph{}
Met de multicycling transformatie dienen we echter een nieuw register te introduceren: het \termen{adresregister (AR)}. Dit register houdt het adres bij tijdens de uitvoeren van verplaatsinstructies. We hebben slechts nood aan \'e\'en register omdat bij bijvoorbeeld impliciete adressering we dit register enkele malen kunnen overschrijven tot de instructie is uitgevoerd.
\subsubsection{ASM-schema}
Na het alloceren van componenten bij het datapad zullen we een ASM-schema opstellen. We stellen dit proces op op basis van enerzijds het stroomdiagram op \figref{flowchart-cisc} en anderzijds de allocatie van de componenten op het datapad. Met deze stap dienen we echter te beslissen welke bewerkingen we in welke toestand uitvoeren. Concreet betekent dit dat we de instructieblokken van het stroomdiagram opsplitsen in zo weinig mogelijk ASM-blokken. In principe kan men alle instructies altijd tegelijk uitvoeren. Anderzijds hebben we de componenten op het datapad reeds vastgelegd. Concreet betekent dit dat we in dit geval over slechts \'e\'en ALU beschikken, dat we slechts \'e\'en adres van het geheugen tegelijk kunnen uitlezen, we \'e\'en woord per toestand naar de registerbank kunnen wegschrijven, enzovoort. Bij wijze van voorbeeld zullen we enkele gevallen bespreken.
\paragraph{Aritmetisch schuiven naar rechts (ASR)}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{flowchart-asr}{Stroomschema.}
\importtikzsubfigure{asm-asr}{Tussentoestand.}
\caption{Stroomschema naar ASM-schema voor de ASR-instructie.}
\label{flowasm-asr}
\end{figure}
Om de voorbeelden te bespreken zullen we telkens eerst de relevante delen van het stroomschema voorstellen. In het geval van aritmetisch schuiven naar rechts (ASR) is dit \figref{flowchart-asr}. De cyclus omvat slechts twee instructieblokken: het ophalen van een instructie en het uitvoeren. Dit is het geval bij alle registerinstructies. Hardwarematig is er geen probleem om de twee bewerkingen in \'e\'en klokcyclus uit te lezen: we kunnen de instructie uit het geheugen inlezen en deze tegelijk uitvoeren en in het instructieregister plaatsen. Er zijn echter drie redenen om dit niet te doen: in dat geval heeft het plaatsen van de instructie in het register geen nut: de volgende instructie zal de waarde immers overschrijven zonder dat deze ooit werd uitgelezen. Verder beschouwen we ook een Moore-machine als controller. Dat betekent dat de stuursignalen afhankelijk zijn van de data die in een vorige klokcyclus werd uitgevoerd. Tot slot is het ophalen van de instructie een bewerking die met alle overige instructies wordt gedeeld. De logica wordt meestal eenvoudiger als men bij het ophalen van de instructie niet voor sommige instructies meteen de relevante bewerkingen uitvoert.
\paragraph{}
We stellen dus twee verschillende toestanden: een toestand waarin we de instructie ophalen en een toestand waarin we de schuifoperatie naar rechts uitvoeren. In het ASM-schema moeten we dus een leeg toestandskader introduceren na het toestandskader die de instructie ophaalt. Onder dit toestandskader plaatsen we vervolgens beslissingskaders die naar een conditioneel kader leiden waar de instructie wordt uitgevoerd. Een ASM-schema dat enkel relevant is voor de ASR-instructie is getekend in \figref{asm-asr}. Merk op dat in een ASM-schema zaken die in hetzelfde toestandskader gebeuren tegelijk worden uitgevoerd, dit in tegenstelling tot een stroomschema.
\paragraph{Laden van een constante (LOAD)}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{flowchart-load1}{Stroomschema.}
\importtikzsubfigure{asm-load1}{ASM-schema.}
\caption{Stroomschema naar ASM-schema voor de LOAD constante-instructie.}
\label{flowasm-load1}
\end{figure}
We beschouwen vervolgens de LOAD-instructie met onmiddellijke adressering die een constante uit het programma in een register inladen. Een compact deel van het stroomschema staat op \figref{flowchart-load1}. In het geval van deze instructie zijn we verplicht om twee toestanden te voorzien. Dit komt omdat het geheugen slechts \'e\'en leespoort heeft en we bijgevolg geen twee woorden tegelijk uit het geheugen kunnen laden. Verder wordt ook de programmateller tweemaal opgehoogd terwijl de controller slechts \'e\'en increment-operator omvat. We introduceren dus opnieuw twee toestanden: \'e\'en toestand waarbij we de instructie inlezen en \'e\'en toestand waarin we het adresveld inlezen en wegschrijven naar de registerbank. Dit leidt tot het ASM-schema in \figref{asm-load1}.
\paragraph{Laad direct uit het geheugen (LOAD)}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{flowchart-load2}{Stroomschema.}
\importtikzsubfigure{asm-load2}{Tussentoestand.}
\caption{Stroomschema naar ASM-schema voor de LOAD direct-instructie.}
\label{flowasm-load2}
\end{figure}
Naast het inladen van een constante bevat de instructieset ook een instructie om gegevens in te laden waarbij het adres gespecificeerd is. Opnieuw kunnen we omwille van het feit dat het geheugen slechts \'e\'en leespoort telt deze operatie enkel met minstens drie toestanden uitvoeren. Bij een multicycling-transformatie dienen we echter de tussenresultaten op te slaan. Hiervoor werd echter het adresregister ge\"introduceerd. Dit adresregister zal na toestand twee het adres bevatten dat moet worden uitgelezen. In de derde toestand wordt de waarde meteen terug uitgelezen om het correcte adres uit het geheugen uit te lezen.
\paragraph{Laad indirect uit het geheugen (LOAD)}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{flowchart-load3}{Stroomschema.}
\importtikzsubfigure{asm-load3}{Tussentoestand.}
\caption{Stroomschema naar ASM-schema voor de LOAD indirect-instructie.}
\label{flowasm-load3}
\end{figure}
De laatste LOAD-instructie die we beschouwen is de impliciete adressering. Deze instructie vereist in totaal viermaal toegang tot het geheugen. Bijgevolg vereist deze operatie minimum vier toestanden. Ook hier beschouwen we dus een multicycling-transformatie waarbij we \'e\'en instructieblok van het stroomschema op in drie toestandsblokken in het ASM-schema. We zullen bijgevolg de tussenresultaten opnieuw moeten wegschrijven. In een algemeen geval betekent dit dat we twee registers moeten voorzien\footnote{In een algemeen geval kan het immers voorkomen dat het finale resultaat afhangt van alle tussenresultaten berekend in de vorige toestanden.}. In dit geval hebben we slechts \'e\'en extra register nodig. We dienen immers enkel de resultaten van de vorige toestand te onthouden. Dit betekent dat we in de vierde toestand de resultaten van de tweede toestand niet meer nodig hebben.
\paragraph{Sprong naar een subroutine (JSR)}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{flowchart-jsr}{Stroomschema.}
\importtikzsubfigure{asm-jsr}{Tussentoestand.}
\caption{Stroomschema naar ASM-schema voor de JSR-instructie.}
\label{flowasm-jsr}
\end{figure}
Ook in het geval van een sprong naar een subroutine moeten we het uitvoeren van de eigenlijke instructie opsplitsen in twee delen. De volledige set instructies staat op \figref{flowchart-jsr}. Dit komt opnieuw door de toegang tot het geheugen: we moeten zowel het adresveld uitlezen en de programmateller na uitlezen in het geheugen plaatsen. Het geheugen omvat echter \'e\'en lees/schrijfpoort. We kunnen dus niet tegelijk lezen en schrijven. Om de toestand te overbruggen zullen we bovendien opnieuw gebruik moeten maken van de adresregister. In de eerste toestand lezen we dus eenvoudigweg het adresveld uit en hogen we de programmateller op. In de tweede toestand schrijven we de programmateller weg naar het geheugen, hogen we de stapel op en stellen we tot slot de programmateller gelijk aan het adresregister. Men kan opmerken dat er nog een tweede reden is om de instructies in twee blokken op te splitsen: we dienen tweemaal een increment uit te voeren. In het geval van de programmateller valt deze verantwoordelijkheid echter onder de controller. De controller beschikt over een eigen increment-operator waardoor men in principe tegelijk een optelling met de ALU en een increment van de programmateller kan realiseren. Het ASM-schema die de twee blokken voorstelt staat in \figref{asm-jsr}.
\paragraph{Terugkeer uit een subroutine (RTS)}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{flowchart-rts}{Stroomschema.}
\importtikzsubfigure{asm-rts}{Tussentoestand.}
\caption{Stroomschema naar ASM-schema voor de RTS-instructie.}
\label{flowasm-rts}
\end{figure}
Tot slot beschouwen we ook nog de terugkeer instructie waarvan het stroomschema is afgebeeld op \figref{flowchart-rts}. Deze instructie voeren we uit in \'e\'en toestand. Men kan opmerken dat we eerst de waarde van een register in de registerbank moeten aftellen om vervolgens de relevante geheugenplaats in te lezen. We kunnen echter zonder gebruik te maken van extra hardware een chaining-transformatie uitvoeren en dus niet alleen het resultaat na de decrement-operatie opslaan in de registerbank maar deze ook gebruiken om het adres te bepalen in het geheugen. We kunnen bijgevolg alle instructies in \'e\'en klokcyclus uitvoeren. Dit leidt dan ook tot het ASM-schema op \figref{asm-rts}.
\subsubsection{Ontwerp Controller}
Na het ontwerpen van een (gedeeltelijk) ASM-schema, kunnen we een specifieke controller ontwikkelen voor onze processor. In de eerste plaats beschouwen we altijd de controller uit \figrefpag{subroutineStructureController}. In deze controller beschouwen we echter enkele algemene componenten zoals een toestandsregister, next-state logica en output logica. In deze subsubsectie ondernemen we een poging deze componenten in te vullen.
\paragraph{}
De eerste component die we zullen bespreken is het toestandsregister. Dit register omvat normaal de toestand waarin de controller zich bevindt. In het geval van een processor is de toestand echter de plaats in het programma waarin we ons bevinden. Deze plaats wordt gemarkeerd door de programmateller: deze teller bevat immers het geheugenadres van waaruit we de instructie zullen uitlezen. Het stroomschema en het ASM-schem specificeren verder ook dat we op basis van de waarde van de programmateller de relevante instructie uit het geheugen inlezen en deze vervolgens in het instructieregister plaatsen. We voegen bijgevolg het geheugen en register tussen de programmateller enerzijds en de next-state- en output-logica anderzijds. De implementatie van de controller na deze stap is ge\"illustreerd in \figref{cisc-controller-pcmemir}.
\importtikzfigure{cisc-controller-pcmemir}{Het ontwerp van een CISC-controller met programmateller, geheugen en instructieregister.}
\paragraph{}
Door het toestandsregister te vervangen met de programmateller introduceren we echter een belangrijk probleem: de waarde van het toestandsregister in een controller beschrijft immers volledig de toestand. Dit zou dus betekenen dat we op basis van de programmateller of de overeenkomstige instructie alle bewerkingen kunnen afleiden. Dit is echter niet het geval: bij sommige bewerkingen werd een multicycling transformatie uitgevoerd. Bij bijvoorbeeld een indirecte laad-instructie doorlopen we vier verschillende toestanden. Alleen in de eerste twee toestanden wordt de programmateller opgehoogd. Dit betekent dus dat we geen onderscheid kunnen maken tussen bijvoorbeeld toestand $S_3$ en $S_4$ in \figrefpag{asm-load3}. We kunnen dit probleem echter oplossen met behulp van de componenten die de volgende toestand en de uitvoer-logica berekenen. Klassiek zijn dit twee combinatorische schakelingen. We kunnen echter ook een eindige toestandsautomaat implementeren om deze componenten voor te stellen. Deze automaat omvat dan een intern toestandsregister die de verschillende deeltoestanden van een instructie bijhoudt. In sommige processoren is er zelfs sprake van een volledige eindige toestandsautomaat-controller met een micro-programmateller en micro-programmageheugen.
\importtikzfigure{cisc-controller-nsolfsm}{Het ontwerp van een CISC-controller met interne eindige toestandsautomaat.}
\paragraph{}
De controller laat toe om naast de programmateller op te hogen ook op twee andere manieren een nieuwe waarde in te laden: de logica die de volgende toestand uitrekent kan zelf een waarde voorstellen of de waarde kan worden afgeleid uit een LIFO-stack (ook wel de \termen{execution stack} of \termen{uitvoerstapel} genoemd) in het geval van subroutines. Op basis van het stroomschema kunnen we echter opmerken dat in het geval van een spronginstructie het adres expliciet in het programma wordt vermeld. We hebben bijgevolg geen extra logica nodig om het adres verder te decoderen. Daarom vervangen we de verbinding vanuit de next-state logica naar de multiplexer door een verbinding vanuit het geheugen naar de multiplexer.
\paragraph{}
Wanneer we een subroutine uitvoeren doet een deel van het geheugen zelf dienst als stapel. Dit zien we bijvoorbeeld in het stroomschema waar de instructies $\texttt{Mem[RF[s1]]}\leftarrow\texttt{PC}$ en $\texttt{RF[s1]}\leftarrow\texttt{RF[s1]}+1$ respectievelijk eerst de waarde van de programmateller op de juiste plaats in de stapel plaatst en vervolgens een register in de registerbank die dienst doet als \termen{stapelteller} ophoogt. In het geval we terugkeren uit een subroutine geldt een omgekeerde procedure. De controller die we op dit moment beschouwen voorziet hiervoor op dit moment zelf een LIFO-stapel. We kunnen vervolgens deze stapel elimineren en de verbindingen afleiden naar het geheugen. Dit betekent dat de uitgang van de increment die oorspronkelijk het adres van de LIFO bepaalde nu in bepaalde omstandigheden het geheugenadres bepaalt. Verder werd al een verbinding vanuit het geheugen naar de multiplexer voorzien. We elimineren dus een verbinding en reduceren ook de multiplexer tot een 2-naar-1 MUX. De controller na het doorvoeren van deze twee wijzigingen staat op \figref{cisc-controller-lifo}.
\importtikzfigure{cisc-controller-lifo}{Controller met samengevoegd geheugen en stapelgeheugen.}
\paragraph{}
Tot slot dienen we op te merken dat het geheugen van de ontwikkelde processor geen onderdeel is van de controller zelf: ook het datapad heeft toegang tot hetzelfde geheugen om bijvoorbeeld programmaconstanten uit te lezen. Een architectuur waar men een centraal geheugen beschouwt die zowel gegevens als programma's beschouwt noemen we Von Neumann-architectuur, in het geval beide geheugens gescheiden zijn spreken we over Harvard-architectuur. We verplaatsen dus het geheugen uit de controller. Dit doen we door twee bussen te beschouwen: een \termen{adresbus} is een reeks verbindingen waarmee men de adresingangen van het geheugen kan aansturen en met behulp van de \termen{databus} leest men gegevens in of schrijft men deze weg in het geheugen. De databus is bijgevolg een bus die in twee richtingen werkt. We dienen bijgevolg tri-state buffers te voorzien voor zowel lees- als schrijfoperaties. Ook op de adresbus brengen we tri-state buffers aan: het datapad moet immers ook adressen kunnen aanleggen. De uiteindelijke controller beschrijven we in \figref{cisc-controller-memex}.
\importtikzfigure{cisc-controller-memex}{Controller met extern geheugen (Von Neumann-architectuur).}
\subsubsection{Ontwerp Datapad}
De laatste stap is het ontwerpen van een datapad. We hebben reeds enkele stappen geleden de vereiste componenten voor het datapad vastgelegd. We dienen echter nog verbindingen te introduceren om de verschillende instructies te kunnen uitvoeren. Deze verbindingen omvatten ook tri-state buffers aan de ingangen van een bus en multiplexers aan de uitgangen. De vereiste verbindingen kunnen we uiteraard afleiden uit het ASM-schema.
\paragraph{}
Het is mogelijk dat er conflicten ontstaan tussen enerzijds het ASM-schema en anderzijds de componenten en verbindingen op het datapad. Dit kunnen we oplossen door terug te keren op \'e\'en van de volgende stappen:
\begin{itemize}
 \item De allocatie van de componenten: in dat geval voorzien we extra componenten zoals een extra ALU of registerbank. We dienen vervolgens wel opnieuw een ASM-schema op te stellen en mogelijk ook een nieuwe controller ontwerpen.
 \item Het ASM-schema: we kunnen extra toestanden introduceren zodat we de componenten op het datapad meermaals kunnen gebruiken. Hiervoor dienen we het ASM-schema en mogelijkerwijs de controller aan te passen. Dit leidt uiteraard tot meer klokcycli voor (sommige) instructies.
\end{itemize}
\paragraph{}
Bij het omzetten van het ASM-schema naar de verbindingen van het datapad is het belangrijk een onderscheid te maken tussen bewerkingen die onder de verantwoordelijkheid van de controller vallen en deze van het datapad. Zo beschrijft toestand $S_0$ het ophalen van een instructie en deze vervolgens in het instructieregister plaatsen. Zowel de programmateller en het instructieregister vallen echter onder de verantwoordelijkheid van de controller. Bijgevolg dienen we voor deze bewerkingen geen verbindingen te introduceren. Ook het interpreteren van de instructie is de verantwoordelijkheid van het datapad.
\paragraph{}
\importtikzfigure{cisc-datapad-basic}{De basis datapad-ontwerp van de CISC-processor.}
Bij het ontwerp beginnen we met een datapad waar we enkel de componenten tekenen. Verder worden ook externe componenten (behalve de controller) die interageren met het datapad getekend. In dit concrete geval is dit het centrale geheugen samen met de adres- en databus. We beschrijven ook de tri-state buffers van de databus van en naar het geheugen. Deze aspecten werden ook al beschreven bij het ontwerp van de controller. Dit resulteert in de afbeelding op \figref{cisc-datapad-basic}.
\paragraph{}
We realiseren een controller door de verschillende instructies toe te voegen en waar nodig extra bussen in het datapad aan te brengen. Het is daarom nuttig om onmiddellijk bij het introduceren van een bus met tri-state buffers bij de aansturing en eventueel ontvangers aan de kant van de gebruikers te plaatsen. Indien later blijkt dat de bus enkel door \'e\'en register wordt aangestuurd of de multiplexer slechts data ontvangt van \'e\'en bus, kan men deze componenten gewoon verwijderen. We zullen in de rest van deze subsubsectie enkele instructies vertalen naar het datapad. Natuurlijk dienen we in realiteit alle instructies te beschouwen. Het resulterende datapad staat in \figrefpag{cisc-datapad-connections} en de uiteindelijke controller in \figrefpag{cisc-controller-final}. We zullen vanaf hier de synthese van deze figuren beschouwen.
\paragraph{Schuifoperatie (SHR)}
We beschouwen opnieuw de schuifoperatie naar rechts. Zoals reeds aangehaald is het inlezen en interpreteren van de instructie de verantwoordelijkheid van de controller. Bijgevolg rest alleen nog verbindingen te voorzien voor de laatste bewerking in de instructie: $\texttt{RF[d]}\leftarrow\texttt{RF[s1]>{}>N}$. Het bepalen van de juiste adressen in de registerbank (\texttt{d} en \texttt{s1}) valt hierbij ook onder de verantwoordelijkheid van de controller. Dit doen we door verbindingen te plaatsen tussen de output logica eindige toestandsautomaat en de adres-ingangen van de registerbank en de schuiflengte-ingangen van het schuifregister. We dienen dus enkel bussen te realiseren die gegevens vanuit de registerbank naar het schuifregister transporteert en terug. De eerste bus wordt via een tri-state buffer aangestuurd vanuit de eerste lees-poort van de registerbank\footnote{We kunnen ook opteren voor de tweede leespoort. Vermits momenteel nog geen enkele leespoort in gebruik is, is de keuze arbitrair.}. Verder loopt vanuit het schuifregister een bus terug naar de registerbank.
\paragraph{Optelling (ADD)}
In het geval van een optelling dienen we opnieuw slechts de verbindingen verantwoordelijk voor de optelling zelf te realiseren. Dit betekent dat we de twee leespoorten moeten aanleggen op de twee ingangen van de ALU. We hebben echter al \'e\'en operandbus voorzien: deze bus wordt aangestuurd door het register bepaald door het \verb+s1+ veld van de instructie. We verwachten dat de implementatie van de controller vereenvoudigt wanneer we dit principe consistent toepassen. Bijgevolg zullen we ook bij de optelling deze bus aansturen met de inhoud van \verb+RF[s1]+. We dienen echter nog een andere operand-bus te voorzien: een bus om \verb+RF[s2]+ te verplaatsen. Deze bus wordt dus aangestuurd door de tweede leespoort van de registerbank. We dienen tot slot ook de twee ingangen van de ALU aan de operandbussen te koppelen. Het datapad voorziet ook reeds een resultaatbus. Deze resultaatbus wordt aangestuurd door de schuifoperator en gebruikt door de registerbank. Omdat we het schuifregister niet tegelijk met de ALU gebruiken, kunnen we bijgevolg de resultaatbus hergebruiken. We voorzien dus een tri-state buffer tussen de uitgang van de ALU en de resultaatbus. De overige registerinstructies worden allemaal ofwel door het schuifregister ofwel door de ALU uitgevoerd. Zonder verder in detail te gaan kunnen we dus stellen dat de twee operandbussen en de resultaatbussen dus volstaan om al deze instructies te ondersteunen.
\paragraph{Onmiddellijk laden (LOAD)}
Naast register-instructies beschouwen we ook instructies die data in en uit het geheugen halen. Dit geheugen bevindt zich buiten het datapad, maar het datapad kan wel communiceren met dit geheugen via de adres- en databus. Wanneer we een constante inladen betekent dit dat we volgende bewerking uitvoeren: $\texttt{RF[d]}\leftarrow\texttt{Mem[PC]}$. We beschikken evenmin over de inhoud van de programmateller, maar de controller kan wel de inhoud op de adres-bus plaatsen. In dat geval staat de inhoud die moet worden ingeladen dus op de data-bus. Wanneer we dus een tri-state buffer plaatsen tussen de data-bus en de resultaat-bus, kunnen we de data in de registerbank inladen.
\paragraph{Direct laden (LOAD)}
Het ASM-schema op \figrefpag{asm-load2} beschrijft hoe gegevens direct uit het geheugen worden ingeladen. Het proces komt neer op twee bewerkingen waar het datapad een rol in speelt: $\texttt{AR}\leftarrow\texttt{Mem[PC]}$ en $\texttt{RF[d]}\leftarrow\texttt{Mem[AR]}$. De eerste bewerking heeft veel gemeen met het onmiddellijk inladen van een constante: we laden immers opnieuw $\texttt{Mem[PC]}$ in, alleen is de gebruiker nu het adresregister \verb+AR+. We kunnen opnieuw gebruik maken van de resultaatbus vermits deze bus opnieuw door geen enkel ander component gebruikt wordt in dezelfde toestand. We dienen hierbij wel het adresregister aan te sluiten op de resultaatbus. Hiervoor hoeven we op dit moment uitsluitend een eenvoudige verbinding te gebruiken: het adresregister dient immers niet te kiezen tussen data van verschillende bussen waardoor een multiplexer overbodig is. Vervolgens beschouwen we de tweede bewerking. In deze bewerking dient de inhoud van het adres-register op de adres-bus te verschijnen. Hiervoor voorzien we dus een verbinding tussen de lees-poort van het adresregister enerzijds en de adresbus anderzijds. In dit geval dienen we wel gebruik te maken van een tri-state buffer: er zijn immers nog registers en componenten die hun inhoud op de adres-bus kunnen plaatsen.
\paragraph{Ge\"indexeerd laden (LOAD)}
Als laatste laad commando beschouwen we ge\"indexeerd laden. Bij ge\"indexeerd laden voorzien we opnieuw twee relevante bewerkingen: de eerste bewerking stelt: $\texttt{AR}\leftarrow\texttt{Mem[PC]+RF[s1]}$, en in een volgende toestand $\texttt{RF[d]}\leftarrow\texttt{Mem[AR]}$. De tweede bewerking is identiek aan een bewerking bij het direct laden van een waarde. Bijgevolg dienen we geen extra verbindingen te voorzien. De eerste operatie omvat echter een nieuw aspect: we laden niet enkel de waarde van de programmateller in, maar tellen er ook nog de registerwaarde \texttt{RF[s1]} bij. Bijgevolg dienen we de waarde die op de databus verschijnt eerst aan te leggen op een ALU die vervolgens de som berekent. Het resultaat van de ALU wordt dan aangelegd op de resultaat-bus en wordt op die manier in de registerbank ingeklokt. Om de data aan te leggen kunnen we gebruik maken van een operand-bus: slechts \'e\'en van de twee wordt immers gebruikt om de data van het register \texttt{RF[s1]} te verplaatsen. Omdat in alle voorgaande bewerkingen de eerste operandbus deze waarde transporteerde, zullen we de waarde van de data-bus dan ook aanleggen op de tweede operand-bus. De optelling is immers commutatief dus maakt de concrete toewijzing niks uit. Concreet introduceren we dus \'e\'en nieuw tri-statebuffer tussen de databus en de tweede operand-bus. Vermits alle overige laad-instructies enkel gebruik maken van bewerkingen die reeds werden beschouwd, zullen deze geen nieuwe verbindingen introduceren.
\paragraph{Kopi\"eren van een register (COPY)}
Verplaatsinstructies verplaatsen niet enkel gegevens tussen registers en het geheugen, maar ook tussen de registers onderling. Dit is de zogenaamde COPY-instruction. We kunnen in de eerste plaats denken om in het geval van een copy-instruction een operandbus te verbinden met de resultaat-bus met behulp van een tri-state buffer. Anderzijds kan deze instructie worden ondersteund zonder extra verbindingen te voorzien. Wanneer we immers schuiven over $0$ bits naar links of rechts, zal dezelfde waarde op de resultaat-bus worden aangelegd die op de eerste operand bus stond. De meeste ALU's laten bovendien toe dat met behulp van een bepaalde functiecode de waarde aan \'e\'en van de ingangen eenvoudigweg wordt aangelegd op de resultatenbus. We kunnen kiezen welke methode moet worden ge\"implementeerd in de logica van de controller, maar de operatie introduceert geen nieuwe verbindingen op het datapad.
\paragraph{Direct stockeren (STOR)}
De verplaats-instructies die data uit het geheugen inladen hebben op het inladen van een constante na een tegenhanger die data wegschrijft naar het geheugen. Vermits het berekenen van het adres gelijkaardig is, zullen we hiervoor geen nieuwe instructies moeten voorzien. De bewerking die het uiteindelijke resultaat wegschrijft -- $\texttt{Mem[AR]}\leftarrow\texttt{RF[s1]}$ dienen we echter wel te beschouwen. In deze bewerking leggen we de inhoud van het adresregister aan op de adresbus. De verbindingen hiervoor zijn reeds voorzien omdat we dit ook moeten doen om bijvoorbeeld gegevens direct in te laden. Anderzijds dienen we de inhoud van het gespecificeerde register aan te leggen op de registerbank. Tot nu werd altijd de eerste leespoort gebruikt om \verb+RF[s1]+ uit te lezen. Om de implementatie van de controller eenvoudig te houden zullen we deze conventie verder toepassen. We dienen echter de leespoort te verbinden met de data-bus. We voorzien dus een tri-state buffer tussen de eerste leespoort en de databus. Met deze STOR-instructie beschouwen we alle overige verplaats-instructies ook als ge\"implementeerd.
\paragraph{Sprong naar subroutine (JSR)}
We zullen ook enkele sprong-instructies beschouwen. De eerste instructie is de sprong naar een subroutine. We beschouwen deze instructie omdat we hierdoor ook tegelijk de bewerkingen van de onvoorwaardelijke (JMP) en voorwaardelijke (CJMP) sprong beschouwen. Het ASM-schema van deze instructie staat op \figrefpag{asm-jsr}. We zien op het ASM-schema twee toestanden die van belang zijn. In de eerste toestand wordt het geheugen op het adres van de programmateller ingelezen in het adresregister. Deze bewerking hebben we echter ook beschouwd bij het inladen van geheugendata met directe adressering. In de volgende toestand beschouwen we drie bewerkingen: $\texttt{Mem[RF[s1]]}\leftarrow\texttt{PC}$, $\texttt{RF[s1]}\leftarrow\texttt{RF[s1]+1}$ en $\texttt{PC}\leftarrow\texttt{AR}$. De increment van het register $\texttt{RF[s1]}$ is eenvoudig te implementeren. Dit is immers een register-instructie en bijgevolg dienen we geen extra verbindingen te voorzien. We dienen verder ook de waarde van de programmateller weg te schrijven in het geheugen op het adres aangegeven door een register. Hiervoor dienen we verbindingen te voorzien die de programmateller verbindt met de databus en de eerste leespoort met de adresbus. Merk op dat we bijgevolg zowel de controller als het datapad moeten aanpassen. Tot slot dienen we de waarde van het adresregister naar de programmateller kopi\"eren. Een probleem is echter dat alle beschikbare bussen reeds bezet zijn. We kunnen weliswaar de tweede operandbus gebruiken, maar deze heeft op dit moment geen verbinding met de programmateller. We kunnen dit oplossen door een verbinding te voorzien vanuit het adresregister naar de programmateller, al da niet via de tweede operandbus, ofwel door het ASM-schema aan te passen. We kunnen bijvoorbeeld een nieuwe toestand voorzien waarin -- bijvoorbeeld via de vrijgekomen databus -- de waarde van het adresregister aanlegt op de multiplexer van de programmateller. In dit geval kiezen we voor het tweede. Dit leidt tot de finale controller in \figref{cisc-controller-final}.
\importtikzfigure{cisc-controller-final}{De uiteindelijke controller van de CISC-processor.}
\paragraph{Terugkeer uit subroutine (RTS)}
De laatste spronginstructie die we beschouwen is de terugkeer uit een subroutine ofwel de RTS-instructie. Het relevante ASM-schema bij deze instructie staat in \figref{asm-rts}. Hiervoor dienen twee bewerkingen tegelijk worden uitgevoerd: $\texttt{RF[s1]}\leftarrow\texttt{RF[s1]-1}$ en $\texttt{PC}\leftarrow\texttt{Mem[RF[s1]-1]}$. Een terugkeer-instructie heeft veel gemeen met een sprong naar een subroutine. Toch is er een fundamenteel verschil: het geheugenadres wordt bepaald door een verschil berekend in dezelfde klokcyclus. Dit verschil wordt berekend door de ALU. Het resultaat van de ALU dient niet enkel teruggeschreven worden naar de registerbank, maar moet ook op de adresbus worden aangelegd (om de waarde op te vragen die in de programmateller moet worden weggeschreven). Daarom voorzien we een tri-state buffer tussen de resultaat-bus en de adresbus. Het wegschrijven van de waarde van de programmateller is vervolgens de verantwoordelijkheid van de controller. De vereiste verbindingen in de controller werden reeds gerealiseerd.
\paragraph{Groter dan (GT) en andere vergelijkingen}
Tot slot beschouwen we \'e\'en van de overige instructies: de groter dan operatie (hoewel iedere operatie kan worden beschouwd). De vergelijker in het datapad is een algemene vergelijker die op basis van stuursignalen \'e\'en van de voorwaarden bepaalt. De vergelijker vergelijkt de waarde in de registers \texttt{RF[s1]} en \texttt{RF[s2]}. Vermits hiervoor reeds operandbussen werden voorzien dienen we enkel verbindingen tussen de bussen en de ingangen van de vergelijker te voorzien. Verder dienen we vervolgens het resultaat in het statusregister weg te schrijven. We kunnen hiervoor een bit van de resultaatbus gebruiken. In dat geval dienen we echter een tri-state buffer te voorzien. Vermits het statusregister slechts \'e\'en bit bijhoudt, is de vereiste verbinding slechts \'e\'en bit breed. Daarom voorzien we een aparte verbinding vanuit de vergelijker naar het statusregister. De toestand van het statusregister vormt ook een signaal voor de controller (bijvoorbeeld bij een voorwaardelijk sprong). We kunnen andere condities testen door de stuursignalen van de vergelijker aan te passen. We beschouwen geen verdere overige instructies omdat deze geen nieuwe verbindingen introduceren. Deze instructies zetten of resetten immers registers, iets wat we kunnen realiseren met behulp van een multiplexer aan de ingang van het statusregister en met behulp van de reset-ingang bij verschillende registers. We bekomen dan ook het uiteindelijke datapad op \figref{cisc-datapad-connections}.
\importtikzfigure{cisc-datapad-connections}{Het datapad-ontwerp na het aanbrengen van verbindingen van de CISC-processor.}
\subsubsection{De 8086 Microprocessor}
Tot slot kijken we naar enkele populaire CISC-processoren: de 8086 microporocessor en de 8051 microcontroller. De structuur van deze processoren staat respectievelijk in \figref{processor-8086} en \figref{processor-8051}.
\paragraph{}
Vooral de 8086 is een populaire processor in computers en vormt de basis voor alle Intel CPU's\footnote{Hoewel de verdere processoren bijvoorbeeld de bitlengte van de registers verder hebben opgedreven is de algemene structuur nog steeds dezelfde.}. Op de figuur staat een component waarvan de vorm nog niet werd ge\"introduceerd: een trapezium met in het midden een inkeping wordt meestal gebruikt om een ALU aan te duiden.
\paragraph{}
In het blokdiagram van Intel 8086 zien we twee ALU's staan. De bovenste ALU rekent enkel het adres uit bij impliciete adressering en staat dan ook bekend als de \emph{adress adder}. De onderste ALU voert verschillende bewerkingen uit zoals optellen, aftrekken, vermenigvuldigen,... Verer zien we onderaan links ook een registerbank. Deze registerbank houdt de acht registers van elk 16 bit. Vier van de registers: AX, BX, CX en DX kunnen verder worden opgedeeld als registers van 8-bit. De overige vier registers zijn registers met een speciaal doel: bijvoorbeeld SP houdt de \emph{stack pointer} bij. Deze registers kan men dan ook niet aanwenden om eender welke instructie op toe te passen en de waarde wordt meestal impliciet aangepast.
\paragraph{}
Onder de ALU zien we nog een register die de \emph{Operand Flags} bijhoudt. Het is een 16 bit registers waarvan 9 bits dienstdoen om een voorwaarde met betrekking tot het resultaat berekend in de ALU bij te houden. Bijvoorbeeld als het resultaat van de ALU gelijk is aan $0$ wordt de \emph{Zero Flag} op $1$ gezet. Het voordeel van dit register is dat men niet altijd eerst een expliciete vergelijk-instructie moet uitvoeren.
\paragraph{}
Boven de central bus zijn we een andere registerbank. Deze registerbank houdt registers bij met betrekking tot de adressering zoals \emph{Instruction Pointer (IP)} \emph{Code Segment (CS)}, \emph{Data Segment (DS)}, \emph{Extra Segment (ES)} en \emph{Stack Segment (ES)}. Behalve de instructionpointer (het equivalent van de programmateller) valt de betekenis van de overige registers buiten het bereik van deze cursus. Men kan echter stellen dat ze nuttig zijn om het adres in een instructie uit te rekenen.
\paragraph{}
Tot slot vinden we bovenaan centraal ook nog een registerbank. Deze registerbank noemen we de \emph{Instruction Queue}. Het is een geheugen dat enkele instructies bevat die waarschijnlijk binnenkort zullen worden uitgevoerd. Door deze in een register te bewaren hoopt men geen wachttijden te introduceren om instructies uit het geheugen op te halen. Onder deze wachtrij bevindt zich ten slotte de controle-eenheid ofwel de controller die op basis van de instructie de gegevens op de juiste manier door de bussen laat stromen.
\importtikzfigure{processor-8086}{De structuur van de 8086 microprocessor.}
\subsubsection{De 8051 Microcontroller}
De 8051-microcontroller is in tegenstelling tot de Intel 8086 een Harvard-machine met een onderscheid tussen datageheugen en instructiegeheugen. In tegenstelling tot de 8086 waar enkel een rekeneenheid met registers wordt voorzien, voorziet de 8051 een rekeneenheid, geheugen, ROM-geheugen, Input-Output (I/O), interrupt logica en een timer.
\paragraph{}
De processor werkt hoofdzakelijk met een woordlengte van $8$-bit. Zo voorziet men een $8$-bit ALU en $8$-bit registers. De adresbus is echter $16$-bit waardoor een groter geheugen kan worden uitgelezen. Wat opvalt is dat de processor zowel een klein RAM-geheugen voorziet van 128 bytes waar de programmagegevens in worden ondergebracht terwijl de chip ook over een grote hoeveelheid EPROM of ROM geheugen beschikt waar het programma in wordt ingelezen. EPROM kan slechts eenmalig worden beschreven. Het is dan ook de bedoeling om deze chip in een specifieke applicatie te gebruiken door er een programma in onder te brengen zonder hier later wijzigingen in aan te brengen. Verder kan men ook opmerken dat de chip voor verschillende speciale registers extra functionaliteit voorziet. Zo zien we een increment-operator die enkel dienst doet om de programmateller op te hogen.
\importtikzfigure{processor-8051}{De structuur van de 8051 microcontroller.}
\subsection{Reduced Instruction Set Computer (RISC)}
\subsubsection{Ontwerp}
Het ontwerp van een RISC processor verloopt ongeveer gelijkaardig aan dat van een CISC processor. Een programma zal echter uit meer instructies bestaan dan bij een CISC processor, daarom is de klokfrequentie een zeer belangrijke factor. Pipelining vormt dan ook een zeer belangrijk aspect in de implementatie van een RISC processor. Zo worden de instructies zelf in nagenoeg alle processoren uitgevoerd volgens het pipelining principe\footnote{Zie voorbeelden van de ARM7 en ARM11 microprocessor verder in deze subsectie.}.
\paragraph{}
Pipelining zal er meestal toe leiden dat men extra beperkingen op de instructieset plaatst. We denken bijvoorbeeld aan het feite dat de meeste instructies even lang zijn. Op de ARM7 processor worden bijvoorbeeld alle instructies voorgesteld met 32 bit (inclusief verplaats instructies). Door geen optioneel adresvelden te voorzien kan een instructie in \'e\'en toestand worden opgehaald. Dit is belangrijk wanneer we bijvoorbeeld een instructie willen inlezen in \'e\'en toestand. Met optionele velden toe te laten moeten we op basis van de instructie beslissen of we de programmateller verder ophogen. Dit verhindert echter dat we in de volgende toestand dus een nieuwe instructie kunnen ophalen. Ook de controller en het datapad zelf werken volgens het pipelining-principe. Dit is belangrijk omdat de pipeline in het geval van sprongbevelen bijvoorbeeld moet worden onderbroken. Andere instructiesets voorzien geen hardware om de pipeline te onderbreken maar een No-Operation instruction die tussen twee instructies kunnen worden geplaatst waardoor de tweede instructie wacht tot de eerste instructie volledig is uitgevoerd.
\subsubsection{De ARM7 Microprocessor}
Bij wijze van voorbeeld zullen we twee microprocessoren bespreken: de ARM7 en ARM11 microprocessor. Voor beide processoren zullen we de structuur bespreken samen met de instructieset en de vormen van pipelining die werden ge\"implementeerd.
\paragraph{}
\importtikzfigure{processor-arm7}{De structuur van de ARM7 microprocessor.}
\figref{processor-arm7} beschrijft de structuur van een ARM7 processor. Op de figuur staan opnieuw enkele vormen die nog niet werden ge\"introduceerd. Zo wordt een barrel shifter typisch voorgesteld aan de hand van een parallellogram en een vermenigvuldiger aan de hand van een zeshoek waarbij de linkse en rechtse knoop inwendige hoeken zijn.
\paragraph{}
Net als in het geval van de Intel 8086 omvat de processor zelf geen RAM geheugen behalve enkele registers. Instructies en data worden dan ook uit een geheugen gelezen naast de ARM processor die verbonden is via een adresbus \texttt{A[31:0]} en een databus \texttt{D[31:0]}. De ARM7 processor omvat grofweg drie delen: een geheugeninterface: dit omvat het \emph{adresregister}, de \emph{adres incrementer}, en het \emph{write data register}; een rekenkundige eenheid met een registerbank, vermenigvuldiger, ALU en barrel shifter en de controle eenheid die de \emph{instruction pipeline} en de \emph{instruction decoder} omvat.
\subsubsection{De ARM11 Microprocessor}
\importtikzfigure{processor-pipeline-arm11}{De pipelining-structuur van de ARM11 microprocessor.}