\chapter{VHDL}
\chapterquote{In redelijke taal weerklinkt wat in werkelijkheid gebeurt.}{Gerard Bolland, Nederlands taalkundige en filosoof (1854-1922)}
\minitoc[n]
\section{Elementen van de VHDL-taal}
In deze sectie zullen we eerst de woordenschat in de VHDL taal bespreken, waarna we de belangrijkste types zullen bespreken samen met het 
\subsection{Lexicale elementen (woordenschat)}
Elk code-bestand\footnote{Onafhankelijk van de taal.} bestaat uit een sequentie van lexicale elementen die men \termen{tokens} noemt. We zullen eerst de verschillende lexicale elementen die in VHDL-code kunnen voorkomen beschrijven. Deze kunnen we dan als terminologie gebruiken. De tokens kunnen verder worden onderverdeeld in: \termen{literals} (deze vertegenwoordigen bepaalde waardes zoals getallen, tekst,...), \termen{identifiers} (dit zijn namen van variabelen, functies, componenten,... gebruikt om naar te refereren en defini\"eren), \termen{scheidingstekens}\footnote{Engels: \emph{delimiters}.} (haakjes en andere symbolen die waardes en identifiers combineren) en \termen{commentaar}. We beschrijven de verschillende soorten tokens verder in de volgende subsecties.

\subsection{Literals}
We onderscheiden vier soorten literals: getallen, karakters, karakterreeksen en bitreeksen. We overlopen de verschillende types. In VHDL is er ook nog sprake van \vhdltermen{enumeration literals} en van de \vhdltermen{NULL literal}, deze literals worden niet beschouwd.

\paragraph{Getal}Een getal (ook wel ``\vhdltermen{abstract literal}'' genoemd) is een numerieke waarde. Net als bij programmeertalen onderscheid men verschillende soorten numerieke waarden:
\begin{itemize}
  \item \vhdltermen{universal\_integer}: dit zijn numerieke literals die geen decimale komma (\vhdltermen{.}) bevatten, bijvoorbeeld \verb+1425+. Deze getallen zijn vergelijkbaar met het \texttt{int}-type in \texttt{Java}\footnote{De vergelijking gaat echter niet geheel op: een \texttt{int} is immers beperkt tot $32$ bit en heeft een specifieke representatie.}.
  \item \vhdltermen{universal\_real}: dit zijn numerieke getallen die wel een decimale komma bevatten. Bijvoorbeeld \verb+1425.1917+. Merk op dat indien er enkel nullen achter de komma staan dat het getal dezelfde waarde heeft als een \vhdltermen{universal\_integer}: \verb+1425.0+, maar daarom niet dezelfde representatie. In \texttt{Java} zouden we dit type voorstellen met bijvoorbeeld een \texttt{float} of \texttt{double}.
  \item \vhdltermen{physical types}: dit zijn fysische waarden. Fysische waarden bestaan uit een getal gevolgd door een fysische eenheid. Er wordt een spatie tussen het getal en de eenheid gezet. Bijvoorbeeld: \verb+1818 ns+. Dit type heeft geen echt equivalent in de meeste programmeertalen. Immers redeneren programmeertalen meestal niet over grootheden.
\end{itemize}
Getallen worden standaard in decimale notatie uitgedrukt. Men kan ze ook in exponenti\"ele vorm schrijven door het toevoegen van een '\vhdltermen{E}' of `\vhdltermen{e}' op het einde van het getal gevolgd door de exponent, bijvoorbeeld: \verb+14e2+. Om een andere basis te gebruiken, wordt volgend formaat gebruikt: \vhdltermen{base\#literal\#exp}, met de basis tussen 2 en 16. Zo kunnen we $1425$ schrijven als \verb+16#591#+, of $4864$ als \verb+16#13#E2+. Tot slot mag men ook vrij \emph{underscores} (\vhdltermen{\_}) toevoegen in een getal om de code leesbaar te houden. Bijvoorbeeld: \verb+19_171_425+.


\paragraph{Karakter} Een karakter (ofwel ``\vhdltermen{character literal}'') slaat een \termen{karakter} (ofwel \termen{character}) op: de eenheid van tekst. Deze literals worden tussen enkele aanhalingstekens (\vhdltermen{'}) geplaatst, bijvoorbeeld \verb+'K'+. In \texttt{Java} zou het equivalent van dit type een \texttt{char} zijn.

\paragraph{Karakterreeks}
Een \termen{karakterreeks} (ofwel ``\vhdltermen{string literal}'') slaat een sequentie karakters op, dus een tekstfragment. In \texttt{Java} noemt men een dergelijk type een \texttt{String}. Deze reeks wordt tussen dubbele aanhalingstekens (\vhdltermen{"}) geplaatst, bijvoorbeeld \texttt{"Hello World!"}. Een probleem doet zich voor wanneer we de dubbele aanhalingstekens (\texttt{"}) zelf in het tekstfragment willen gebruiken. In dat geval dienen we de aanhalingstekens dubbel te plaatsen, bijvoorbeeld:
\begin{quote}\verb+"""The answer?"" said Deep Thought. ""The answer to what?"""+\cite[\S25]{Adams81BOOK54}\end{quote}
\paragraph{Bitreeksen}
Een \vhdltermen{bitreeks} (ofwel ``\vhdltermen{bit string literal}'') is een sequentie aan bits (dit is een eenheid van informatie die ofwel \texttt{0} ofwel \texttt{1} is). Een bitreeks wordt geschreven als een sequentie van enen en nullen tussen dubbele aanhalingstekens (\vhdltermen{"}). Zoals we al vroeger in deze cursus hebben opgemerkt is zo'n sequentie niet effici\"ent, leesbaar en praktisch. Daarom laat men ook octale  en hexadecimale notatie toe. Hiertoe wordt er een \vhdltermen{B} (binair), \vhdltermen{O} (octaal) of \vhdltermen{X} (hexadecimaal) voor de dubbele aanhalingstekens geplaatst om de bitreeks in een bepaald formaat te lezen. Bij hexadecimale getallen gebruikt men \vhdltermen{a}, \vhdltermen{b}, \vhdltermen{c}, \vhdltermen{d}, \vhdltermen{e} en \vhdltermen{f} om respectievelijk $10$ tot $15$ voor te stellen. Net als bij getallen kan de gebruiker \termen{underscores} (\vhdltermen{\_}) toevoegen om tot meer leesbare code te komen.
\subsection{Identifiers}
Een \vhdltermen{identifier} is een referentie naar een variabele, functie, component,... Dit is vergelijkbaar met de naam van een variabele, methode, klasse,... in \texttt{Java}. Identifiers beginnen met een letter en mogen letters en cijfers bevatten. Ook de underscore (\vhdltermen{\_}) teken is toegelaten, indien dit niet het eerste of laatste karakter van de identifier vormt. Identifiers zijn niet hoofdletter gevoelig. In VHDL'93 wordt het begrip van een identifier verder uitgebreid. Deze uitbreiding wordt hier niet beschouwd. Voor meer details \cite[p. 4]{hardi00}.
\paragraph{Gereserveerde woorden}Niet alle namen die aan de hierboven beschreven regels mag men zelf gebruiken. Sommige identifiers zijn immers \termen{sleutelwoorden} die een reeds ingebouwde functie vevullen in VHDL: ze verwijzen naar functies die in de VHDL compiler zijn ingebakken. De woorden in \tblref{vhdl-reserved-words} mogen niet gebruikt worden als identifiers.

\importtabulartable{vhdl-reserved-words}{Gereserveerde woorden in VHDL.}

We onderscheiden verschillende soorten sleutelwoorden: enerzijds zijn er compiler-directieven zoals bijvoorbeeld \vhdltermen{case} en \vhdltermen{downto}, daarnaast zijn er basis-operaties zoals \vhdltermen{nand} en \vhdltermen{sla}, tot slot zijn er ook type-directieven zoals \vhdltermen{array} en \vhdltermen{signal}. Sommige gereserveerde worden werden pas ge\"introduceerd in VHDL'93, we gaan hier niet verder op in.

\subsection{scheidingstekens}
Een \vhdltermen{scheidingsteken} (ofwel ``\vhdltermen{delimiter}'') tenslotte wordt gebruikt om operaties op gegevens uit te voeren, bijvoorbeeld een optelling maar ook een index. De
scheidingstekens van VHDL worden weergegeven in \tblref{vhdl-delim}.

\importtabulartable{vhdl-delim}{Scheidingstekens in VHDL.}

We onderscheiden opnieuw verschillende soorten scheidingstekens: tekens die operaties voorstellen (zoals \texttt{+} en \texttt{*}), tekens die voorwaarden voorstellen (zoals \texttt{<>}), tekens die tekst afbakenen (zoals \texttt{(} en \texttt{[}) en tekens die aangeven dat twee fragmenten los van elkaar staan (zoals \texttt{,}).

\subsection{Commentaar}
Commentaar zijn delen van de code die genegeerd worden door de VHDL-compiler, maar die nuttig zijn voor programmeurs: ze bevatten gegevens over het project en richtlijnen die een belangrijke rol kunnen hebben tijdens het project. Commentaar plaatst men na twee horizontale strepen \verb+--+ en reikt tot het einde van de lijn. Dit is vergelijkbaar met de dubbele slash (\verb+//+) in \texttt{Java}.

\section{Typesysteem}
VHDL is getypeerd: een variabele slaat data op volgens een bepaald type, dit type geeft een interpretatie aan zowel de data en de operatoren die erop gedefinieerd zijn. De types kunnen bovendien door de programmeur uitgebreid worden. Men vertrekt echter steeds van basistypes.

\subsection{Voorgedefinieerde types}
Ook in de VHDL-secties werden sommige van deze types reeds gebruikt. \tblref{vhdl-type} geeft een overzicht van de meest populaire basistypes.
\begin{table}[hbt]
\centering
\importtabularsubtable{vhdl-type}{Overzicht van belangrijke types in VHDL.}
\importtabularsubtable{vhdl-type-deriv}{Overzicht van belangrijke afgeleide types in VHDL.}
\caption{Overzicht van belangrijke types en afgeleide types in VHDL.}
\end{table}

\paragraph{}
Naast deze reeks van basistypes bevat VHDL ook standaard enkele afgeleide types. Het zijn types die een gereduceerd bereik uit de basistypes vertegenwoordigen. Deze subtypes staan in \tblref{vhdl-type-deriv} samen met hun gereduceerd bereik.

\subsection{Zelf types defini\"eren}
Hoe defini\"eren we nu zelf types? Afhankelijk van het soort type dat we willen bouwen zijn er verschillende mogelijkheden:
\begin{itemize}
 \item Defini\"eren door opsomming;
 \item Defini\"eren door subtypering (beperk het bereik);
 \item Defini\"eren van fysische types;
 \item Afgeleide types met matrices en vectoren.
\end{itemize}

We bespreken de verschillende methodes nu in meer detail.

\subsubsection{Defini\"eren met opsomming}
We kunnen een type specificeren door alle mogelijke toestanden op te sommen. Deze methode wordt toegepast voor bijvoorbeeld de types \vhdltermen{bit} en \vhdltermen{byte}. De namen of karakters die de toestand bepalen worden tussen haakjes opgesomd na het sleutelwoord \vhdltermen{is}. Dit doen we na het sleutelwoord \vhdltermen{type} en de identifier voor het type. \vhdlref{type-enum} toont mogelijke definities van \vhdltermen{bit} en \vhdltermen{byte}. We defini\"eren ook het type \texttt{StateMachine}, dit type bevat drie elementen: \texttt{start}, \texttt{processing} en \texttt{wait} die de "toestanden" weergeven van een schakeling die we bijvoorbeeld zouden kunnen willen bouwen.

\importvhdl{type-enum}{Defini\"eren van types door opsomming.}


\subsubsection{Defini\"eren met subtypering}

Soms wensen we een type te specificeren die een deelverzameling omvat van een reeds eerder gespecificeerd type. Zo zal een \vhdltermen{integer} alle waarden omvatten die met $32$ bit voor te stellen zijn, het is echter mogelijk dat we bijvoorbeeld een type \texttt{byte} willen specificeren die uitsluitend numerieke waarden bevat die we op $8$ bit kunnen voorstellen. In dat geval gebruiken we het sleutelwoord \vhdltermen{subtype} gevolgd door een identifier die de naam van het type aanduidt, daarna volgt opnieuw het sleutelwoord \vhdltermen{is} en het "supertype". VHDL kent twee soorten beperkingen die hierop kunnen volgen: de "range beperking" en de "index beperking".

\paragraph{}
Een "range beperking" omvat twee literals die het begin en het einde markeren van een bereik van waarden. Vermits alle basistypes in VHDL een inherente orde-relatie hebben\footnote{Voor karakters maakt men gebruik van de ASCII-code.}

\begin{vhdlcode}[hbt]
\begin{lstlisting}
subtype byte is integer range 0 to 255;
subtype lowercase is character range 'a' to 'z';
\end{lstlisting}
\caption{Defini\"eren van types door subtypering.}
\vhdllab{constante}
\end{vhdlcode}

\begin{vhdlcode}[hbt]
\begin{lstlisting}
type bit is ('0','1');
type boolean is (false,true);
\end{lstlisting}
\caption{Defini\"eren van fysische types.}
\vhdllab{constante}
\end{vhdlcode}
\subsubsection{Data-objecten}
Een object in VHDL is een benoemd item met een specifieke waarde. We onderscheiden 3 soorten objecten: \vhdltermen{constante}, \vhdltermen{variabele} en \vhdltermen{signaal}.
\paragraph{Constante}Een constante is een object die slechts \'e\'enmaal een waarde kan toegekend worden. Ze geven een interpretatie aan de waarde, en maken de VHDL-code daarom beter verstaanbaar en aanpasbaar. We gebruiken hiervoor het sleutelwoord \vhdltermen{constant}. \vhdlref{constante} toont de declaratie van verschillende constanten. Merk op dat VHDL niet hoofdlettergevoelig is in programma-syntax. Alleen de waarde die in karakters en karakterreeksen wordt opgeslagen zijn hoofdlettergevoelig.
\begin{vhdlcode}[hbt]
\begin{lstlisting}
constant pi : real := 3.14159265;
constant byte_length : natural := 8;
constant word_length : natural := 4*byte_length;
\end{lstlisting}
\caption{Werken met constanten.}
\vhdllab{constante}
\end{vhdlcode}
Het algemene formaat is dus \verb+constant <identifier> : <type> := <waarde>;+.
\paragraph{Variabele}De syntax van een variabele is ongeveer dezelfde, alleen wordt het sleutelwoord \vhdltermen{variable} gebruikt. Verder is het onmiddellijk toekennen van een waarde optioneel. \vhdlref{variabele} toont het gebruik van variabelen in VHDL.
\begin{vhdlcode}[hbt]
\begin{lstlisting}
variable index : integer;
index := 0;
index := index + 1;
variable andere_index : natural := 12;
variable antwoord : natural := 4*andere_index-6*index;
\end{lstlisting}
\caption{Werken met variabelen.}
\vhdllab{variabele}
\end{vhdlcode}
\paragraph{Signaal}Een signaal ten slotte is het VHDL-equivalent van een fysische verbinding of een groep van verbindingen in de hardware. Een signaal wordt geconstrueerd met behulp van het sleutelwoord \vhdltermen{signal}. Toewijzingen aan een signaal gebeuren met de \vhdltermen{<=} operator. De toewijzing bij een signaal werkt anders dan bij een variabele en constante. Variabelen en constanten worden onmiddellijk toegewezen. Dit betekent dat expressies als \verb/index := index + 1;/ mogelijk zijn. Signalen veranderen echter wanneer elementen uit hun toewijzing veranderen. Beschouw het voorbeeld uit \vhdlref{signal}.
\begin{vhdlcode}[hbt]
\begin{lstlisting}
signal a : bit;
signal b : bit;
signal y : bit;
a <= '1';
b <= '0', '1' after 100 ns;
y <= a and b;
\end{lstlisting}
\caption{Werken met signalen.}
\vhdllab{signal}
\end{vhdlcode}
We zien drie signalen \verb+a+, \verb+b+ en \verb+y+. \verb+b+ zal na $100\mbox{ ns}$ een 1 aanleggen. Dit heeft als implicatie dat ook \verb+y+ van waarde zal veranderen. Indien we dit met variabelen en constanten zouden hebben berekend zou variabele \verb+y+ na de toewijzing een waarde toegewezen krijgen, en deze tot een volgende toewijzing behouden. Merk verder op dat we hier ook de betekenis van het codewoord \vhdltermen{after} tonen. Een signaal kan ook een initi\"ele waarde krijgen, hiervoor gebruiken we de \vhdltermen{:=} operator.
\subsubsection{Bibliotheken}
\subsubsection{Bewerkingen}
\section{Combinatorische schakelingen in VHDL}
\label{s:combinatorischVHDL}
Nu we verschillende schakelingen hebben gebouwd zullen we deze proberen te beschrijven met VHDL. In deze sectie zullen we eerst een formeel overzicht geven van de VHDL-syntax. Vervolgens zullen we in subsectie \ref{ss:combinatorischVHDLHardware} een methode ontwikkelen om combinatorische elementen te beschrijven met deze syntax. In elk hoofdstuk zullen we de methodologie uitbreiden zodat we de nieuwe componenten ook kunnen beschrijven.
\subsection{Hardwarebeschrijving met VHDL}
\subsubsection{Structurele beschrijving}
\begin{vhdlcode}[hbt]
\centering
\begin{lstlisting}
-- 2-naar-1 Multiplexer
--
architecture Struct of MUX2 is
  signal U,V,W : bit;
  component AND2 is
    port (X,Y: in bit;
          Z: out bit);
  end component AND2;
  component OR2 is
    port (X,Y: in bit;
          Z: out bit);
  end component OR2;
  component INV is
    port (X: in bit;
          Z: out bit);
    end component INV;
begin
  Gate1: component INV  port map (X=>S,Z=>U);
  Gate2: component AND2 port map (X=>A,Y=>S,Z=>W);
  Gate3: component AND2 port map (U,B,V);
  Gate4: component OR2  port map (X=>W,Y=>V,Z=>Y);
end Struct;
\end{lstlisting}
\caption{2-naar-1-multiplexer.}
\label{vhdl:bToAMultiplexer}
\end{vhdlcode}
\subsubsection{Gedragsbeschrijving}
\begin{vhdlcode}[hbt]
\centering
\begin{lstlisting}
-- Opteller
--
library ieee;
use ieee.std_logic_signed.all;

entity adder is
  generic(n : positive := 4);
  port(Cin : in std_logic;
       X,Y : in std_logic_vector(n-1 downto 0);
       S   : in std_logic_vector(n-1 downto 0);
       Cout, Overflow : out std_logic);
end adder;

architecture behav of adder is
  signal Sum : std_logic_vector(n downto 0);
begin
  Sum <= (X(n-1) & X) + Y + Cin;
  S <= Sum(n-1 downto 0);
  Cout <= Sum(n);
  Overflow <= Sum(n) xor X(n-1) xor Y(n-1) xor Sum(n-1);
end behav;
\end{lstlisting}
\caption{$n$-bit Opteller.}
\label{vhdl:adder}
\end{vhdlcode}
\subsubsection{Repetitieve structuren}
\label{ss:combinatorischVHDLHardware}