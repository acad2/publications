\chapter{Niet-Programmeerbare Processoren}
\chplab{nonprogramming}
\chapterquote{We accepteren nu het feit dat leren een levenslang proces is om op de hoogte te blijven van veranderingen. En de meest urgente taak is mensen te leren hoe te leren.}{Peter F. Drucker, Amerikaans management consultant en auteur (1909-)}
\begin{chapterintro}
In de twee vorige hoofdstukken hebben we componenten gebouwd met een beperkte functionaliteit. De combinatorische schakelingen laten ons toe om schakelingen te ontwerpen die een rekenkundige operatie uitvoeren, maar we hebben geen geheugen beschikbaar om tussenresultaten in op te slaan. Het hoofdstuk over sequenti\"ele schakelingen maakt het mogelijk om schakelingen te ontwerpen met een geheugen. De meeste problemen hebben echter zeer grote toestandsruimtes (een 32-bit getal heeft meer dan vier miljard toestanden). Daarom volstaan de methodes uit dit hoofdstuk niet om een component te ontwikkelen die iets functioneel doet. Daarvoor zullen we methodes op een hoger niveau introduceren, dat van een niet-programmeerbare processor. Een niet programmeerbare processor voert een algoritme uit dat op voorhand gekend is. Hierdoor kunnen we optimaal gebruik maken van de hardware en zoveel mogelijk instructies tegelijk uitvoeren. Het nadeel is dat eenmaal de processor geproduceerd is, we geen andere problemen met het
component kunnen uitvoeren.
\end{chapterintro}
\minitoc[n]
\section{De Niet-Programmeerbare Processor}
Alvorens we de bouw van zo'n processor verder uitwerken, dienen we eerst enkele concepten te formaliseren. Allereerst ontleden we in deze sectie uit welke delen zo'n processor is opgebouwd. Vervolgens zullen we in sectie \ref{s:descriptionFSMD} een methode ontwikkelen om een algoritme formeel weer te geven. Deze beschrijving zal toelaten het algoritme later om te zetten naar een processor. In sectie \ref{s:memoryFSMD} ten slotte zullen we extra geheugencomponenten introduceren die we nodig zullen hebben bij de bouw van een processor.
\subsection{Algemene Structuur}
\label{ss:specialProcessorGeneralStructure}
Een \termen{Niet-programmeerbare processor}, ofwel \termen{Finite State Machine with Data path (FSMD)} bestaat grofweg uit twee delen:
\begin{itemize}
 \item Een \termen{datapad}: een component die bewerkingen (rekenkundig, aritmetisch,...) uitvoert en de resultaten opslaat in tijdelijk geheugen.
 \item Een \termen{controller}: een component die het datapad aanstuurt. Het zegt welke actie op welk moment moet ondernomen worden.
\end{itemize}
In dit hoofdstuk is de controller niet programmeerbaar. Dat wil zeggen dat de controller telkens hetzelfde programma uitvoert. Dit betekent echter niet dat er een vaste cyclus in de controller zit. De controller kan afhankelijk van de waarden die in de geheugens van het datapad zitten, of van ingangen van de processor beslissen om andere acties te ondernemen. Een controller is dus een sequenti\"ele schakeling ofwel finite state machine. De synthese van een finite state machine werd in het hoofdstuk \ref{ch:SeqComp} reeds besproken. Uiteraard zullen we de karakteristieken die eigen zijn aan controllers in dit hoofdstuk bespreken.
\paragraph{}
Het spreekt voor zich dat de controller en het datapad continu data met elkaar uitwisselen. Enerzijds geeft de controller instructies aan het datapad. De groep signalen waarmee een controller een datapad aanstuurt noemen we het ``\termen{instructiewoord}'' ofwel ``\termen{controle-signalen}''. Anderzijds zullen de instructies vaak afhangen van de toestand van variabelen opgeslagen in het datapad. De verzameling van signalen die het datapad over zijn variabelen doorstuurt naar de controller noemen we ``\termen{statussignalen}''.
\paragraph{}
Een processor voert operaties uit op data. Deze data moet op de een of andere manier ingelezen worden in de processor. De verzameling ingangen waarmee we data vanuit de omgeving in het datapad injecteren noemen we de ``\termen{data-ingangen}''. Verder zullen we vaak ook informatie aan de controller moeten meedelen: we denken bijvoorbeeld aan een signaal dat actief wordt wanneer alle data ingelezen is, en het algoritme kan uitgevoerd worden. Deze signalen noemen we ``\termen{controle-ingangen}''. Daarnaast willen we ook de resultaten kunnen uitlezen. Hiervoor voorzien we een reeks signalen vanuit het datapad, deze signalen noemen we ``\termen{data-uitgangen}''. Tot slot zijn we soms ook ge\"interesseerd in de toestand van het algoritme. We zullen bijvoorbeeld enkel data uitlezen indien het algoritme afgelopen is. De controller kan informatie over het algoritme naar buiten brengen via ``\termen{controle-uitgangen}''. De verschillende informatiestromen tussen het datapad en de controller en de processor en zijn
omgeving beschrijven we op figuur \ref{fig:processorInformationStreams}.
\begin{figure}[hbt]
\centering
\subfigure[Processor]{
\begin{tikzpicture}[scale=0.8]
\draw[gray,dashed,thick] (-2.5,-3) rectangle (2.5,3);
\draw (-2.5,0) node[rotate=-90,gray,anchor=south]{Processor};
\draw (-2.5,0) node[rotate=-90,gray,anchor=north]{Omgeving};
\node[rectangle,thick,draw=black,minimum width=2 cm,minimum height=0.75 cm] (D) at (0,2) {Datapad};
\node[rectangle,thick,draw=black,minimum width=2 cm,minimum height=0.75 cm] (C) at (0,-2) {Controller};
\draw[->,thick] (D.south -| 0.3333,0) to node[midway,sloped,above,scale=0.8]{status-signalen} (C.north -| 0.3333,0);
\draw[->,thick] (C.north -| -0.3333,0) to node[midway,sloped,above,scale=0.8]{instructiewoord} (D.south -| -0.3333,0);
\draw[<-,thick] (C.west) to node[below,midway,scale=0.8]{controle-ingangen} (-4.25,-2);
\draw[->,thick] (C.east) to node[below,midway,scale=0.8]{controle-uitgangen} (4.25,-2);
\draw[<-,thick] (D.west) to node[above,midway,scale=0.8]{data-ingangen} (-4.25,2);
\draw[->,thick] (D.east) to node[above,midway,scale=0.8]{data-uitgangen} (4.25,2);
\end{tikzpicture}
\figlab{processorInformationStreams}}
\subfigure[Datapad]{
\begin{tikzpicture}[scale=0.8]
\draw[gray,dashed,thick] (-3.5,-3) rectangle (3.5,3);
\draw (-3.5,1.3) node[rotate=-90,gray,anchor=south]{Datapad};
\draw (-3.5,1.3) node[rotate=-90,gray,anchor=north]{Omgeving};
\node[rectangle,thick,draw=black,minimum width=2 cm] (T) at (0,1.25) {Tijdelijk geheugen};
\node[trapezium,thick,draw=black] (O) at (0,0) {Operatorverbindingen};
\node[rectangle,thick,draw=black,minimum width=2 cm] (F) at (0,-1.25) {Functionele eenheden};
\node[minimum width=2 cm] (RA) at (0,-2.5) {Resultaatverbindingen};
\node[minimum width=2 cm,white] (RB) at (0,2.5) {Resultaatverbindingen};
\draw[thick] (RA.north west) -- (O.bottom left corner |- RA.south) -- (RA.south east) -- ++(1,0) |- (RB.north west) -- (RB.south -| O.bottom left corner) -- (RB.south east) -- ++(0.5,0) |- (RA.north west);
\draw[thick,->] (RB) -- (T);
\draw[thick,->] (T) -- (O);
\draw[thick,->] (O) -- (F);
\draw[thick,->] (F) -- (RA);
\draw[<-,thick] (RA.west -| O.west) -- ++(-3,0);
\draw[<-,thick] (RB.west -| O.west) -- ++(-3,0);
\draw (-4,0) node[scale=0.8,anchor=south]{instructiewoord};
\draw (-4,-2.5) node[scale=0.8,anchor=south]{instructiewoord};
\draw (-4,2.5) node[scale=0.8,anchor=south]{externe-ingangen};
\draw (1.75,-3.5) node[scale=0.8,anchor=south]{externe-uitgangen};
\draw[<-,thick] (O.west) -- ++(-3,0);
\draw[->,thick] (RA) |- ++(3.5,-1);
\end{tikzpicture}
\figlab{datapadInformationStreams}}
\caption{Opbouw van een processor en datapad.}
\end{figure}
\paragraph{}
Door de controle-ingangen wordt de definitie van ``niet-programmeerbaar'' natuurlijk vaag. We zouden immers het toestandswoord van de controller in grote mate laten afhangen van de invoer die de controle-ingangen. Hierdoor kunnen we de processor toch programmeren. Het onderscheid is dan ook eerder een common-sense.
\subsection{Het Datapad}
Zoals we reeds hebben vermeld, kunnen we een controller modelleren als een eindige toestandsautomaat ofwel finite state machine. Een datapad daarentegen bestaat uit verschillende componenten:
\begin{itemize}
 \item \termen{Functionele Eenheden} ofwel \termen{Functional Units (FU)}: dit zijn schakelingen die berekeningen en aritmetisch operaties uitvoeren. Dit zijn dus de componenten die we in hoofdstuk \ref{ch:combinatoric} hebben besproken: optellers, ALU, schuifoperator,... Uiteraard kunnen we ook zelf functionele eenheden bouwen op de manier die we gezien hebben.
 \item \termen{Tijdelijke geheugens}: dit zijn componenten die de waarden waarop we bewerkingen uitvoeren voor enkele klokcycli kunnen vasthouden. Dit zijn bijvoorbeeld de registerbanken en RAM die we in sectie \ref{s:memoryFSMD} zullen invoeren. Het zijn groepen van flipflops die ons toelaten om op een hoger niveau te redeneren.
 \item \termen{Verbindingen}: de tijdelijke geheugens en de functionele eenheden wisselen informatie uit. Daarom hebben we twee types verbindingen nodig:
 \begin{itemize}
  \item \termen{Operandverbindingen}: dit zijn verbindingen die de waardes van de tijdelijke geheugens overbrengen als operanden van de functionele eenheden. De waarde van een register kan op die manier bijvoorbeeld gebruikt worden bij een optelling.
  \item \termen{Resultaatverbindingen}: het is de bedoeling dat de resultaten vervolgens in een tijdelijk geheugen opgeslagen worden. Resultaatverbindingen transporteren de resultaten van de functionele eenheden terug naar de tijdelijke geheugens. Sommige uitvoer kan ook weggeschreven worden naar de data-uitgangen. Ook de invoer van de data-ingangen wordt door deze verbindingen verwerkt.
 \end{itemize}
 Het spreekt voor zich dat de verbindingen beslissen welke geheugens als operanden en resultaatgeheugens dienen. Daarom zullen we ze implementeren als bussen met multiplexers en 3-state buffers. Deze bussen zullen dan worden aangestuurd door de controller.
\end{itemize}
Dit concept beschrijven we op figuur \ref{fig:datapadInformationStreams}.
\paragraph{}
In het datapad doen we dan ook niets anders dan waardes uit het tijdelijke geheugen inlezen, er een operatie van een functionele eenheid op uitvoeren en vervolgens in een tijdelijk geheugen plaatsen. Dit proces noemen we ook wel de ``\termen{registertransfer}'' en formaliseren we als:
\begin{equation}
\mbox{register}_a\leftarrow\mbox{FU}_a\left(\mbox{register}_{a_1},\mbox{register}_{a_2},\ldots,\mbox{register}_{a_n}\right)
\end{equation}
In het eerste hoofdstuk hebben we reeds vermeld dat we schakelingen bij het bouwen van een processor beschrijven op registertransfer-niveau. Dit betekent dat we bijvoorbeeld abstractie zullen maken van flipflops en zullen werken met registers. Ook zullen we details als het aantal bits die een opteller nodig heeft verwaarlozen. Deze nieuwe notatiestijl zullen we geleidelijk invoeren.
\section{Formeel Beschrijven van een Algoritme}
\label{s:descriptionFSMD}
Alvorens we een processor kunnen bouwen die een algoritme uitvoert, moeten we eerst een formeel algoritme kunnen opstellen. Dit algoritme vertrekt altijd vanuit een probleemstelling. Hoe we een probleemstelling omzetten naar een algoritme behoort niet tot de inhoud van deze cursus\footnote{Het omzetten van een probleem in een algoritme is geen exacte wetenschap. Het is een vaardigheid die wel geoefend kan worden. Hiervoor bestaan er andere cursussen.}. We zullen altijd stellen dat het algoritme vooraf gekend moet zijn.
\subsection{Leidend Voorbeeld: Deler}
Als leidend voorbeeld doorheen dit hoofdstuk zullen we een processor bouwen die natuurlijke getallen kan delen. Uiteraard zouden we hiervoor een combinatorische schakeling kunnen bouwen. We zullen echter een algoritme beschouwen om de berekening te maken. De processor heeft 2 4-bit ingangen die het deeltal en de deler inlezen. Verder bevat het ook een controle-ingang. Zolang we een laag signaal op de controle-ingang aanleggen betekent dit dat er geen correcte invoer op de data-ingangen staat. Pas wanneer we een hoog signaal aanleggen zal het algoritme dus een deling uitvoeren. Verder bevat de processor ook 2 4-bit uitgangen om het quoti\"ent en de rest naar buiten te brengen, en een controle uitgang die hoog wordt op het moment dat het algoritme het quoti\"ent en de rest heeft berekend. Zolang de controle-uitgang dus laag is, is het algoritme nog bezig met de berekening. Verder zal de processor ook wachten totdat de controle-ingang eerst laag is geweest alvorens opnieuw te beginnen. We maken de assumptie dat
de deler nooit gelijk is aan 0. Het algoritme dat dan vervolgens het deeltal en de deler omzet in het quoti\"ent en rest staat op \algoref{alg:devisionFSMD}.
\begin{algorithm}[hbt]
\caption{Delen van twee $n$-bit getallen.}\alglab{devisionFSMD}
\begin{algorithmic}[1]
\Function{Division}{$N,D$}
\State $Q\gets 0$
\State $R\gets 0$
\For{$I=n-1\mbox{ \textbf{to} }0$}
\State $R\gets R\shlcmd{}1$\Comment{Logische shift $R$ naar links over 1 positie}
\State $R\left[0\right]\gets N\left[n-1\right]$
\State $N\gets N\shlcmd{}1$\Comment{Logische shift $N$ naar links over 1 positie}
\State $Q\gets Q\shlcmd{}1$\Comment{Logische shift $Q$ naar links over 1 positie}
\If{$R\geq D$}
\State $R\gets R-D$
\State $Q\left[0\right]\gets 1$
\EndIf
\EndFor
\State \Return $\left(Q,R\right)$
\EndFunction
\end{algorithmic}
\end{algorithm}
We gaan niet in op de precieze werking van het algoritme. Indien we een index opvragen of zetten bij een variabele zoals $V\left[i\right]$ betekent dit dat we een operatie op de $i$-de bit uitvoeren. We tellen we van rechts naar links, $V[0]$ is dus de minst beduidende bit van $V$ die rechts staat in de encodering. Verder zullen we ook de subscript-notatie gebruiken wanneer we bits samen nemen. Zo betekent $v_2v_1w_2w_2v_2w_1$ dat we een getal samenstellen uit de eerste twee bits van $V$, gevolgd door de eerste en de derde bit van $W$, daarna volgen nog de derde bit van $V$ en de tweede bit van $W$. Dit algoritme is echter niet geschikt voor een processor. Een processor voert immers continu het programma uit. Bovendien wordt hier niet gewacht tot er invoer op de data-ingangen staat. Een laatste opmerking is dat we geen berekeningen op invoer kunnen uitvoeren. Anders zouden we immers de uitgangen van functionele eenheden met de ingangen van de processor verbinden. Daarom dienen we variabelen te introduceren
die we $X$, $Y$ en $Z$ noemen. Daarom zullen we het algoritme herschrijven\footnote{Strikt genomen is dit geen algoritme meer, vermits het nooit eindigt en er geen echt resultaat is. Een betere bewoording is waarschijnlijk procedure.}. We beschouwen hierbij de controle-ingang $ci$ en de controle-uitgang $co$. De herschreven procedure staat in \algoref{alg:devisionFSMDRev}.
\begin{algorithm}[hbt]
\caption{Procedure voor het delen van twee $4$-bit getallen.}\label{alg:devisionFSMDRev}
\begin{algorithmic}[1]
\Procedure{Division}{}
\While{true}
\Repeat\label{algl:s1start}
\State $co\gets 0$
\State $X\gets N$
\State $Y\gets 0$
\State $Z\gets 0$
\Until{$ci$}\label{algl:s1stop}
\For{$I=3\mbox{ \textbf{to} }0$}\label{algl:s2start}
\State $Z\gets Z\shlcmd{}1$\Comment{Logische shift $Z$ naar links over 1 positie}
\State $Z\left[0\right]\gets X\left[3\right]$
\State $X\gets X\shlcmd{}1$\Comment{Logische shift $X$ naar links over 1 positie}
\State $Y\gets Y\shlcmd{}1$\Comment{Logische shift $Y$ naar links over 1 positie}
\If{$Z\geq D$}\label{algl:devisionFSMDComp}
\State $Z\gets Z-D$\label{algl:devisionFSMDSub}
\State $Y\left[0\right]\gets 1$
\EndIf
\EndFor\label{algl:s2stop}
\Repeat\label{algl:s3start}
\State $co\gets 1$
\State $Q\gets Y$
\State $R\gets Z$
\Until{$\neg ci$}\label{algl:s3stop}
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
\subsection{Toestandsbeschrijving}
Een eerste probleem dient zich aan hoe we de procedure omzetten in een reeks toestanden. De vraag is immers wat we in \'e\'en zo'n toestand zullen realiseren. Zo kunnen we \algoref{alg:devisionFSMDRev} uitvoeren en per instructie een nieuwe toestand bouwen. Als we echter het programma onder de loep nemen, zien we dat dit algoritme zich uitstekend leent om verschillende instructies samen uit te voeren. Allereerst voeren we in de \textbf{for}-lus hoofdzakelijke shift operaties uit. Deze shiftoperaties vinden plaats over een vast aantal posities. We dienen dus helemaal geen schuifoperator te implementeren, en kunnen eenvoudigweg schuiven met verbindingen. Vervolgens doen we ook aan bitmanipulaties. Omdat deze bitmanipulaties opnieuw op vaste plaatsen plaatsvinden kunnen we dit realiseren met behulp van verbindingen. De enige twee aspecten die enige logica vereisen is de test of $Z\geq D$ is (lijn \ref{algl:devisionFSMDComp}), en het eventueel aftrekken van $D$ uit $Z$ (lijn \ref{algl:devisionFSMDSub}).
Daarnaast moeten we tijdens de uitvoer van de \textbf{for} lus ook controleren of $I\geq 0$. In dat geval dienen we immers nogmaals de for-lus uit te voeren. We kunnen dit echter controleren met een simpele OR-poort die alle bits van $I$ samenneemt. Indien minstens \'e\'en van de bits een 1 is, zal de OR-lus een 1 teruggeven, en dienen we dus nog een cyclus uit te voeren. Dit leidt ertoe dat we ons algoritme in drie toestanden opdelen:
\begin{enumerate}
 \item $S_0$: inlezen van invoer, initialiseren van variabelen en wachten totdat $ci$ hoog wordt (lijnen \ref{algl:s1start}-\ref{algl:s1stop}).
 \item $S_1$: uitvoeren van een cyclus van de \textbf{for} lus en $I$ met 1 verlagen (lijnen \ref{algl:s2start}-\ref{algl:s2stop}).
 \item $S_2$: resultaten op de uitgang plaatsen en wachten tot $ci$ laag wordt (lijnen \ref{algl:s3start}-\ref{algl:s3stop}).
\end{enumerate}
\subsection{Toestand-Actie Tabel}
Nu we de toestanden hebben vastgesteld kunnen we het algoritme verder formaliseren. Dit zouden we kunnen doen met een grafische voorstelling zoals we gedaan hebben met een eindige toestandsautomaat. Het probleem is dat een rij in het toestandsdiagram niet enkel de voorwaarden en eventuele uitgangen bevat, daarnaast dient het ook nog de acties die door het datapad moeten worden uitgevoerd weer te geven. Dit zou leiden tot een complex en chaotisch diagram. Daarom verkiezen we een tabel: de ``\termen{Toestand-Actie Tabel}''. De tabel bestaat grofweg uit drie gedeeltes:
\begin{itemize}
 \item de huidige toestand: de huidige toestand waarin de controller zich bevindt.
 \item Een toestandsgedeelte: die we kunnen vergelijken met de toestandstabel van een eindige toestandsautomaat. De tabel bevat volgende kolommen:
 \begin{itemize}
  \item condities (afhankelijk van controle- en status-signalen)
  \item de volgende toestand
  \item de uitvoer (van eventuele controle-uitgangen).
 \end{itemize}
 \item een controle-actie gedeelte. Dit gedeelte bevat twee kolommen:
 \begin{itemize}
  \item conditie: een set voorwaarden wanneer een bepaalde set acties (gespecificeerd in de volgende kolom) moet worden uitgevoerd.
  \item actie: afhankelijk van de conditie welke opdrachten uitgevoerd worden op de variabelen in een klokcyclus.
 \end{itemize}
\end{itemize}
Tabel \ref{tbl:stateActionTableRunningExample} toont de toestand-actie tabel van \algoref{alg:devisionFSMDRev}. Een belangrijke opmerking is dat het onderverdelen van toestanden in condities bij het toestandsgedeelte niet verder loopt bij het onderverdelen van diezelfde toestand in het controle-actie gedeelte. Dit betekent dus dat de conditie bij de volgende toestand niet de conditie bij de controle- en datapad-acties impliceert en omgekeerd. Concreet betekent dit dus dat indien $I>0$, dit niet betekent dat $z_2z_1z_0x_3<D$ of dat we de bijbehorende datapad-acties moeten uitvoeren. Het toestandsgedeelte en het controle-actie gedeelte zijn dus onafhankelijk en zijn enkel afhankelijk van de huidige toestand.
\begin{table}[hbt]
\centering
\begin{tabular}{c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c}
Huidige&\multicolumn{2}{c|}{Volgende toestand}&Uit-&\multicolumn{2}{c}{Controle- \& datapad-acties}\\
Toestand&Conditie&Toestand&gang&Conditie&Acties\\\noalign{\hrule height 1pt}
\multirow{4}{*}{$S_0$}&\multirow{2}{*}{$ci=0$}&\multirow{2}{*}{$S_0$}&\multirow{2}{*}{$co=0$}&&$X\gets N$\\
&&&&&$Y\gets 0$\\\cline{2-4}
&\multirow{2}{*}{$ci=1$}&\multirow{2}{*}{$S_1$}&\multirow{2}{*}{$co=0$}&&$Z\gets 0$\\
&&&&&$I\gets 3$\\\noalign{\hrule height 1pt}
\multirow{8}{*}{$S_1$}&\multirow{4}{*}{$I>0$}&\multirow{4}{*}{$S_1$}&\multirow{4}{*}{$co=0$}&\multirow{4}{*}{$z_2z_1z_0x_3<D$}&$Z\gets z_2z_1z_0x_3$\\
&&&&&$X\gets X\shlcmd 1$\\
&&&&&$Y\gets Y\shlcmd 1$\\
&&&&&$I\gets I-1$\\\cline{2-6}
&\multirow{4}{*}{$I=0$}&\multirow{4}{*}{$S_2$}&\multirow{4}{*}{$co=0$}&\multirow{4}{*}{$z_2z_1z_0x_3\geq D$}&$Z\gets z_2z_1z_0x_3-D$\\
&&&&&$X\gets X\shlcmd 1$\\
&&&&&$Y\gets y_2y_1y_01$\\
&&&&&$I\gets I-1$\\\noalign{\hrule height 1pt}
\multirow{6}{*}{$S_2$}&\multirow{3}{*}{$ci=0$}&\multirow{3}{*}{$S_0$}&$co=1$&&\\
&&&$Q=Y$&&\\
&&&$R=Z$&&\\\cline{2-4}
&\multirow{3}{*}{$ci=1$}&\multirow{3}{*}{$S_2$}&$co=1$&&\\
&&&$Q=Y$&&\\
&&&$R=Z$&&\\
\end{tabular}
\caption{Toestand-actie tabel van het leidend voorbeeld.}
\label{tbl:stateActionTableRunningExample}
\end{table}
\paragraph{Simulatie}Om ons meer vertrouwd te maken met het concept van een toestand-actie tabel zullen we een deling simuleren met behulp van de tabel. We zullen $N=12$ delen door $D=7$ op de processor en stap per stap kijken wat er verandert. Dit doen we met behulp van tabel \ref{tbl:stateActionTableRunningExampleSim}. Omdat we met bitoperaties werken zullen we alle variabelen in de tabel in binaire notatie zetten.
\begin{table}[hbt]
\centering
\begin{tabular}{c|c|c|c}
Toestand&Voldane Condities&Acties&Uitvoer\\\hline
\multirow{4}{*}{$S_0$}&\multirow{4}{*}{$ci=1$}&$X\gets N=1100$&\multirow{4}{*}{$co=0$}\\
&&$Y\gets0000$&\\
&&$Z\gets0000$&\\
&&$I\gets11$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=11>00$}&$Z\gets z_2z_1z_0x_3=0001$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=1000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0001<D=0101$}&$Y\gets Y\shlcmd{} 1=0000$&\\
&&$I\gets I-1=10$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=10>00$}&$Z\gets z_2z_1z_0x_3=0011$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0011<D=0101$}&$Y\gets Y\shlcmd{} 1=0000$&\\
&&$I\gets I-1=01$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=01>00$}&$Z\gets z_2z_1z_0x_3-D=0001$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0110\geq D=0101$}&$Y\gets y_2y_1y_01=0001$&\\
&&$I\gets I-1=00$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=00$}&$Z\gets z_2z_1z_0x_3=0010$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0010<D=0101$}&$Y\gets Y\shlcmd{} 1=0010$&\\
&&$I\gets I-1=11$&\\\hline

\multirow{3}{*}{$S_2$}&\multirow{3}{*}{$ci=0$}&&$co=1$\\
&&&$Q=Y=0010$\\
&&&$R=Z=0010$\\
\end{tabular}
\caption{Simulatie van het algoritme met behulp van de toestand-actie tabel (tabel \ref{tbl:stateActionTableRunningExample}).}
\label{tbl:stateActionTableRunningExampleSim}
\end{table}
We stellen dat vanaf dat we de simulatie beginnen, reeds de data op de ingangen van de processor aangelegd staat. Bijgevolg is $ci=1$, $N=1100$ en $D=0101$. We maken verder ook een assumptie dat $X$, $Y$ en $Z$ 4-bit geheugens zijn, dit is redelijk vermits we uitsluitend bits in dit bereik gebruiken, en we geen schuifoperaties naar rechts uitvoeren waardoor hogere bits in het bereik zouden komen te liggen. $I$ is een 2-bit geheugen vermits het uitsluitend waardes tussen 0 en 3 moet aannemen. Initieel vertrekt de processor vanuit toestand $S_0$ we zien op die toestand-actie tabel dat in toestand $S_0$ de ingangen in de geheugens worden ingelezen. Vermits er data op de ingangen staat, krijgt $X$ de waarde van de teller $N=1100$. De overige variabelen worden ge\"initialiseerd zoals beschreven staat in de toestand-actie tabel. Omdat $ci=1$ kunnen we afleiden dat de volgende toestand $S_1$ is. Verder specificeert de tabel ook dat we een laag signaal op de controle-uitgang moeten aanleggen (momenteel staat
er immers geen uitkomst op de uitgangen). In de volgende stap bevinden we ons in toestand $S_1$. We evalueren eerst de verschillende condities ??.
\subsection{ASM-Schema}
Zoals reeds gezegd is de visualisatie van een eindige toestandsautomaat niet toereikend om een algoritme weer te geven. Een grafisch voorstelling die we wel kunnen gebruiken is een ``\termen{Algorithmic-State-Machine Chart}'' ofwel ``\termen{ASM-schema}''.
\subsubsection{ASM-Elementen}
Een ASM-schema lijkt op een flow-chart en bestaat drie verschillende soorten ``\termen{ASM-elementen}'':
\begin{itemize}
 \item \termen{Toestandskader} ofwel \termen{state box}: dit is een set niet-conditionele toekenning. We stellen een toestandskader voor door middel van een rechthoek waarin we de toekenningen schrijven. De toekenningen in \'e\'en toestandskader worden parallel uitgevoerd. Daarnaast bevat een toestandskader ook de status- en data-uitgangen van de processor. Men maakt een onderscheid doordat toekenningen met een pijl ($\gets$) weergegeven worden en uitgangen met een gelijkheidsteken ($=$). Figuur \ref{fig:asmElementState} toont een voorbeeld van een toestandskader.
 \item \termen{Beslissingskader} ofwel \termen{decision box}: dit is de voorstelling van een bepaalde conditie. Een conditie wordt voorgesteld met behulp van een ruit, waarin de conditie wordt geschreven. Vanuit een beslissingskader vertrekken er twee pijlen: voor het geval waarin de voorwaarde waar of vals is. We noteren de pijlen dan ook respectievelijk met ``[True]'' en ``[False]'', soms wordt ook 1 en 0 gebruikt. Figuur \ref{fig:asmElementDecision} toont een voorbeeld van een beslissingskader.
 \item \termen{Conditioneel kader} ofwel \termen{conditional box}: Dit is een toestandskader die enkel onder voorwaarden gespecificeerd door een beslissingskader worden uitgevoerd. Ook deze toekenningen worden in parallel uitgevoerd. Verder bevat een conditioneel kader ook de conditionele uitvoer op de processoruitgangen. We noteren toekenningen en uitgangen op dezelfde manier als bij toestandskaders. Men stelt een conditioneel kader voor als een rechthoek met afgeronde hoeken. Figuur \ref{fig:asmElementConditional} toont een voorbeeld van een conditioneel kader.
\end{itemize}
\begin{figure}[hbt]
\centering
\subfigure[Toestandskader]{
\begin{tikzpicture}
%\node[asmS] (S) at (0,0) {$\begin{array}{c}\mbox{niet conditioneel commando 1}\\\mbox{niet conditioneel commando 2}\\\cdots\\\mbox{niet conditioneel commando $n$}\end{array}$};
\node[asmS] (S) at (0,0) {$\begin{array}{c}\mbox{variabele$_1\gets$ expressie$_1$}\\\cdots\\\mbox{variabele$_m\gets$ expressie$_m$}\\\mbox{uitgang$_1=$ expressie$_{m+1}$}\\\cdots\\\mbox{uitgang$_n=$ expressie$_{m+n}$}\end{array}$};
\draw[<-] (S) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (S) -- ++(0,-1.5) node[anchor=north]{uit};
\end{tikzpicture}
\figlab{asmElementState}
}
\subfigure[Beslissingskader]{
\begin{tikzpicture}
\node[asmD] (D) at (0,0) {test};
\draw[<-] (D) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (D) -| ++(-1.75,-1.5) node[anchor=north]{uit 1};
\draw[->] (D) -| ++(1.75,-1.5) node[anchor=north]{uit 2};
\draw (-1.75,0) node[anchor=south west,scale=0.75]{[True]};
\draw (1.75,0) node[anchor=south east,scale=0.75]{[False]};
\end{tikzpicture}
\figlab{asmElementDecision}
}
\subfigure[Conditioneel kader]{
\begin{tikzpicture}
%\node[asmC] (C) at (0,0) {$\begin{array}{c}\mbox{conditioneel commando 1}\\\mbox{conditioneel commando 2}\\\cdots\\\mbox{conditioneel commando $n$}\end{array}$};
\node[asmC] (C) at (0,0) {$\begin{array}{c}\mbox{variabele$_1\gets$ expressie$_1$}\\\cdots\\\mbox{variabele$_m\gets$ expressie$_m$}\\\mbox{uitgang$_1=$ expressie$_{m+1}$}\\\cdots\\\mbox{uitgang$_n=$ expressie$_{m+n}$}\end{array}$};
\draw[<-] (C) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (C) -- ++(0,-1.5) node[anchor=north]{uit};
\end{tikzpicture}
\figlab{asmElementConditional}
}
\caption{Voorstelling van de verschillende ASM-elementen}
\figlab{asmElementsEnum}
\end{figure}
\subsubsection{Het ASM-Blok}
Deze ASM-elementen worden gegroepeerd in een ``\termen{ASM-blok}''. Alle ASM-elementen die in eenzelfde ASM-blok zitten, worden dan in \'e\'en klokcyclus uitgevoerd. Hierdoor voorzien we per toestand in de Toestand-Actie tabel een ASM-blok. Het blok zelf moet dan specificeren wat er in de toestand gebeurt. We zullen deze component voorstellen met behulp van een vierkant met streepjeslijnen. Vermits alle acties in \'e\'en klokflank uitgevoerd worden, bevat elk ASM-blok exact \'e\'en toestandskader. Dit toestandskader bevat dan alle toekenningen en uitgangen die onafhankelijk van condities in die toestand worden uitgevoerd. Indien er geen onafhankelijke operaties zijn, is het vierkant leeg. Indien er naast onafhankelijke acties ook conditionele acties gebeuren (zowel in het toestand- als het actie-gedeelte), zullen we vervolgens enkele beslissingskaders plaatsen. We voeren testen uit op variabelen in het datapad door middel van status-signalen en eventuele signalen aan de controle-ingangen. Vermits we al deze
testen reeds in de toestand-actie-tabel hebben gedefinieerd kunnen we eenvoudig de toestand-actie-tabel omvormen tot een ASM-schema. Zo staat op figuur \ref{fig:aSMSchemaRunningExample} het ASM-schema voor het leidend voorbeeld.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\ds{6};
\def\di{1.75};
\def\dy{-2};
\def\offset{1};
\node[asmS] (S1S) at (0,0) {$\begin{array}{c}X\gets N\\Y\gets 0\\Z\gets 0\\I\gets 3\\co=0\end{array}$};
\node[asmD] (S1D) at (0,\dy) {$ci=0$};
\draw[->] (S1S) -- (S1D);
\draw[->] (S1D) -| (-\di,0) -- (S1S);
\setTrueFalseLabels{S1D};

\node[asmS] (S2S) at (\ds,0) {$\begin{array}{c}X\gets X\shlcmd 1\\I\gets I-1\\co=0\end{array}$};
\node[asmD] (S2D1) at (\ds,\dy) {$z_2z_1z_0x_3<D$};
\draw[->] (S2S) -- (S2D1);
\node[asmC] (S2C1) at (\ds-\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3\\Y\gets Y\shlcmd{} 1\end{array}$};
\draw[->] (S2D1) -| (S2C1);
\node[asmC] (S2C2) at (\ds+\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3-D\\Y\gets y_2y_1y_01\end{array}$};
\draw[->] (S2D1) -| (S2C2);
\draw (S2C1) |- (\ds,2.5*\dy) -| (S2C2);
\node[asmD] (S2D2) at (\ds,3*\dy) {$I>0$};
\draw[->] (\ds,2.5*\dy) -- (S2D2);
\draw[->] (S1D) -| (\di,\offset) -| (S2S);
\draw[->] (S2D2) -| (\ds-2*\di,0) -- (S2S);
\setTrueFalseLabels{S2D1};
\setTrueFalseLabels{S2D2};

\node[asmS] (S3S) at (2*\ds,0) {$\begin{array}{c}co=1\end{array}$};
\node[asmD] (S3D) at (2*\ds,\dy) {$ci=1$};
\node[asmN] (N1) at (2*\ds,2*\dy) {$\begin{array}{c}Q=Y\\R=Z\end{array}$};
\draw[->] (S2D2) -| (\ds+2*\di,\offset) -| (S3S);
\draw[->] (S3S) -- (S3D);
\draw[->] (S3D) -| (2*\ds-\di,0) -- (S3S);
\draw[->] (S3D) -| (\di+2*\ds,1.5) -| (S1S);
\setTrueFalseLabels{S3D};
\begin{pgfonlayer}{background}
\node[asmB, fit=(S1S) (S1D)] (S1) {};
\node[asmB, fit=(S2S) (S2D1) (S2D2) (S2C1) (S2C2)] (S2) {};
\node[asmB, fit=(S3S) (S3D)] (S3) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\end{tikzpicture}
\caption{ASM-schema van het leidend voorbeeld.}
\figlab{aSMSchemaRunningExample}
\end{figure}
\subsubsection{Traditionele Valkuilen}
Traditioneel maakt men een aantal fouten tegen ASM-schemas. In deze subsubsectie zullen we een overzicht geven van de meest gemaakte fouten.
\begin{figure}[hbt]
\centering
\subfigure[Meerdere volgende toestanden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$A_0$};
\node[asmD] (T0) at (-1.75,-1.25) {$t_1$};
\node[asmD] (T1) at (1.75,-1.25) {$t_2$};
\node[asmS] (A1) at (-3,-2.375) {$A_1$};
\node[asmS] (A2) at (0,-2.375) {$A_2$};
\node[asmS] (A3) at (3,-2.375) {$A_3$};
\setTrueFalseLabels{T0};
\setTrueFalseLabels{T1};
\draw[->] (A0) -- (0,-0.5) -| (T0);
\draw[->] (0,-0.5) -| (T1);
\draw[->] (T0) -| (A1);
\draw[->] (T1) -| (A3);
\draw[->] (T0) -| (A2);
\draw[<-] (A0) -- ++(0,0.75);
\draw (T1) -| (0,-1.25);
\pdot{0,-0.5};
\pdot{0,-1.25};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (T1)] (S1) {};
\node[asmB, fit=(A1)] (S2) {};
\node[asmB, fit=(A2)] (S3) {};
\node[asmB, fit=(A3)] (S4) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\draw (S4.south west) node[anchor=south west]{$S_4$};
\end{tikzpicture}
\figlab{badASMMultipleFlows}
}
\subfigure[Geen volgende toestanden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$A_0$};
\node[asmD] (T0) at (0,-1.25) {$t_1$};
\node[asmS] (A1) at (1.25,-2.375) {$A_1$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw (T0) -| (-1.25,-0.5) -- (0,-0.5);
\pdot{0,-0.5};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0)] (S1) {};
\node[asmB, fit=(A1)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\figlab{badASMNoFlows}
}
\subfigure[Meerdere toekenningen]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$X\gets 0$};
\node[asmD] (T0) at (0,-0.75) {$t_1$};
\node[asmC] (A1) at (1.25,-1.5) {$X\gets 1$};
\node[asmS] (A2) at (0,-2.5) {$A_0$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw[->] (T0) -| (-1.25,-2) -| (A2);
\draw (A1) |- (0,-2);
\pdot{0,-2};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (A1)] (S1) {};
\node[asmB, fit=(A2)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\figlab{badASMMultipleAssignments}
}
\subfigure[Testen op nieuwe waarden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0.25) {$a\gets a-1$};
\node[asmD] (T0) at (0,-0.75) {$a>3$};
\node[asmC] (A1) at (-1.25,-1.5) {$b\gets 2$};
\node[asmS] (A2) at (0,-2.5) {$A_0$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw[->] (T0) -| (1.25,-2) -| (A2);
\draw (A1) |- (0,-2);
\pdot{0,-2};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (A1)] (S1) {};
\node[asmB, fit=(A2)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\figlab{badASMTests}
}
\subfigure[Gebruik nieuwe waarde]{
\begin{tikzpicture}
\node[asmS] (A00) at (0,0) {$y\gets x+1$};
\node[asmS] (A01) at (0,-1) {$z\gets y+2$};
\draw[->] (0,0.75) -- (A00);
\draw[->] (A00) -- (A01);
\draw[->] (A01) -- (0,-1.75);
\node (A) at (1.5,-0.5) {$\neq$};
\node[asmS] (A1) at (3,-0.5) {$\begin{array}{c}y\gets x+1\\z\gets y+2\end{array}$};
\draw[->] (3,0.75) -- (A1);
\draw[->] (A1) -- (3,-1.75);
\end{tikzpicture}
\figlab{badASMUsage}
}
\subfigure[Conditioneel na toestandskader]{
\begin{tikzpicture}
\node[asmS,minimum width=3cm] (A00) at (0,0) {$A_0$};
\node[asmC,minimum width=3cm] (A01) at (0,-1) {$A_1$};
\draw[->] (0,0.75) -- (A00);
\draw[->] (A00) -- (A01);
\draw[->] (A01) -- (0,-1.75);
\end{tikzpicture}
\figlab{badCAfterS}
}
\subfigure[Toewijzen uitgang]{
\begin{tikzpicture}
\node[asmS] (A1) at (3,-0.5) {$\mbox{uitgang}\gets\mbox{expressie}$};
\draw[->] (3,0.75) -- (A1);
\draw[->] (A1) -- (3,-1.75);
\end{tikzpicture}
}
\caption{Traditionele valkuilen bij het maken van ASM-schema's.}
\figlab{badASM}
\end{figure}
\paragraph{Meerdere volgende toestanden}Men kan in een ASM-schema een flow chart tekenen waarbij onder bepaalde condities, men twee verschillende pijlen kan volgen. Een voorbeeld van zo'n flow chart staat op figuur \ref{fig:badASMMultipleFlows}. Indien bijvoorbeeld test $t_1$ slaagt en $t2$ faalt, dienen we de stromen naar $A_1$ \'en $A_3$ te volgen. Dit is niet zo problematisch wanneer dit in hetzelfde ASM-blok gebeurt (we kunnen argumenteren dat we dan alle toewijzingen uit $A_1$ en $A_3$ uitvoeren). Indien we echter later naar verschillende toestanden gaan krijgen we problemen. We kunnen dit probleem makkelijk verhelpen door geen vertakkingen met pijlen toe te staan. Enkel uit het beslissingskader vertrekken twee pijlen. Uit een toestands- en conditioneel kader vertrekt altijd slechts \'e\'en pijl. Het samenbrengen van pijlen is wel toegelaten.
\paragraph{Geen volgende toestand}Ook het omgekeerde kan voorkomen: een ASM-blok waarbij we geen volgende toestand bekomen bij een bepaalde situatie. Figuur \ref{fig:badASMNoFlows} toont een minimaal voorbeeld: indien aan $t_1$ wordt voldaan zullen we nooit naar een volgende toestand overgaan. Dit komt omdat de pijl nooit een toestandskader bereikt (en we dus in een volgende toestand komen. Ook dit probleem kunnen we eenvoudig voorkomen: in elk ASM-blok gaan alle mogelijke lussen doorheen het toestandskader.
\paragraph{Verschillende toekenningen aan dezelfde variabele} Tijdens \'e\'en klokflank kan een variabele slechts \'e\'enmaal van waarde veranderen. We kunnen in een ASM-blok echter meerdere kaders plaatsen die elk een waarde aan dezelfde variabele toekennen. Figuur \ref{fig:badASMMultipleAssignments} toont zo'n situatie: indien $t_1$ niet waar is, kennen we zowel $0$ als $1$ toe aan $X$. Men kan argumenteren dat $X$ dan de waarde $1$ krijgt, omdat dit de laatste toekenning is aan $X$ in het diagram. De componenten die in een ASM-blok staan kunnen dus vrij veranderd worden in volgorde. Bovendien zullen we in sectie \ref{s:syntheseFSMD} een mechanisme ontwikkelen om deze ASM-schema's om te zetten in hardware. Incorrecte ASM-schema's zullen leiden tot implementatiefouten. We kunnen dit voorkomen door bij elk ASM-blok alle mogelijke paden te analyseren en te controleren dat geen variabele twee toewijzingen krijgt.
\paragraph{Testen van nieuwe waarde} Omdat alles in een ASM-blok tegelijk gebeurt, zijn de waardes van variabelen ook nog niet aangepast wanneer we een toestandsblok verlaten. Zolang we ons echter nog in hetzelfde ASM-blok bevinden, zijn die aanpassingen nog niet doorgevoerd. Stel dat we bijvoorbeeld volgende \texttt{C} programma beschouwen:
\begin{verbatim}
a--;
if(a > 3) {
  b = 2;
}
\end{verbatim}
Dan kunnen we dit vertalen naar \'e\'en toestand in het ASM-schema. Figuur \ref{fig:badASMTests} is echter niet de juiste vertaling. Stel immers dat $a=4$ dan zal in het \texttt{C}-programma de \texttt{if}-lus niet uitgevoerd worden, $a$ heeft immers voor het \texttt{if}-statement de waarde $3$. In het ASM-schema krijgt $a$ ook de waarde $3$, maar alleen nadat we het ASM-blok verlaten hebben. Bijgevolg zal bij de voorwaarde $a$ nog steeds de waarde $4$ hebben en zal de \texttt{if}-lus uitgevoerd worden. Een oplossing is om in dit geval gewoon te testen op $a-1>3$ of dus $a>4$.
\paragraph{Gebruiken van een nieuwe waarde} Een verwante traditionele fout is het gebruiken van de nieuwe waarde in de volgende berekening. Een voorbeeld van dit concept staat op figuur \ref{fig:badASMUsage}. Hier zien we twee ASM-schema's die niet equivalent zijn. Indien bijvoorbeeld $x=2$ en $y=1$ zal in de eerste flow $z=5$. In het tweede geval is $z=3$. Indien beide kaders in een verschillend ASM-blok of -element staan, is dit uiteraard toegelaten. Indien de toekenningen in hetzelfde ASM-element of ASM-blok staan, worden de opdrachten parallel uitgevoerd, en zullen we dus de oude waarde gebruiken. Men kan dit fenomeen testen door de volgorde van toekenningen in een ASM-element te wijzigen of de beslissingskaders en hun bijbehorende conditionele kaders anders te schikken. Nadat deze volgorde dan wijzigt, zou het programma nog steeds op dezelfde manier moeten werken.
\paragraph{Aanduiden van controller-uitgangen}We zijn reeds kort ingegaan op de notatie van uitgangen in de toestand- en conditionele kaders. We noteren de waarde van een uitgang met behulp van een gelijkheidsteken ($=$). Indien we de uitgang niet vermelden, staat er een 0 op die uitgang (in het geval van meerdere bits, zijn alle bits dus 0). Soms komt het ook voor dat een uitgang in elke toestand een combinatorische schakeling van enkele variabelen is. In dat geval moeten we deze uitgang niet in elk toestandskader vermelden, maar volstaat het om een nota te maken, zoals we ook op figuur \ref{fig:aSMSchemaRunningExample}. Deze nota is geen onderdeel van het ASM-schema, en wordt makkelijk vergeten.
\paragraph{Conditioneel kader na toestandskader}Een laatste fout die regelmatig terugkomt is het plaatsen van een conditioneel kader na een toestandskader zoals op figuur \ref{fig:badCAfterS}. Vermits er geen beslissingskader aan vooraf gaat, is dit conditioneel kader helemaal niet gebonden aan een voorwaarde. Dit probleem lossen we op door het conditioneel kader om te vormen tot een toestandskader. Indien beide kaders bovendien in eenzelfde ASM-blok staan, kunnen we de inhoud van beide kaders samennemen in \'e\'en toestandskader.
\subsubsection{Inputgebaseerde en Toestandsgebaseerde ASM-schema's}
We hebben het reeds kort gehad over het toekennen van toestanden aan delen van een programma besproken. Een belangrijk aspect daarbij is dat we ASM-schema's kunnen onderverdelen in twee categorie\"en:
\begin{itemize}
 \item \termen{Inputgebaseerd ASM-schema}: In dit schema kunnen we de waarde van testen (status-signale) en controle-ingangen onmiddellijk gebruiken. Een inputgebaseerd ASM-schema van het leidend voorbeeld stond op figuur \ref{fig:aSMSchemaRunningExample}.
 \item \termen{Toestandsgebaseerd ASM-schema}: Hierbij kunnen we de waardes van testen (status-signalen) en controle-ingangen pas in de volgende klokflank gebruiken. Het betekent dus dat elke voorwaardelijke uitvoering van een opdracht gepaard gaat met de overgang naar een nieuwe toestand. Bijgevolg bevat dit diagram ook geen conditionele kaders.
\end{itemize}
Inputgebaseerde ASM-schema's kunnen meer opdrachten uitvoeren in een klokflank, omdat we niet moeten wachten op het kloksignaal om conditionele operaties uit te voeren. Anderzijds zal dit ASM-schema tot een langere klokcyclus leiden. Dit komt omdat de testen eerst moeten berekend worden alvorens we sommige opdrachten kunnen uitvoeren. Een nadeel van toestandsgebaseerde ASM-schema's is dat we meer toestanden nodig hebben, wat zal leiden tot een groter geheugen en mogelijk ook logica.
\paragraph{}
De termen inputgebaseerd en toestandsgebaseerd komen van de controller. We hebben reeds besproken dat een controller een eindige toestandsautomaat is. Ook bij deze eindige toestandsautomaten hebben we deze indeling gemaakt. Een toestandsgebaseerd ASM-schema zal aanleiding geven tot een toestandsgebaseerde controller en vice versa. Bij wijze van voorbeeld zullen we het leidend voorbeeld ook met een toestandsgebaseerd ASM-schema visualiseren op figuur \ref{fig:aSMSchemaRunningExampleState}.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\ds{6};
\def\di{1.75};
\def\dy{-2};
\def\offset{1};
\node[asmS] (S1S) at (0,0) {$\begin{array}{c}X\gets N\\Y\gets 0\\Z\gets 0\\I\gets 3\\co=0\end{array}$};
\node[asmD] (S1D) at (0,\dy) {$ci=0$};
\draw[->] (S1S) -- (S1D);
\draw[->] (S1D) -| (-\di,0) -- (S1S);
\setTrueFalseLabels{S1D};

\node[asmS] (S2S) at (\ds,0) {$\begin{array}{c}X\gets X\shlcmd 1\\co=0\end{array}$};
\node[asmD] (S2D1) at (\ds,\dy) {$z_2z_1z_0x_3<D$};
\draw[->] (S2S) -- (S2D1);
\node[asmS] (S4S) at (\ds-\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3\\I\gets I-1\\Y\gets Y\shlcmd{} 1\end{array}$};
\draw[->] (S2D1) -| (S4S);
\node[asmS] (S5S) at (\ds+\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3-D\\I\gets I-1\\Y\gets y_2y_1y_01\end{array}$};
\draw[->] (S2D1) -| (S5S);
\node[asmD] (S4D) at (\ds-\di,3*\dy) {$I>0$};
\draw[->] (S4S) -| (S4D);
\node[asmD] (S5D) at (\ds+\di,3*\dy) {$I>0$};
\draw[->] (S5S) -| (S5D);
\draw[->] (S1D) -| (\di,\offset) -| (S2S);
\draw[->] (S4D) -| (\ds-2*\di,0) -- (S2S);
\setTrueFalseLabels{S2D1};
\setTrueFalseLabels{S4D};
\setTrueFalseLabels{S5D};

\node[asmS] (S3S) at (2*\ds,0) {$\begin{array}{c}co=1\end{array}$};
\node[asmD] (S3D) at (2*\ds,\dy) {$ci=1$};
\node[asmN] (N1) at (2*\ds,2*\dy) {$\begin{array}{c}Q=Y\\R=Z\end{array}$};
\draw[->] (S4D) -| (\ds-0.375*\di,3.75*\dy) -| (\ds+2*\di,\offset) -| (S3S);
\draw (S5D) -| (\ds+0.375*\di,3.5*\dy) -| (\ds-2*\di,0 |- S4D);
\draw (S5D) -- (S5D -| \ds+2*\di,0);
\pdot{S5D -| \ds+2*\di,0}
\pdot{\ds-2*\di,0 |- S4D}
\draw[->] (S3S) -- (S3D);
\draw[->] (S3D) -| (2*\ds-\di,0) -- (S3S);
\draw[->] (S3D) -| (\di+2*\ds,1.5) -| (S1S);
\setTrueFalseLabels{S3D};
\begin{pgfonlayer}{background}
\node[asmB, fit=(S1S) (S1D)] (S1) {};
\node[asmB, fit=(S2S) (S2D1)] (S2) {};
\node[asmB, fit=(S3S) (S3D)] (S3) {};
\node[asmB, fit=(S4S) (S4D)] (S4) {};
\node[asmB, fit=(S5S) (S5D)] (S5) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\draw (S5.south west) node[anchor=south west]{$S_4$};
\draw (S4.south west) node[anchor=south west]{$S_5$};
\end{tikzpicture}
\caption{Toestandsgebaseerd ASM-schema van het leidend voorbeeld.}
\figlab{aSMSchemaRunningExampleState}
\end{figure}
\section{Geheugencomponenten}
\label{s:memoryFSMD}
Alvorens we processoren kunnen implementeren zullen we eerst nieuwe componenten moeten introduceren. We zullen we deze componenten introduceren in een logische volgorde waarbij componenten gebruik maken van eerder ge\"introduceerde componenten.
\subsection{Register File Cell (RFC)}
Een \termen{register file cell} is een uitbreiding op een geklokte D-flipflop. Het component bevat een klok-ingang $\mbox{Clk}$, data-ingangen $D_{\mbox{\small{in}}1},\ldots,D_{\mbox{\small{in}}m}$, data-uitgangen $D_{\mbox{\small{out}}1},\ldots,D_{\mbox{\small{out}}n}$, \termen{leespoorten $\mbox{RE}_1,\mbox{RE}_{n}$} (ook wel ``\termen{Read-Enabled}'' genoemd) en \termen{schrijfpoorten $\mbox{WE}_1,\ldots,\mbox{WE}_{\left\lceil\log_2m+1\right\rceil}$} (ook wel ``\termen{Write-Enabled}'' genoemd). Deze ingangen laten ons toe om te kiezen uit welke data-ingang we data willen inlezen en deze bij de klokflank willen opslaan. We zullen data geklokt wegschrijven, net zoals bij een D-flipflop. Indien alle schrijfpoorten $\mbox{WE}_i=0$ lezen we geen nieuwe waarde in, en blijft de oude waarde behouden. In de andere gevallen dienen de schrijfpoorten een binair getal $a$ te bepalen vanuit welke data-ingang $d_{\mbox{\small{in}}a}$ we data inlezen. Indien er voor het aantal data-ingangen $m$ geen natuurlijk getal
$l$ bestaat zodat $l=\log_2 m+1$, zal er bij alle overige write-enable configuraties, data ingelezen worden uit de laatste data-ingang. Daarnaast kunnen we op eender welke uitgang de inhoud van het geheugen plaatsen. Vandaar dat er per uitgang ook een read-enable ingang is voorzien. Indien we een laag signaal aanleggen op een read-enable ingang $\mbox{RE}_i$, zal de overeenkomstige uitgang $D_{\mbox{\small{out}}i}$ hoog impedant zijn. De toestand van de uitgangen is niet geklokt: indien we tijdens twee klokflanken in een read-enable ingang aanpassen zullen we mits enige vertraging het resultaat op de data-uitgang zien, we hoeven dus niet op een klokflank te wachten. Op figuur \ref{fig:registerFileCell} tonen we een implementatie van een Register File Cell met $m=n=2$.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\node[dff] (D) at (0,0) {};
\node[mux4to1,rotate=90] (M) at (-1.75,0 |- D.D) {};
\draw (M.output) -- (D.D);
\node[tris] (T1) at (1.75,0 |- D.Q) {};
\node[tris] (T2) at (2.5,-0.25) {};
\draw (D.Q) -- (T1.x);
\draw (D.Q -| 1.25,0) |- (T2.x);
\draw (D.Q -| 1.25,0) |- (-2.25,1.5) |- (M.data0);
\draw (M.data3) -| (M.data2 -| -2.25,0);
\draw (M.data1) -- ++(-1,0) node[anchor=east,scale=0.85]{$D_{\mbox{\small{in}}1}$};
\draw (M.data2) -- ++(-1,0) node[anchor=east,scale=0.85]{$D_{\mbox{\small{in}}2}$};
\draw (D.Clk) -| (-1,-2) node[anchor=north,scale=0.85]{Clk};
\draw (T1.z) -- (T1.z -| 3.5,0) node[anchor=west,scale=0.85]{$D_{\mbox{\small{out}}1}$};
\draw (T2.z) -- (T2.z -| 3.5,0) node[anchor=west,scale=0.85]{$D_{\mbox{\small{out}}2}$};
\draw (T1.c) -- (T1.c |- 0,-1.75) node[anchor=north,scale=0.85]{$\mbox{RE}_1$};
\draw (T2.c) -- (T2.c |- 0,-1.75) node[anchor=north,scale=0.85]{$\mbox{RE}_2$};
\draw (M.selout1) -- (M.selout1 |- 0,2) node[anchor=south,scale=0.85]{$\mbox{WE}_2$};
\draw (M.selout0) -| (-1.125,2) node[anchor=south,scale=0.85]{$\mbox{WE}_1$};
\pdot{D.Q -| 1.25,0};
\pdot{M.data2 -| -2.25,0};
\setIndexLabelsMuxD[west]{M};
\node[rectangle,draw=black,dashed,inner sep=0.3cm, fit=(M) (D) (T1) (T2)] (S1) {};
\end{tikzpicture}
\caption{Implementatie van een Register File Cell (RFC) met $2$ lees- en $2$ schrijfpoorten}
\figlab{registerFileCell}
\end{figure}
\subsection{Registerbank}
Een belangrijke toepassing van een Register File Cell is een \termen{registerbank}. Een registerbank bevat verschillende register file cellen, die geordend worden in matrixstructuur. We spreken dan ook over een \termen{$m\times n$ registerbank} met $k$ \termen{schrijfpoorten} en $l$ \termen{leespoorten}. Dit betekent dat de component $m$ sequenties van $n$ bits opslaat. We kunnen hierbij data op $k$ verschillende sequenties tegelijk schrijven, en de inhoud van $l$ verschillende sequenties uitlezen. Hiervoor dienen we volgende in- en uitgangen te voorzien:
\begin{itemize}
 \item \termen{invoer-ingangen $I_{ij}$}: een set van $k\times n$ ingangen om $k$ sequenties van $n$ bits te kunnen inlezen in de registerbank.
 \item \termen{write-enable-ingangen $\mbox{WE}_i$}: $k$ verschillende signalen waarmee we aangeven of de invoer op $I_{ij}$ ingangen moet worden ingelezen.
 \item \termen{write-address-ingangen $\mbox{WA}_{ia}$}: $k$ groepen van $\lceil\log_2m\rceil$ bits waarmee we aangeven op welk adres we de $n$ bits die op $I_{ij}$ staan zullen wegschrijven.
 \item \termen{uitvoer-uitgangen $O_{ij}$}: een reeks van $l\times n$ signalen die we gebruiken om data in de registerbank uit te lezen.
 \item \termen{read-enable-ingangen $\mbox{RE}_i$}: $l$ signalen die bepalen of we op de uitgangen $O_{ij}$ iets zullen uitlezen. Analoog aan de write-enable-ingangen.
 \item \termen{read-address-ingangen $\mbox{RA}_{ia}$}: $l$ groepen van $\left\lceil\log_2m\right\rceil$ bits bepalen welke sequentie -- binair voorgesteld op de adres-ingangen -- wordt uitgelezen. Dit is analoog aan de write-address-ingangen.
\end{itemize}
Een registerbank omvat twee scenarios: het inlezen van data en het uitlezen van data. Indien we een hoog signaal aanleggen op $\mbox{WE}_i$, zullen we de data die op de ingangen $I_{ij}$ staan wegschrijven naar het adres dat binair ge\"encodeerd is met de write-access ingangen $\mbox{WA}_{ia}$ voor $j=0\ldots n-1$ en $a=0\ldots\left\lceil\log_2m\right\rceil-1$. Dit doen we op de klokflank. Indien we een laag signaal aan de write-enable ingang plaatsen, wordt de inhoud die op de bijbehorende invoer-ingangen staat genegeerd. Bij het uitlezen van data is het signaal van de read-enable-ingang van belang. Indien we een hoog signaal aanleggen op $\mbox{RE}_i$ zullen de uitvoer-uitgangen $O_{ij}$ de waardes van de data opgeslagen in een adres, binair gevormd door de read-address-ingangen $\mbox{WA}_{ia}$, aannemen voor $j=0\ldots n-1$ en $a=0\ldots\left\lceil\log_2m\right\rceil-1$. Indien we een laag signaal aanleggen, zijn deze uitvoer-uitgangen hoog impedant. Uitlezen van data gebeurt ongeklokt: indien we
bijvoorbeeld de read-adress signalen aanpassen, zullen de uitvoer-uitgangen zich aanpassen ongeacht de toestand van de kok op dat moment. Tot slot beschouwen we vaak een speciaal geval van een registerbank: de \termen{dual port registerbank} is een registerbank met \'e\'en lees- en \'e\'en schrijfpoort. Bijgevolg is in dat geval $k=l=1$.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\dy{-2.2 cm};
\def\dx{2.2 cm};
\def\ra{0.0725};
\def\rb{0.03625};
\foreach \a in {0,1} {
  \node[decoder2to4,rotate=90] (DW\a) at (-1.25*\dx,0.5*\dy+2*\a*\dy) {decoder};
%  \node[sigo] (SgW\a) at (-1.5*\dx,0 |- DW\a) {};
  \draw (DW\a.a0) -- ++(-0.5*\dx,0) node[anchor=east]{$\mbox{WA}_{\a0}$};
  \draw (DW\a.a1) -- ++(-0.5*\dx,0) node[anchor=east]{$\mbox{WA}_{\a1}$};
  \draw (DW\a.enable) |- ++(-0.5*\dx,\ra*\dy) node[anchor=east]{$\mbox{WE}_{\a}$};
}
\foreach \a in {0,1,2} {
  \node[decoder2to4,rotate=-90] (DR\a) at (3.5*\dx,0.5*\dy+\dy*\a) {decoder};
  \draw (DR\a.a0) -- ++(0.5*\dx,0) node[anchor=west]{$\mbox{RA}_{\a0}$};
  \draw (DR\a.a1) -- ++(0.5*\dx,0) node[anchor=west]{$\mbox{RA}_{\a1}$};
  \draw (DR\a.enable) |- ++(0.5*\dx,-\ra*\dy) node[anchor=west]{$\mbox{RE}_{\a}$};
}
\foreach \y in {0,...,3} {
  \foreach \x in {0,1,2} {
    \node[rfcbc] (RFC\y\x) at (\dx*\x,\dy*\y) {RFC};
  }
}
\foreach \x in {0,...,3} {
  \coordinate (MI\x0) at (DW0.s\x -| -0.5*\dx-4*\ra*\dx-\ra*\dx*\x,0);
  \coordinate (MI\x1) at (DW1.s\x -| -0.5*\dx-3*\ra*\dx+\ra*\dx*\x,0);
  \foreach \y in {0,1} {
    \draw (DW\y.s\x) -- (MI\x\y);
  }
  \foreach \y in {0,1,2} {
    \coordinate (MO\x\y) at (DR\y.s\x -| 2.5*\dx+\rb*\dx+4*\ra*\dx*\y+\ra*\dx*\x,0);
    \draw (DR\y.s\x) -- (MO\x\y);
  }
}
\foreach \y in {0,...,3} {
  \foreach \x/\p in {0/a,1/b,2/c} {
    \coordinate (RLH\y\x) at (0,\dy*\y+0.5*\dy-\rb*\dy-\ra*\dy*\x -| RFC\y2.re\p);
    \draw (RLH\y\x) -- (RLH\y\x -| RFC\y0.re\p);
    \foreach \z in {0,1,2} {
      \draw (RFC\y\z.re\p) -- (RLH\y\x -| RFC\y\z.re\p);
    }
    \foreach \z in {1,2} {
      \pdot{RLH\y\x -| RFC\y\z.re\p};
    }
  }
  \foreach \x/\p in {0/a,1/b} {
      \coordinate (WLH\y\x) at (0,\dy*\y-0.5*\dy+\rb*\dy+\ra*\dy+\ra*\dy*\x -| RFC\y0.we\p);
      \draw (WLH\y\x) -- (WLH\y\x -| RFC\y2.we\p);
      \foreach \z in {0,1,2} {
	\draw (RFC\y\z.we\p) -- (WLH\y\x -| RFC\y\z.we\p);
      }
      \foreach \z in {0,1} {
	\pdot{WLH\y\x -| RFC\y\z.we\p};
      }
    }
}
\foreach \x in {0,1,2} {
  \foreach \y/\p/\an in {0/a/west,1/b/north,2/c/east} {
    \coordinate (RLV\x\y) at (\dx*\x+0.5*\dx-\rb*\dx-\ra*\dx*\y,0 |- RFC0\x.dout\p);
    \draw (RLV\x\y) -- (RLV\x\y |- 0,3.75*\dy) node[anchor=\an,scale=0.95]{$O_{\y\x}$};

    \foreach \z in {0,1,2,3} {
      \draw (RLV\x\y |- RFC\z\x.dout\p) -- (RFC\z\x.dout\p);
    }
    \foreach \z in {1,2,3} {
      \pdot{RLV\x\y |- RFC\z\x.dout\p};
    }
  }
  \foreach \y/\p/\an in {0/a/east,1/b/west} {
    \coordinate (WLV\x\y) at (\dx*\x-0.5*\dx+\rb*\dx+\ra*\dx+\ra*\dx*\y,0 |- RFC3\x.din\p);
    \draw (WLV\x\y) -- (WLV\x\y |- 0,-0.75*\dy) node[anchor=\an,scale=0.95]{$I_{\y\x}$};
    \foreach \z in {0,1,2,3} {
      \draw (WLV\x\y |- RFC\z\x.din\p) -- (RFC\z\x.din\p);
    }
    \foreach \z in {0,1,2} {
      \pdot{WLV\x\y |- RFC\z\x.din\p};
    }
  }
}
\foreach \y in {0,...,3} {
  \foreach \x in {0,1} {
    \draw (MI\y\x) |- (WLH\y\x);
  }
}
\foreach \y in {0,...,3} {
  \foreach \x in {0,1,2} {
    \draw (MO\y\x) |- (RLH\y\x);
  }
}
\node[fit=(DR0) (DR1) (DR2) (DW0) (DW1) (RFC00) (RFC32),inner sep=0.625cm,draw=black,rectangle,dashed] {};
\end{tikzpicture}
\caption{Implementatie van een $4\times 3$ registerbank met $2$ schrijf- en $3$ leespoorten.??}
\figlab{registerbank}
\end{figure}
\paragraph{}
Op figuur \ref{fig:registerbank} beschouwen we een $4\times 3$ registerbank met $2$ schrijf- en $3$ leespoorten. Bij de constructie van een registerbank met $k$ schrijf- en $l$ leespoorten, gebruiken we logischerwijs file register cellen met $k$ schrijf- en $l$ leespoorten. We zullen hier het kloksignaal negeren vermits de klokingang van de registerbank het kloksignaal enkel verder propageert naar de klokingangen van alle register file cellen. We construeren vervolgens $k+l$ $m$-bit decoders te introduceren. Bij elk van de decoders verbinden we een read-enable $\mbox{RE}_i$ of write-enable $\mbox{WE}_i$ met de enable-ingang van de decoder. De read-address $\mbox{RA}_{ij}$ en write-address $\mbox{WA}_{ij}$ ingangen leggen vervolgens signalen aan op de adres-ingangen van de bijbehorende decoders.??
\paragraph{}
Verder zullen we ook een nieuwe notatie invoeren die we vanaf hier frequent zullen gebruiken: vaak zullen een groot aantal signalen parallel verschillende bits van de ene component naar de andere overbrengen. Vermits door de ori\"entatie van de de component meestal duidelijk is om welke signalen het gaat, zullen we niet elk signaal individueel tekenen. In dat geval stellen we de groep signalen voor met een brede lijn, en schrijven naast een dwarse streep het aantal signalen op die deze lijn voorstelt.
\subsection{Random Access Memory (RAM)}
Een variant van een registerbank is ``\termen{Random Access Memory (RAM)}''. De term ``\termen{Random Access}'' slaat op het feit dat we het geheugen niet sequentieel moeten uitlezen. We kunnen dus een adres meegeven dat bepaalt welke cellen we uitlezen. Verder wijkt een RAM ook af van ``Read-Only Memory (ROM)'' omdat we data naar het geheugen kunnen schrijven. Bij ROM branden we de data via een ingewikkelde procedure op de chip, waarna we enkel data kunnen uitlezen. Beide eigenschappen zijn ook eigen aan een registerbank. Indien we echter naar de implementatie van een registerbank kijken, is deze niet goedkoop. RAM geheugens bieden een gelijkaardige functionaliteit met minder hardware. Hiervoor bestaan er twee soorten implementaties:
\begin{itemize}
 \item \termen{Statisch RAM}: hier realiseren we een bit geheugen met een flipflop (wat dus neerkomt op 4 tot 6 transistoren per bit).
 \item \termen{Dynamisch RAM}: een implementatie met behulp van een condensator. Indien er stroom op de condensator staat bevat de cel een 1, in het ander geval een 0. Dynamisch RAM heeft de eigenschap dat door de data van een bit op te vragen, we de stroom uit de condensator halen, en deze dus opnieuw moeten opladen. Daarnaast kent een condensator ook lekstroom, waardoor we aan een zekere frequentie de cellen die een 1 voorstellen terug moeten opladen.
\end{itemize}
Vermits we minder hardware per bit nodig hebben, zal RAM bepaalde functionaliteit van een registerbank niet aanbieden. Allereerst werkt RAM geheugen trager. Dit kan alleen al verklaard worden door een grotere adres-decoder - RAM geheugens zijn immers groter - en het is dus niet geschikt voor het opslaan van tussenresultaten in processoren. Daarnaast heeft RAM-geheugen een \termen{gecombineerde lees-schrijfpoort $R/W^*$}. Om aan te geven dat we iets willen schrijven of uitlezen bevat RAM-geheugen daarnaast ook een \termen{Chip Select-ingang $CS$}. Deze ingang functioneert ook als een vorm van klok-ingang. RAM geheugen is bijgevolg niet geklokt\footnote{Of tenminste niet op de globale klok van de schakeling.}.
\paragraph{}
RAM-geheugens hebben complex tijdsgedrag. Daarom zullen we twee scenario's bespreken: het uitlezen en wegschrijven van data bespreken samen met de verschillende vormen van vertraging. Verder zullen we ook enkele typische grenzen van vertragingstijden voor vergelijkbare RAM-geheugen geven in tabel \ref{tbl:rAMDelaySamples}.
\paragraph{Uitlezen van data}Hiervoor dienen we het adres op de adres-ingang aan te leggen en een hoog signaal op de Chip Select-ingang $\mbox{CS}$ en de lees-schrijfpoort $\mbox{R/W}^*$. Op het moment dat we dit doen, zal de data-uitgang\footnote{Meestal heeft RAM-geheugen geen enkele data-uitgang maar een reeks uitgangen waardoor we bijvoorbeeld 8 bit tegelijk kunnen uitlezen.} $\mbox{D}_{\mbox{\small{out}}}$ hoog impedant zijn. Na enige tijd zal er op deze uitgang een ongeldig signaal komen te staan dit wordt meestal veroorzaakt door de interne logica van de component. Vervolgens komt de werkelijke data op de data-uitgangen te staan. Kenmerkend zijn hier de \termen{toegangstijd $t_{\mbox{\small{AA}}}$} en de \termen{$\mbox{CS}$ toegangstijd $t_{\mbox{\small{ACS}}}$}. Het zijn de maximale tijdsverschillen tussen het aanleggen van het signaal en het verschijnen van de geldige data op de data-uitgangen. Stel dat de lees-schrijfpoort en de chip-select ingang al hoog aangestuurd worden, en we zetten een adres
op de adres-ingang zal het hoogstens de tijd gespecificeerd door de toegangstijd duren alvorens er geldige data op data-uitgang komt te staan. Omgekeerd kan er ook een geldig adres op de adres-ingang staan en dienen we nog een hoog signaal op de $\mbox{CS}$- en $\mbox{R/W}^*$ aan te leggen. In dat geval duurt het hoogstens de $\mbox{CS}$ toegangstijd alvorens geldige data op de data-uitgang verschijnt. Eenmaal er geldige data op de data-uitgang verschijnt kunnen we deze uitlezen en ergens in de schakeling gebruiken. Om nieuwe data uit te lezen of weg te schrijven zullen we ofwel het adres moeten veranderen, ofwel een laag signaal op de $\mbox{CS}$- of $\mbox{R/W}^*$-ingang aanleggen. Er treed enige vertraging op alvorens het signaal van de data-uitgang dan terugvalt op de hoog impedante toestand. Deze vertraging noemen we de \termen{\mbox{CE} Off to Output High Impedance State $t_{\mbox{\small{HZ}}}$}. Een laatste tijdseenheid is de \termen{leescyclustijd $t_{\mbox{\small{RC}}}$}. Deze vertraging bepaalt
de minimale duur van het volledige leesproces. Het specificeert de minimale tijd die tussen twee leesopdrachten ligt. Vaak is deze bij DRAM langer dan de som van alle vertragingen die we hierboven beschouwd hebben. Dit komt omdat we na het uitlezen van de data, de condensatoren terug moeten opladen. Een schematische voorstelling van deze tijden staat op figuur \ref{fig:timeRAMRead}.
\begin{figure}[hbt]
\centering
\subfigure[Uitlezen]{
\begin{tikzpicture}
\begin{wave}[0.5]{3}{5.71428}
 \nextwave{Adres} \knownS{}{0.6857} \known{Adres}{4} \knownE{}{1.02857}
 \nextwave[0.5]{$\mbox{CS}\cdot \mbox{R/W}^*$} \bitS{0}{0.6857} \bit{1}{4} \bitE{0}{1.02857}
 \nextwave[1.0]{$\mbox{D}_{\mbox{\small{out}}}$} \unknownbit{2.3571428} \unknown{0.5} \known{geldig}{2.3428572} \unknownbit{0.51428}
 \waveTime{1}{1}{1}{2}{0.5}{$t_{\mbox{\small{RC}}}$}
 \waveTime{1}{1}{3}{2}{-1}{$t_{\mbox{\small{AA}}}$}
 \waveTime{2}{1}{3}{2}{-2.5}{$t_{\mbox{\small{ACS}}}$}
 \waveTime{2}{2}{3}{3}{-2.5}{$t_{\mbox{\small{HZ}}}$}
\end{wave}
\end{tikzpicture}
\figlab{timeRAMRead}}
\centering
\subfigure[Wegschrijven]{
\begin{tikzpicture}
\begin{wave}[0.5]{3}{5.71428}
 \nextwave{Adres} \knownS{}{0.6857} \known{Adres}{4} \knownE{}{1.02857}
 \nextwave[0.5]{$\mbox{CS}\cdot\left(\mbox{R/W}^*\right)'$} \bitS{0}{0.6857} \bit{1}{4} \bitE{0}{1.02857}
 \nextwave[1.0]{$\mbox{D}_{\mbox{\small{in}}}$} \knownS{-}{2.8571428} \known{geldig}{2.3428572} \knownE{-}{0.51428}
 \waveTime{1}{1}{1}{2}{0.5}{$t_{\mbox{\small{WC}}}$}
 \waveTime{2}{2}{3}{1}{-2.5}{$t_{\mbox{\small{DW}}}$}
 \waveTime{2}{2}{3}{2}{-2.5}{$t_{\mbox{\small{DH}}}$}
\end{wave}
\end{tikzpicture}
\figlab{timeRAMWrite}}
\caption{Tijdsgedrag van RAM-geheugens.}
\end{figure}
\paragraph{Wegschrijven van data}
Een gelijkaardig scenario treedt op bij het wegschrijven van data, alleen beschouwen we hier de data-ingang\footnote{Vermits er bij het inlezen op data-uitgang een hoog-impedant signaal wordt aangelegd, combineren sommige RAM-geheugens de data-ingang en de data-uitgang. In dat geval kunnen de signalen dus in beide richtingen stromen. We gaan hier niet verder op in.} $\mbox{D}_{\mbox{\small{in}}}$. Opnieuw dienen we eerst het adres aan te leggen op de adres ingang. Verder zetten we een 0 op de lees-schrijfpoort om aan te geven dat we een schrijf-operatie uitvoeren, en zetten we een 1 op de Chip Select-ingang om aan te geven dat we een operatie zullen uitvoeren. Vervolgens kunnen we data op de data-ingang aanleggen. Wanneer we de correcte data wegschrijven is in principe irrelevant. Vanaf het moment dat we de operatie starten, zal het geheugencomponenten beginnen met data weg te schrijven. Als we data aan de data-ingang veranderen zal met enige vertraging de nieuwe data weggeschreven worden. We dienen alleen de
tijdkarakteristieken van geheugencomponenten in het algemeen in de gaten te houden: de \termen{set-up-tijd $t_{\mbox{\small{DW}}}$} en de \termen{data houdtijd $t_{\mbox{\small{DH}}}$}. Kort voor het afronden van de operatie dient immers de data niet meer te veranderen aan de ingang van de data-ingang. Dit is de set-up tijd. Anderzijds dient de data bovendien nog een zekere periode na het afronden van de operatie te blijven staan: de houdtijd. Tot slot spreken we ook over een \termen{schrijf cyclustijd $t_{\mbox{\small{WC}}}$}. Dit is de minimale tijd dat het adres op de adres-ingang moet blijven staan en de chip select-ingang en lees-schrijfpoort dezelfde configuratie blijven behouden. Een schematische voorstelling van een schrijfoperatie staat op figuur \ref{fig:timeRAMWrite}. Typische vertragingen voor een $4\mbox{k}\times1$-RAM\footnote{Dit betekent dat het geheugencomponent 4096 adressen bevat en elk adres 1 bit bijhoudt.} geheugen voor SRAM en DRAM staan in tabel \ref{tbl:rAMDelaySamples}.
\begin{table}[hbt]
\centering
\begin{tabular}{cl|rr|rr}
\multirow{2}{*}{$\Delta t$}&\multirow{2}{*}{Vertraging}&\multicolumn{2}{c|}{2147H SRAM}&\multicolumn{2}{c}{MM5280 DRAM}\\
&&min&max&min&max\\
\hline
$t_{RC}$&cyclustijd lezen&35 ns&&400 ns&\\
$t_{AA}$&toegangstijd&&35 ns&&200 ns\\
$t_{ACS}$&$CS$ toegangstijd&&35 ns&&180 ns\\
$t_{HZ}$&$CS'\rightarrow Z$&0 ns&30 ns&0 ns&\\\hline
$t_{WC}$&cyclustijd schrijven&35 ns&&0 ns&\\
$t_{DW}$&data set-up-tijd&20 ns&&150 ns&\\
$t_{DH}$&data houdtijd&0 ns&&0 ns&\\
\end{tabular}
\caption{Typische vertragingstijden voor RAM-geheugens.}
\label{tbl:rAMDelaySamples}
\end{table}
\subsection{Geheugens met Impliciete Adressering}
RAM geheugens vereisen dat we een absoluut adres meegeven. In heel wat programmeertalen hebben we echter datastructuren beschikbaar die zonder expliciete adressen werken. We spreken dan over een \termen{stapelgeheugen} ofwel \termen{stack} en een \termen{buffergeheugen} ofwel \termen{queue}. Omdat deze datastructuren bijzonder nuttig zijn in sommige algoritmen, werden hiervoor ook hardware-equivalenten ontwikkeld. We zullen in de volgende subsubsecties eerst deze datastructuren bespreken en vervolgens een hardwarecomponent bouwen die deze structuren implementeert. Studenten met een uitgebreide kennis over deze datastructuren kunnen de definitie overslaan.
\subsubsection{Stack (LIFO: Last-In-First-Out)}\ssclab{stack}
\paragraph{Definitie}Een stack ofwel stapelgeheugen is een datastructuur die een lineare lijst voorstelt. Alle methodes van de stapel kunnen enkel bewerkingen uitvoeren op \'e\'en uiteinde van deze lijst: de \termen{top}. De lijst van aangeboden functionaliteiten verschilt nogal. Toch dient een stapel minstens volgende functionaliteiten aan te bieden:
\begin{itemize}
 \item \termen{push}: het toevoegen van een element aan de stapel. Dit element wordt dan de nieuwe top.
 \item \termen{pop}: het weghalen van het element die zich bij de top bevindt. Het element net onder de top wordt dan de nieuwe top.
 \item \termen{reset}: ook wel clear genoemd. Een operatie die de volledige stapel verwijdert. We kunnen dit opvatten als het herhalen van een pop-operatie totdat de stapel leeg is, in de meeste gevallen kunnen we deze operatie echter sneller uitvoeren.
 \item \termen{leeg/empty}: controleren of een stapel leeg is en dus geen enkel element bevat. Indien dit het geval is, kan men geen pop-operaties meer uitvoeren.
 \item \termen{vol/full}: controleren of het volledige geheugen van de stapel gebruikt wordt. Indien dit het geval is, kan men geen push-operaties meer uitvoeren. Deze functionaliteit wordt meestal niet in software-implementaties van stapels aangeboden vermits men het geheugen dynamisch kan uitbreiden tot het volledige RAM geheugen in gebruik genomen is. Een fenomeen dat men doorgaans niet beschouwt in software.
\end{itemize}
In hardware is een element een hoeveelheid data met een vast aantal bits. Men spreekt over het ``\termen{Last-In-First-Out (LIFO)}''-principe omdat de elementen die het laatst aan een stapel toegevoegd worden (door middel van een push-operatie), de eerste elementen zijn die terug uit de stapel gehaald worden (door middel van een pop-operatie).
\paragraph{Conceptueel voorbeeld}
\begin{figure}[hbt]
\centering
\subfigure[Push 6]{
\begin{stackConcept}{}\scpush{6}\end{stackConcept}
}
\subfigure[Push 2]{
\begin{stackConcept}{6}\scpush{2}\end{stackConcept}
}
\subfigure[Pop]{
\begin{stackConcept}{6,2}\scpop{}\end{stackConcept}
}
\subfigure[Push 1]{
\begin{stackConcept}{6}\scpush{1}\end{stackConcept}
}
\subfigure[Pop]{
\begin{stackConcept}{6,1}\scpop{}\end{stackConcept}
}
\subfigure[Pop]{
\begin{stackConcept}{6}\scpop{}\end{stackConcept}
}
\caption{Conceptueel voorbeeld van een stapelgeheugen.}
\figlab{stackConceptExample}
\end{figure}
We introduceren ook een conceptueel voorbeeld van een stapelgeheugen dat staat op figuur \ref{fig:stackConceptExample}. Initieel is de stapel leeg en bevat deze dus geen elementen. Vervolgens voeren we een push-operatie uit met als argument 6. Het gevolg is een stapel met als enig element 6. Daarna voeren we een push operatie uit met 2. We voegen dus 2 toe aan de top van de stapel. Hierna voeren we een pop-operatie uit. Vermits het laatste toegevoegde element -- dat nog niet van de stapel is gehaald -- 2 is, zullen we 2 terugkrijgen. Bij de push-operatie van 1 voegen we 1 toe aan de stapel. De stapel heeft dan als top 1 en subtop 6. Tot slot voeren we twee pop-operaties uit. Omdat 1 het laatste toegevoegde element is, is dit het resultaat van de eerste pop-operatie. Tot slot zullen we ook 6 van de stapel halen.
\paragraph{Implementatie met een schuifregister}
We kunnen een stapel implementeren met behulp van een schuifregister. Voorwaarde is wel dat het geheugen dan niet bijzonder groot kan worden. Bij een push operatie zullen we in dat geval de bits van het element inschuiven en dit aantal bits naar links opschuiven. Bij een pop-operatie schuiven we dit aantal bits terug naar rechts, en stellen de meest rechtse bits dit element voor. Deze implementatie is vrij kostelijk: in \ref{s:schuifregisters} hebben we reeds registers ge\"implementeerd. Per bit geheugen hebben we een flipflop en enkele multiplexers nodig. Bij grote stapelgeheugens is deze kost onacceptabel. Daarom zullen we bij grote stapels meestal gebruik maken van RAM-geheugens.
\begin{figure}[hbt]
\centering
\subfigure[Push 6]{
\stackImpl{3}{3}{0}{}
}
\subfigure[Push 2]{
\stackImpl{3}{0}{1}{6}
}
\subfigure[Pop]{
\stackImpl{3}{1}{2}{6,2}
}
\subfigure[Push 1]{
\stackImpl{3}{0}{1}{6}
}
\subfigure[Pop]{
\stackImpl{3}{1}{2}{6,1}
}
\subfigure[Pop]{
\stackImpl{3}{0}{1}{6}
}
\caption{Demonstratie van een stapelgeheugen met tellers.}
\figlab{stackConceptExample}
\end{figure}
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[circuit logic US]
\def\ec{-5};
\def\epp{-5.25};
\def\er{-5.625};
\def\efe{-1};
\node[counterdbitrev] (CW) at (-3,1.5) {$\begin{array}{c}n+1\mbox{-bit}\\\mbox{schrijfteller}\end{array}$};
\node[mux2to1,rotate=90,scale=1.5,anchor=data0,thick] (M) at ($(CW.Q2)+(2.75,-0.25)$) {};
\draw[thick] (CW.Q2) -- (CW.Q2 |- M.data0);
\node[counterdbitrev] (CR) at (-3,-1.75) {$\begin{array}{c}n\mbox{-bit}\\\mbox{leesteller}\end{array}$};
\node (CRV) at (CR.D2 |- 0,-0.25) {$2^n-1$};\draw[thick] (CRV) -- (CR.D2);
\draw[thick] (CR.Q2) |- ++(2.5,-0.25);
\draw[decoration={sigo,lines={$n$}},decorate,thick] ($(CR.Q2)+(2.5,-0.25)$)  |- (M.data1);
\node[ramm,anchor=A] (R) at ($(M.output)+(0.75,0)$) {$\begin{array}{c}2^n\times w\mbox{-bit}\\\mbox{RAM}\end{array}$};
\draw[decoration={sigo,lines={$n$}},decorate,thick] (M.output) -- (R.A);
\node[not gate,scale=0.75,rotate=90] (N1) at ($(R.RW)+(-0.25,-1)$) {};%($(CR.Q2)+(0,-0.875)$)
\node[not gate,scale=0.75,rotate=-90] (N2) at (\er,0) {};
\node[nor gate,inputs={normal,normal,normal}] (NO) at ($(R.north)+(0,1)$) {};
\coordinate (FEO) at (\efe,0 |- NO.input 2);
\coordinate (FEOM) at (FEO |- M.data0);
\coordinate (CRD) at ($(CR.Q2)+(0,-0.75)$);
\coordinate (MRW) at (M.selin0 |- CRD);
\pdot{MRW};
\draw (M.selin0) -- (MRW);
\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (CW.Q2 |- M.data0) -- (FEOM);
\draw[decoration={sigo,lines={$n$}},decorate,thick] (FEOM) -- (M.data0);
\pdot{FEO};\pdot{FEOM};
\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FEOM) -- (FEO);
\draw[decoration={sigo,lines={$n$}},decorate,thick] (FEO) -- (NO.input 2);
\node[anchor=east,scale=0.9] (IR) at (-7,0 |- CW.CLR) {Reset$^*$};\draw (IR) -- (CW.CLR);\draw (IR -| \er,0) -- (N2.input);\draw(N2.output) |- (CR.LD);\pdot{IR -| \er,0};
\node[anchor=east,scale=0.9] (IE) at (-7,0 |- CR.CEIN) {Enable};\draw (IE) -- (CR.CEIN);\draw (IE -| \ec,0) |- (CW.CEIN);\draw (IE -| \ec,0) |- ($(CR.Q2)+(2.5,-0.5)$) -| ($(R.CS)+(-0.625,0)$) -- (R.CS);\pdot{IE -| \ec,0};
\node[anchor=east,scale=0.9] (IPP) at (-7,0 |- CR.DU) {Push/Pop$^*$};\draw (IPP) -- (CR.DU);\draw (IPP -| \epp,0) |- (CW.DU);\draw (IPP -| \epp,0) |- ($(CR.Q2)+(2.5,-0.75)$) -| (N1.input); \draw (N1.output) -| ($(R.RW)+(-0.25,0)$) -- (R.RW);\pdot{IPP -| \epp,0};
\node[anchor=west,scale=0.9] (OF) at (5,0 |- CW.north east) {Full};\draw[decoration={sigo,lines={$1$ MSB}},decorate] (FEO) |- (OF);
\node[anchor=west,scale=0.9] (OE) at (5,0 |- NO.output) {Empty};\draw (NO.output) -- (OE);
\node[anchor=west,scale=0.9] (OD) at (R.D -| 5,0) {Data In/Out};\draw[decoration={sigo,lines={$w$}},decorate,thick] (R.D) -- (OD);
\node[fit=(R) (M) (CW) (CR) (N1) (N2) (NO) (MRW),inner sep=0.625cm,draw=black,rectangle,dashed] {};
\end{tikzpicture}
\caption{Implementatie van een stapelgeheugen met behulp van RAM-geheugen.}
\figlab{stackImplRAM}
\end{figure}
\paragraph{Implementatie met RAM-geheugens}
Een goedkopere manier is gebruik maken van RAM-geheugens. Hierbij is de kost beperkt tot een 4 \`a 6 transistoren per bit. We realiseren dan een stapelgeheugen met behulp van een RAM-geheugen -- die tevens ook de grootte van het stapelgeheugen bepaalt -- en twee tellers: het \termen{leesadres} en het \termen{schrijfadres}. Indien het RAM-geheugen $2^n$ adressen kent, beschouwen we een $n$-bit leesteller en $n+1$-bit schrijftellers\footnote{Op die manier kunnen ze elk adres voorstellen. We voegen aan de schrijfteller een extra bit toe voor overflow.}. De schrijfteller staat initieel op $0$, de leesteller staat initeel op $2^n-1$. Wanneer we een push operatie uitvoeren schrijven we de data weg naar het adres voorgesteld door de schrijfteller, en verhogen we beide tellers. Bij een pop-operatie lezen we de data uit het RAM-geheugen op het adres voorgesteld door de leesteller. Vervolgens verlagen we beide tellers. Merk op dat we bij een push- en pop-operatie dus niet alle data in het RAM-geheugen moeten opschuiven.
We verhogen en verlagen enkel de tellers. Indien we het volledige geheugen volgeschreven hebben, zal de schrijfteller op $2^n$ komen te staan\footnote{Vermits de schrijfteller een $n+1$-bit teller is.}. Dit betekent dus dat de $n+1$-de bit van die teller een hoog signaal bevat. We kunnen dit hoog signaal naar buiten brengen als een full-signaal. Op figuur \ref{fig:stackImplRAM} implementeren we dit stapelgeheugen. Indien het reset-signaal actief wordt, wordt de schrijfteller gereset en komt deze op 0 te staan, de leesteller voert een load-operatie uit en laadt de waarde $2^n-1$ in. Bij een push-operatie wordt het push/pop$^*$ signaal hoog, hierdoor wordt het increment-signaal bij beide tellers geactiveerd en worden deze opgehoogd in de volgende klokflank. De multiplexer zal intussen de huidige waarde van de schrijfteller doorsturen naar het RAM-geheugen, die de waarde die op de data-ingangen staat zal inlezen en wegschrijven. Bij een pop-operatie ontvangen beide tellers een decrement-signaal, de multiplexer
stuurt het leesadres door naar het RAM-geheugen die de waarde die op dit adres staat op de data-uitgang zal zetten. Ons component bevat daarnaast nog een enable-ingang: indien deze op 0 staat, worden de tellers en het RAM-geheugen niet aangepast en gebeurt er dus niets. De full-uitgang brengt zoals eerder vermeld de hoogste bit van de schrijfteller naar buiten, en is hoog indien alle geheugenplaatsen opgebruikt zijn. Daarnaast bevat ons component ook een empty-uitgang. Deze voert een NOR-operatie uit op alle bits van de schrijfteller. Indien alle bits 0 zijn (en de teller dus op 0 staat) is de stapel leeg, en geeft empty dus een laag signaal. Tot slot kunnen we opmerken dat we voor de implementatie strikt genomen geen twee tellers nodig hebben. Vermits de leesteller telkens gelijk is aan de gedecrementeerde waarde schrijfteller (en modulo $2^n$), zouden we ook een combinatorische moduler kunnen voorzien die de waarde van de leesteller uit de schrijfteller afleidt. In dit geval zal de vertraging van de pop-
operaties wel groter worden.
\subsubsection{Queue (FIFO: First-In-First-Out)}
\paragraph{Definitie}Een queue of buffergeheugen is een datastructuur die een lineare lijst voorstelt. Deze lijst heeft twee uiteindes. Aan het ene uiteinde voegen we elementen toe bij een schrijfoperatie, aan het andere uiteinde zullen we bij een leesoperatie elementen weghalen. Zoals de naam al doet vermoeden heeft een queue hoofdzakelijk de taak om data te bufferen in de tijd\footnote{Men dient een buffergeheugen niet te verwarren met een buffer-component. Een buffercomponent staat in voor het gelijkmatig verdelen van de spanning over verschillende uitgangen (en buffert dus het elektrisch potentiaal).}. Dit kan bijvoorbeeld nuttig zijn indien we een component soms aan hoge snelheid invoer data krijgt (zogenaamde bursts) en men deze data niet aan dezelfde snelheid kan verwerken. Een queue dient minstens volgende functionaliteiten aan te bieden:
\begin{itemize}
 \item \termen{Write} (ofwel enqueue): het inlezen van data en dit aan \'e\'en uiteinde van het buffergeheugen plaatsen.
 \item \termen{Read} (ofwel dequeue): het uitlezen van data aan het andere uiteinde van het buffergeheugen.
 \item \termen{Reset}: het buffergeheugen in de initi\"ele toestand plaatsen (waarbij het dus geen elementen bevat). Dit kan opgevat worden als het herhalen van read operaties tot alle elementen uit de queue verdwenen zijn.
 \item \termen{Full}: een indicator of alle beschikbare geheugenlocaties bezet zijn.
 \item \termen{Empty}: een indicator dat het buffergeheugen leeg is.
\end{itemize}
In hardware is een element een hoeveelheid data met een vast aantal bits. Men spreekt over het ``\termen{First-In-First-Out (LIFO)}''-principe omdat de elementen die het eerst aan een queue toegevoegd worden (door middel van een write-operatie), de eerste elementen zijn die terug uit de queue gehaald worden (door middel van een read-operatie).
\begin{figure}[hbt]
\centering
\subfigure[Write 6]{
\begin{queueConcept}{4}{}\qupush{6}\end{queueConcept}
}
\subfigure[Write 2]{
\begin{queueConcept}{4}{6}\qupush{2}\end{queueConcept}
}
\subfigure[Read]{
\begin{queueConcept}{4}{6,2}\qupop{}\end{queueConcept}
}
\subfigure[Write 1]{
\begin{queueConcept}{4}{2}\qupush{1}\end{queueConcept}
}
\subfigure[Read]{
\begin{queueConcept}{4}{2,1}\qupop{}\end{queueConcept}
}
\subfigure[Read]{
\begin{queueConcept}{4}{1}\qupop{}\end{queueConcept}
}
\caption{Conceptueel voorbeeld van een buffergeheugen.}
\figlab{queueConceptExample}
\end{figure}
\paragraph{Conceptueel voorbeeld}
Analoog aan het stapelgeheugen introduceren we een conceptueel voorbeeld voor een buffergeheugen op figuur \ref{fig:queueConceptExample}. We voeren dezelfde operaties uit als bij het stapelgeheugen (push is write en pop is read). Toch zien we dat de elementen op een andere manier uit de datastructuur verdwijnen. Aanvankelijk is de queue leeg. Vervolgens plaatsen we met write operaties een 6 en een 2 in de queue. Bij de read operatie zullen we in tegenstelling tot bij een stapel, de 6 uit het geheugen halen.
\begin{figure}[hbt]
\centering
\subfigure[Push 6]{
\queueImpl{2}{0}{0}{}
}
\subfigure[Push 2]{
\queueImpl{2}{0}{1}{6}
}
\subfigure[Pop]{
\queueImpl{2}{0}{2}{6,2}
}
\subfigure[Push 1]{
\queueImpl{2}{1}{2}{6}
}
\subfigure[Pop]{
\queueImpl{2}{1}{3}{6,1}
}
\subfigure[Pop]{
\queueImpl{2}{2}{3}{6}
}
\caption{Demonstratie van een buffergeheugen met tellers.}
\figlab{queueConceptExample}
\end{figure}
\paragraph{Implementatie met RAM-geheugens}
Analoog kunnen we ook een buffergeheugen implementeren met behulp van een RAM-geheugen en een lees- en schrijfteller. De schrijfteller houdt de positie bij van het uiteinde van de rij, waar we elementen zullen bijschrijven. De leesteller houdt de positie van het andere uiteinde bij, waar we elementen zullen uitlezen. We gebruiken het RAM-geheugen op een manier waarbij we de elementen niet dienen te verplaatsen. Dit kunnen we doen door zowel de lees als de schrijfteller aanvankelijk op 0 te zetten. Indien we een schrijf-operatie dienen uit te voeren, schrijven we het elementen op het adres gespecificeerd door de schrijfteller, en incrementeren we deze teller. Bij een lees-operatie lezen we de locatie van het geheugen uit en incrementeren we de leesteller. Indien \'e\'en van de tellers aan het einde van het geheugen komt, voeren we eenvoudigweg een wrap-around uit, en schrijven we dus opnieuw op het begin van het geheugen. Een probleem stelt zich op het moment dat de lees- en schrijftellers beide dezelfde
waarde hebben. In dat geval zijn er immers twee situaties mogelijk: ofwel zijn op dat moment alle geheugencellen bezet, ofwel is op dat moment het buffergeheugen leeg (zoals bijvoorbeeld bij de initi\"ele toestand van de tellers). We verhelpen dit probleem opnieuw door bij een $2^n\times w$-bit RAM geheugen, de tellers uit te breiden naar $n+1$-bit tellers. De hoogste bit wordt niet gebruikt om het adres voor het RAM-geheugen aan te wijzen, we beschouwen voor adressering dus enkel de laagste $n$ bits. Indien deze $n$ laagste bits van de lees- en schrijfteller aan elkaar gelijk zijn, speelt zich opnieuw het scenario van vol of leeg af. Indien daarenboven de hoogste bits aan elkaar gelijk zijn, is de queue leeg, indien ze niet gelijk zijn is het buffergeheugen vol. Het conceptueel principe van deze tellers staat op figuur \ref{fig:queueConceptExample}. Op figuur \ref{fig:queueImplRAM} implementeren we een schakeling die een buffergeheugen realiseert. Vermits de tellers in \'e\'en richting tellen, makken we
gebruik van uptellers. Indien de enable-inang hoog is, zal afhankelijk van het signaal aan de \mbox{\termen{read/write$^*$-ingang}} \'e\'en van de tellers een increment uitvoeren. Verder bepaalt deze ingang ook, welke teller de multiplexer naar het RAM-geheugen doorstuurt. De multiplexer stuurt wel enkel de laagste $n$ bits door. De enable ingang zal verder ook het RAM-geheugen activeren. Indien de reset-ingang geactiveerd is, zullen beide tellers terug de initi\"ele waarde 0 krijgen. Tot slot implementeren we de indicators zoals eerder besproken: een buffergeheugen is leeg indien alle $n+1$ bits van de twee tellers gelijk zijn. Een buffergeheugen is vol indien op de hoogste bits na de tellers gelijk zijn.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[circuit logic US]
\def\el{-6.75};
\def\ela{5.25};
\def\ec{-5.125};
\def\epp{-6.125};
\def\epq{-6.375};
\def\er{-5};
\def\efe{-1.25};
\def\eff{2.75};
\def\af{3.5};
\def\afa{3.25};
\def\afb{3};
\node[upcounterdbit,minimum width=3cm] (CW) at (-3,1.5) {$\begin{array}{c}n+1\mbox{-bit}\\\mbox{schrijfteller}\end{array}$};
\node[mux2to1,rotate=90,scale=1.5,anchor=data0,thick] (M) at ($(CW.Q2)+(3,-0.5)$) {};\setIndexLabelsMuxB[west]{M};
\draw[thick] (CW.Q2) -- (CW.Q2 |- M.data0);
\node[upcounterdbit,minimum width=3cm] (CR) at (-3,-1.75) {$\begin{array}{c}n+1\mbox{-bit}\\\mbox{leesteller}\end{array}$};
\draw[thick] (CR.Q2) |- ++(\eff,-0.25);
\draw[decoration={sigo,lines={$n$}},decorate,thick] ($(CR.Q2)+(\eff,-0.25)$)  |- (M.data1);
\node[ramm,anchor=A] (R) at ($(M.output)+(0.75,0)$) {$\begin{array}{c}2^n\times w\mbox{-bit}\\\mbox{RAM}\end{array}$};
\draw[decoration={sigo,lines={$n$}},decorate,thick] (M.output) -- (R.A);
\node[and gate,anchor=output] (AR) at (CR.CEIN -| \ec,0) {};\draw (AR.output) -- (CR.CEIN);
\node[and gate,inputs={inverted,normal},anchor=output] (AW) at (CW.CEIN -| \ec,0) {};\draw (AW.output) -- (CW.CEIN);
\node[comp,rotate=90,thick,anchor=north,xshift=-0.125cm] (CO) at (R.west |- CW.CEIN) {Comp};
\node[xor gate,anchor=south,yshift=0.25cm] (X) at (CO.east) {};
\node[and gate,anchor=input 1] (A0) at (X -| \af,0) {};\draw (A0.output) -- (A0.output -| \ela,0) node[anchor=west]{Full};
\node[and gate,inputs={inverted,normal},anchor=input 2] (A1) at (CO -| \af,0) {};\draw (A1.output) -- (A1.output -| \ela,0) node[anchor=west]{Empty};
\draw (X.output -| \afa,0) |- (A1.input 1);\pdot{X.output -| \afa,0};\draw (CO.eq -| \afb,0) |- (A0.input 2);\pdot{CO.eq -| \afb,0};
\coordinate (FEO) at (\efe,0 |- CR.CEIN);
\coordinate (FEOM) at (FEO |- M.data0);\coordinate (FEOC) at (FEO |- CO.y1);\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FEOM) -- (FEOC);\pdot{FEOC};\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FEOC) -- (CO.y1);\draw (FEOC) |- (X.input 1);
\coordinate (FFO) at ($(CR.Q2)+(\eff,-0.25)$);
\coordinate (FFOM) at (FFO |- M.data1);\coordinate (FFOC) at (FFO |- CO.x1);\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FFOM) -- (FFOC);\pdot{FFOC};\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FFOC) -- (CO.x1);\draw (FFOC) |- (X.input 2);
\coordinate (CRD) at ($(CR.Q2)+(0,-0.75)$);
\coordinate (MRW) at (M.selin0 |- CRD);
\pdot{MRW};\pdot{FFOM};
\draw (M.selin0) -- (MRW);
\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (CW.Q2 |- M.data0) -- (FEOM);
\draw[decoration={sigo,lines={$n$}},decorate,thick] (FEOM) -- (M.data0);
\pdot{FEOM};
\node[anchor=east,scale=0.9] (IR) at (\el,0 |- CW.CLR) {Reset$^*$};\draw (IR) -- (CW.CLR);\draw (IR -| \er,0) |- (CR.CLR);\pdot{IR -| \er,0};
\node[anchor=east,scale=0.9] (IE) at (\el,0 |- AR.input 2) {Enable};\draw (IE) -- (AR.input 2);\draw (IE -| \epq,0) |- (AW.input 2);\draw (IE -| \epq,0) |- ($(CR.Q2)+(2.5,-0.5)$) -| ($(R.CS)+(-0.625,0)$) -- (R.CS);\pdot{IE -| \epq,0};
\draw (X.output) -- (A0.input 1);\draw (CO.eq) -- (A1.input 2);
\node[anchor=east,scale=0.9] (IPP) at (\el,0 |- AW.input 1) {Read/Write$^*$};\draw (IPP) -- (AW.input 1);\draw (IPP -| \epp,0) |- (AR.input 1);\pdot{IPP -| \epp,0};\draw (AR.input 1 -| \epp,0) |- (MRW) -| ($(R.RW)+(-0.25,0)$) -- (R.RW);\pdot{AR.input 1 -| \epp,0};
\node[anchor=west,scale=0.9] (OD) at (R.D -| \ela,0) {Data In/Out};\draw[decoration={sigo,lines={$w$}},decorate,thick] (R.D) -- (OD);
\node[fit=(R) (M) (CW) (CR) (CW) (AR) (AW) (MRW),inner sep=0.625cm,draw=black,rectangle,dashed] {};
\end{tikzpicture}
\caption{Implementatie van een buffergeheugen met behulp van RAM-geheugen.}
\figlab{queueImplRAM}
\end{figure}
\section{Synthese van een Niet-Programmeerbare Processor}
\label{s:syntheseFSMD}
Nu we een ASM-schema gedefinieerd hebben en nieuwe geheugencomponenten ter beschikkingen hebben kunnen we eindelijk een processor implementeren. We vertrekken vanuit het ASM-schema, en zullen in subsectie \ref{ss:syntheseFSMDBasis} eerst een methode bespreken om op een mechanische manier een ASM-schema om te zetten in een processor. Deze methode leidt tot een straightforward resultaat, maar dit is verre van optimaal. In subsecties \ref{ss:syntheseFSMDController}, \ref{ss:syntheseFSMDDatapad} en \ref{ss:syntheseFSMDOptimal} zullen we dan ook optimalisaties bespreken om de processor goedkoper en effici\"enter te maken.
\subsection{Basisprincipes}
\label{ss:syntheseFSMDBasis}
\subsubsection{Principes}
We kunnen door volgende principes toe te passen op het ASM-schema een processor bouwen:
\begin{enumerate}
 \item Elke variabele is een register.
 \item Voor elk register maakt de set-ingang deel uit van het instructiewoord.
 \item Elke operatie komt overeen met een functionele eenheid (FU) die logischerwijs dezelfde opdracht uitvoert (indien er dus een optelling in het ASM-schema voorkomt, zullen we een opteller in het datapad plaatsen).
 \item Indien een operatie de waarde van een variabele nodig heeft, maken we een verbinding van de uitgang van het bijbehorende register naar de bijbehorende ingang van de functionele eenheid.
 \item Indien het resultaat van een operatie wordt weggeschreven naar een variabele, bouwen we een verbinding van de uitgang van de bijbehorende functionele eenheid naar de data-ingang van het register.
 \item Indien data-ingangen of constanten ingelezen kunnen worden bij een variabele, bouwen we een verbinding tussen de data-ingang/constante en het bijbehorende register, tenzij de constante 0 is.
 \item Indien een variabele op 0 gezet kan worden, bevat het instructiewoord de reset-ingang van het bijbehorende register.
 \item Indien verschillende functionele eenheden waardes wegschrijven naar eenzelfde register, voorzien we een multiplexer om de waarde te kiezen. De selectie-ingangen van deze multiplexers behoren tot het instructiewoord.
 \item Elk ASM-blok komt overeen met een toestand van de controller.
 \item Voor elke test waarbij een variabele betrokken is, dienen we een combinatorische module te bouwen die op basis van de waarde van de registers de test kan uitvoeren. De uitgang van deze test module is \'e\'en van het status-signalen, en bijgevolg een deel van de controller-ingangen.
 \item De reset- en load-ingangen van de registers vormen samen met de selectie-ingangen de het instructiewoord: een deel van de uitgangen van de controller.
 \item Data-uitgangen worden berekend aan de hand van een combinatorische schakeling met als invoer de waarde van de relevante registers, en eventuele instructiewoord-bits.
\end{enumerate}
\subsubsection{Leidend voorbeeld}
\paragraph{Datapad}
Op basis van het ASM-schema op figuur \ref{fig:aSMSchemaRunningExample} op pagina \pageref{fig:aSMSchemaRunningExample} kunnen we een processor bouwen. Het resultaat van van deze omzetting staat op figuur \ref{fig:sprocessorDatapathGenericLeadingExample}. In het ASM-schema is er sprake van vier variabelen: $X$, $Y$, $Z$ en $I$. Daarom introduceren we vier registers. Uit het ASM-schema kunnen we afleiden dan zowel $Y$ als $Z$ op 0 gezet kunnen worden. Daarom voorzien we op basis van de register reeds 6 instructie-bits: de set-ingangen van de $X$ en $I$-registers en de set- en reset-ingangen van de $Y$ en $Z$ registers. Voor elk van de registers voorzien we vervolgens een lijn (deze tekenen we onder de registers). We kunnen nu de functionele eenheden introduceren. Alle operaties uit het ASM-schema gebeuren in toestand $S_2$. In totaal zijn er 6 functionele eenheden: een shift voor zowel $X$ als $Y$ samen met de speciale recombinaties en decrement. We maken geen verschil of de instructies al dan niet voorwaardelijk
zijn. Elk van deze functionele eenheden plaatsen we onder de lijnen van de registers. Vervolgens tekenen we verbindingen vanuit de registers en eventuele data-ingangen naar de functionele eenheden. Zo tekenen we een signaal vanuit $I$ naar de decrementor, $X$ en $Y$ naar een shift-operator, en andere registers naar hun specifieke recombinaties. Verder tekenen we ook de testen: $I>0$ en $z_2z_1z_0x_3<D$. Ook deze testen verbinden we met de respectievelijk registers en data-ingangen. Elk van deze testen vormen een deel van het status-signaal. We duiden deze bits aan met onderlijnde grote letters. Vervolgens dienen we de uitgang van de functionele eenheden samen met data-ingangen te verbinden met de ingang van de registers. Zo zien we in het ASM-schema dat de variable $X$ vanuit twee bronnen waardes kan krijgen: vanuit de data-ingang $N$ en vanuit een schuifregister $X\shlcmd1$. Bijgevolg voorzien we een multiplexer die zowel de data-ingang $N$ als de uitgang van een schuifoperator combineert. De selectie-
ingang van deze multiplexer maakt deel uit van het instructiewoord. Bits van het instructiewoord duiden we aan met onderlijnde kleine letters\footnote{De voorstelling van bits van het toestand- en instructiewoord zijn louter arbitrair, andere notaties zijn eveneens toegelaten.}. $Y$ kan worden gezet op drie soorten waardes: de waarde 0, het resultaat van een andere schuifoperator en de waarde na de recombinatiestap. Vermits we 0 kunnen activeren door een hoog signaal op de reset-ingang van het register aan te leggen, zullen we 0 niet toevoegen aan de multiplexer, en combineert de multiplexer alleen de uitvoer van de schuifoperator met deze van recombinatie-functionele eenheid. Op een gelijkaardige manier realiseren we de rest van de multiplexers. Tot slot dienen we nog combinatorische logica voor de data-uitgangen te bouwen. In dit geval is het simpel: de notitie bij het ASM-schema stelt dat de data-uitgangen $Q$ en $R$ louter de waardes van $Y$ en $Z$ naar buiten brengen. We specificeren dus deze uitgangen
en verbinden de bussen van de registers met deze data-uitgangen. We hebben nu het volledige datapad gerealiseerd zoals op figuur \ref{fig:sprocessorDatapathGenericLeadingExample}.
\begin{figure}[hbt]
\centering
\begin{sprocessor}{x/$X$/1/2,y/$Y$/3/2,z/$Z$/3/2,i/$I$/1/2}{sa/{$\shlcmd 1$},sb/{$\shlcmd 1$},rcc/$y_2y_1y_01$,rca/$z_2z_1z_0x_3$,rcb/{$z_2z_1z_0x_3$\\$-D$},de/$-1$}{ta/{$z_2z_1z_0x_3$\\$<D$},tb/{$I>0$}}
\node[anchor=south] (VN) at ($(RRx-1)+(0,0.5)$) {$N$};
\node[anchor=south] (V3) at (RRi-1 |- VN.south) {$3$};
\spcorf{VDC}{rcb}{-0.3};
\node[anchor=south] (VD) at (VDC |- VN.south) {$D$};
\draw[thick] (RRx-1) -- (VN.south);
\draw[thick] (RRi-1) -- (V3.south);
\draw[thick] (VDC) -- (VD.south);
\draw[thick] (FURde) -| (RRi-0);
\draw[thick] (FURsa) -| (RRx-0);
\draw[thick] (FURrcb) -| (RRz-0);
\draw[thick] (FURrca) -| (RRz-1);
\draw[thick] (FURrcc) -| (RRy-0);
\draw[thick] (FURsb) -| (RRy-1);
\spcort{TAD}{ta}{0.3};
\spcort{OQB}{tb}{0.75};\coordinate (OQ) at (OQB |- 0,-4);
\spcort{ORB}{ta}{0.75};\coordinate (OR) at (ORB |- 0,-4);
\draw (OQ) node[anchor=north]{$Q$};\sprbtc{y}{OQ};
\draw (OR) node[anchor=north]{$R$};\sprbtc{z}{OR};
\draw[thick] (TAD) |- ($(VD.south)+(0,-0.3)$);
\pdot{$(VD.south)+(0,-0.3)$};
\sprbtf{i}{de}{0};
\sprbtf{z}{rcb}{0.3};
\sprbtf{x}{rcb}{0};
\sprbtf{z}{rca}{0.2};
\sprbtf{x}{rca}{-0.2};
\sprbtf{y}{rcc}{0};
\sprbtf{y}{sb}{0};
\sprbtf{x}{sa}{0};
\sprbtt{x}{ta}{-0.3};
\sprbtt{z}{ta}{0};
\sprbtt{i}{tb}{0};
\end{sprocessor}
\caption{Implementatie van het datapad van het leidend voorbeeld via de basisprincipes.}
\figlab{sprocessorDatapathGenericLeadingExample}
\end{figure}
\paragraph{Controller}
Naast het datapad moeten we ook de controller realiseren. De controller bouwen we op basis van het ASM-schema. Elke toestand van het ASM-schema komt overeen met een toestand van de controller. De invoer van de controller bestaat enerzijds uit controle-ingangen en anderzijds status-signalen. Voor het voorbeeld van de deler betekent dit dus:
\begin{enumerate}
 \item [\underline{ci}] het signaal van de controle-ingang dat aangeeft dat de data-ingangen gereed zijn voor verwerking.
 \item [\underline{A}] het resultaat van de test $z_2z_1z_0x_3<D$
 \item [\underline{B}] het resultaat van de test $I>0$
\end{enumerate}
Daarnaast dient de controller zowel een instructiewoord naar
\begin{enumerate}
 \item[\underline{co}] het signaal van de controle-uitgang dat aangeeft dat het algoritme was uitgevoerd en de resultaten op de data-uitgangen staat.
 \item[\underline{a}] indien hoog wordt de waarde van de variabele $X$ gezet op de waarde van de multiplexer.
 \item[\underline{b}] indien hoog wordt de waarde $N$ doorgegeven aan het register $X$, anders wordt $X\shlcmd1$ doorgegeven.
 \item[\underline{c}] indien hoog wordt de waarde van de variabele $Y$ gezet op de waarde van de multiplexer.
 \item[\underline{d}] indien hoog wordt de waarde van de variabele $Y$ gezet op 0.
 \item[\underline{e}] indien hoog wordt de waarde $Y\shlcmd1$ doorgegeven aan het register $Y$, anders wordt $y_2y_1y_01$ doorgegeven.
 \item[\underline{f}] indien hoog wordt de waarde van de variabele $Z$ gezet op de waarde van de multiplexer.
 \item[\underline{g}] indien hoog wordt de waarde van de variabele $Z$ gezet op 0.
 \item[\underline{h}] indien hoog wordt de waarde $z_2z_1z_0x_3$ doorgegeven aan het register $Z$, anders wordt $z_2z_1z_0x_3-D$.
 \item[\underline{i}] indien hoog wordt de waarde van de variabele $I$ gezet op de waarde van de multiplexer.
 \item[\underline{j}] indien hoog wordt de waarde $3$ doorgegeven aan het register $I$, anders wordt $I-1$ doorgegeven.
\end{enumerate}
Op basis van deze beschrijving kunnen we een toestandstabel bouwen die de volledige controller beschrijft zoals in tabel \ref{tbl:sprocessorControllerGenericLeadingExample} of figuur \ref{fig:sprocessorControllerGenericLeadingExample}.
\begin{table}[hbt]
\centering
\begin{tabular}{c|ccc|ccccccccccc|c}
\multirow{2}{*}{Toestand}&\multicolumn{3}{c|}{Ingang}&\multicolumn{11}{c|}{Uitgang}&\multirow{2}{*}{Volgende toestand}\\
&ci&A&B&co&a&b&c&d&e&f&g&h&i&j&\\\hline
\multirow{2}{*}{$S_1$}
&0&-&-&		0	&1&1	&0&1&-	&0&1&-	&1&1	&$S_1$\\
&1&-&-&		0	&1&1	&0&1&-	&0&1&-	&1&1	&$S_2$\\\hline
\multirow{4}{*}{$S_2$}
&-&0&0&		0	&1&0	&1&0&0	&1&0&0	&1&0	&$S_3$\\
&-&0&1&		0	&1&0	&1&0&0	&1&0&0	&1&0	&$S_2$\\
&-&1&0&		0	&1&0	&1&0&1	&1&0&1	&1&0	&$S_3$\\
&-&1&1&		0	&1&0	&1&0&1	&1&0&1	&1&0	&$S_2$\\\hline
\multirow{2}{*}{$S_3$}
&0&-&-&		1	&0&-	&0&0&-	&0&0&-	&0&-	&$S_1$\\
&1&-&-&		1	&0&-	&0&0&-	&0&0&-	&0&-	&$S_3$\\
\end{tabular}
\caption{Toestandstabel van de controller van het leidend voorbeeld via de basisprincipes.}
\label{tbl:sprocessorControllerGenericLeadingExample}
\end{table}
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=4cm,on grid,semithick,every state/.style={draw=black!50,very thick,fill=black!20,scale=0.75}]
\node[state] (S1) {$S_1$};
\node[state] (S2) [right=of S1] {$S_2$};
\node[state] (S3) [right=of S2] {$S_3$};
\path	(S1) edge node[swap] {\texttt{1--/01101-01-11}} (S2)
	   edge[loop below] node {\texttt{0--/01101-01-11}} (S1)
	(S2) edge node[swap] {\begin{varwidth}{5cm}\begin{center}\texttt{-00/01010010010}\\\texttt{-10/01010110110}\end{center}\end{varwidth}} (S3)
	   edge[loop below] node {\begin{varwidth}{5cm}\begin{center}\texttt{-01/01010010010}\\\texttt{-11/01010110110}\end{center}\end{varwidth}} (S2)
	(S3) edge[bend right] node {\texttt{0--/10-00-00-0-}} (S1)
	   edge[loop below] node {\texttt{1--/10-00-00-0-}} (S3);
%bend left
%0--/01101-01-11
\end{tikzpicture}
\caption{Toestandsdiagram van de controller van het leidend voorbeeld via de basisprincipes.}
\figlab{sprocessorControllerGenericLeadingExample}
\end{figure}
Deze tabel genereren we opnieuw op basis van het ASM-schema. Het instructiewoord -- een sequentie aan bits die bepaalt welke instructies op het datapad worden uitgevoerd -- is afhankelijk van zowel de toestand als de controller-ingang en statussignalen. Bij wijze van voorbeeld zullen we de controller-tabel van het leidend voorbeeld opbouwen. Bij toestand $S_1$ zijn alle opdrachten onafhankelijk van testen. Bijgevolg zal het instructiewoord ook onafhankelijk zijn van de invoer. Dit instructiewoord kunnen we bouwen aan de hand van de instructies bij toestand 1. Zo is de controller-uitgang $co=0$, logischerwijs is dit ook het geval de uitvoer. Daarnaast bevat de toestand de instructie $X\gets N$. Bijgevolg zetten we het set-signaal van het $X$-register hoog, samen met het selectie-signaal van de multiplexer, waardoor deze $N$ doorgeeft. Dit resulteert in $\left(a,b\right)=\left(1,1\right)$. Daarnaast worden $Y$ en $Z$ op $0$ gezet. Dit betekent dat we het set-signaal op laag zetten van beide registers en het
reset-signaal op hoog. Vermits de waarde van de multiplexers niet wordt ingelezen, maakt het niet uit welke waarde de multiplexer doorgeeft. Daarom is het volgende deel van het instructiewoord $\left(c,d,e,f,g,h\right)=\left(0,1,-,0,1,-\right)$. De instructie $I\gets N$ bepaalt tot slot de rest van het instructiewoord. Het complete instructiewoord wordt dan:
\begin{equation}
S_1:\left(co,a,b,c,d,e,f,g,h,i,j\right)=\left(0,1,1,0,1,-,0,1,-,1,1\right)
\end{equation}
Ondanks het feit dat alle instructies onafhankelijk van testen worden uitgevoerd, is de volgende toestand wel afhankelijk van de $ci$-controller-ingang. Bijgevolg plaatsen we twee regels in de toestandstabel: indien $ci=0$ is de volgende toestand opnieuw $S_1$, in het andere geval is de volgende toestand $S_2$. In het geval van toestand $S_2$ zijn sommige instructies wel afhankelijk van de resultaten van enkele testen. Er zijn echter wel enkele instructies die onafhankelijk van testen worden uitgevoerd. Op analoge wijze bekomen we voor deze instructiebits: $\left(co,a,b,i,j\right)=\left(0,1,0,1,0\right)$. De andere instructies zijn afhankelijk van de test die we gespecificeerd hebben als de status-bit \underline{A} ofwel $z_2z_1z_0x_3<D$. In het geval deze test slaagt zijn de rest van de instructie-bits $\left(c,d,e,f,g,h\right)=\left(1,0,0,1,0,0\right)$. In het andere geval is $\left(c,d,e,f,g,h\right)=\left(1,0,1,1,0,1\right)$. Dit kunnen we formaliseren als:
\begin{equation}
S_2:\left(co,a,b,c,d,e,f,g,h,i,j\right)=\left\{\begin{array}{ll}
\left(0,1,0,1,0,0,1,0,0,1,0\right)&\ifun\mbox{\underline{A}}\\
\left(0,1,0,1,0,1,1,0,1,1,0\right)&\otherwiseun\\
\end{array}\right.
\end{equation}
Opnieuw wordt de volgende toestand gedifferentieerd op basis van een test: \underline{B}. Indien \underline{B} waar is, is $I>0$ bijgevolg is de volgende toestand $S_2$, in het geval de test faalt, is de volgende toestand $S_3$. Tot slot beschouwen we de laatste toestand $S_3$: hierbij worden er geen instructies uitgevoerd. Bijgevolg staan alle set- en reset-signalen van de registers op 0. Opnieuw is ook de selectie-ingang van de multiplexers irrelevant: de inhoud wordt immers niet opgeslagen in de registers. Tot slot is de controller-uitgang $co=1$. Bijgevolg is de volledige uitvoer:
\begin{equation}
S_3:\left(co,a,b,c,d,e,f,g,h,i,j\right)=\left(1,0,-,0,0,-,0,0,-,0,-\right)
\end{equation}
Ook hier bepaalt de controller-ingang $ci$ de volgende toestand. Bijgevolg differenti\"eren we de volgende toestand opnieuw op basis van deze test. Op basis van deze paragraaf kunnen we dus de controller toestandstabel op tabel \ref{tbl:sprocessorControllerGenericLeadingExample} opstellen. Voor de concrete implementatie van de controller met behulp van flipflops verwijzen we naar het vorige hoofdstuk. Eenmaal de controller en het datapad gebouwd zijn, dienen we beide componenten alleen nog met elkaar te verbinden: de instructie-uitgangen van de controller worden gelinkt met de set- en reset-signalen van de registers en de selectie-ingangen van de multiplexers. De testen die op het datapad worden uitgevoerd vormen dan weer de invoer van de controller. Merk verder ook op dat we hier een input-gebaseerd ASM-schema hebben verwezenlijkt. Een toestandsgebaseerd ASM-schema wordt op compleet analoge wijze gesynthetiseerd, alleen zal het instructiewoord niet afhangen van eventuele testen. Opdelingen zoals bij
toestand $S_2$ komen dus niet voor.
\subsubsection{Betere implementatie}
Zoals reeds eerder vermeld leidt de procedure die we in deze subsectie hebben ontwikkeld hebben niet tot een optimale oplossing. Er zijn verschillende problemen die afhankelijk van het algoritme tot een ineffici\"ente implementatie leiden:
\begin{itemize}
 \item In deze implementatie zullen we voor elke operatie een aparte functionele eenheid voorzien. Merk echter op dat indien we in eender welke toestand slechts \'e\'en optelling uitvoeren we dezelfde opteller zouden kunnen gebruiken.
 \item Nogal wat functionele eenheden hebben gelijkaardige kenmerken. Zo valt $Y\shlcmd1$ te combineren met $y_2y_1y_01$. Functionele eenheden te combineren leidt tot een complexere schakeling maar minder redundante delen.
 \item In sommige algoritmen wordt slechts een subset van de register tegelijk gebruikt. In dat geval kunnen we een registerbank gebruiken en enkel de adressen uitlezen die bij een bepaalde toestand relevant zijn.
 \item We dienen niet steeds per register een bus te voorzien. Indien bij elke toestand een deel van de register belangrijk zijn, kunnen we op een beperkt aantal bussen de waardes van de relevante registers plaatsen.
 \item Soms kunnen we het ASM-schema verder optimaliseren. Dit sluit enigzinds aan bij de discussie over het aantal toestanden die we gebruikten voor de vertaling van het algoritme naar een ASM-schema.
 \item Logischerwijs kunnen we de toestandstabel van de controller eerst minimaliseren alvorens deze te implementeren.
\end{itemize}
In de volgende subsecties zullen we een groot deel van deze problemen bespreken en toepassen op het leidend voorbeeld.
\subsection{Ontwerp Controller}
\label{ss:syntheseFSMDController}
\subsubsection{Patronen in een algoritme}
Het ontwerp van een controller is in wezen equivalent met de implementatie van een Finite State Machine (FSM). De controller in het leidende voorbeeld is dan ook vrij eenvoudig te implementeren met behulp van de methodes uit hoofdstuk \ref{ch:SeqComp}. Bij complexe programma's is een implementatie van een controller echter niet meer zo triviaal: deze kennen een groot aantal toestanden en tests, en doorgaans een groot instructiewoord. Daarom werd al snel naar een methode gezocht om snel complexe controllers te bouwen. Dit doen we door volgende patronen in een ontwerp (ASM-schema) te zoeken:
\begin{itemize}
 \item \termen{Natuurlijke volgorde} van toestanden.
 \item Terugkerende sets van toestanden veroorzaakt door een \termen{subroutine}.
 \item Eenvoud van het implementeren van logica met behulp van one-hot coderingen.
\end{itemize}
Elk van deze elementen wordt in de volgende subsubsecties verder uitgewerkt. Op basis van deze drie elementen zullen we een component bouwen die een algemene controller vertegenwoordigt: de \termen{microprogrammeerbare controller}. Een component die we in een schakeling inpluggen en die we gegeven een ASM-schema vervolgens kunnen programmeren en daardoor omvormen tot een concrete controller.
\subsubsection{Algemene vorm van een controller}
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[subcomp/.style={minimum width=1.5cm,minimum height=2 cm,draw=black,fill=white,thick,rectangle}]
\node[subcomp] (SR) at (0,0) {SReg};
\node[subcomp] (NSL) at (3,1.25) {\begin{varwidth}{2 cm}\begin{center}Next\\State\\Logic\end{center}\end{varwidth}};
\node[subcomp] (OL) at (3,-1.25) {\begin{varwidth}{2 cm}\begin{center}Output\\Logic\end{center}\end{varwidth}};
%\coordinate (CSP) at ($0.5*(SR)+0.25*(NSL)+0.25*(OL)$);
\coordinate (CSP) at ($(SR.east)+(1,0)$);
\coordinate (TL) at (SR.west |- NSL.north);\coordinate (TL) at ($(TL)+(-0.25,0.25)$);
\pdot{CSP};
\coordinate (NSLA) at ($0.75*(NSL.south west)+0.25*(NSL.north west)$);
\coordinate (NSLB) at ($0.5*(NSL.south west)+0.5*(NSL.north west)$);
\coordinate (NSLC) at ($0.25*(NSL.south west)+0.75*(NSL.north west)$);
\coordinate (OLA) at ($0.75*(OL.south west)+0.25*(OL.north west)$);
\coordinate (OLB) at ($0.5*(OL.south west)+0.5*(OL.north west)$);
\coordinate (OLC) at ($0.25*(OL.south west)+0.75*(OL.north west)$);
\draw[thick] (SR) -- (CSP);\draw[thick,->] (CSP) |- (NSLA);\draw[thick,->] (CSP) |- (OLC);
\draw[thick,->] (NSL.east) -- ++(0.25,0) |- (TL) |- (SR.west);
\begin{pgfonlayer}{background}
\node[subcomp,fill=gray!20, fit=(SR) (NSL) (OL),inner sep=1cm] (CT) {};
\end{pgfonlayer}
\coordinate (CS) at ($0.333*(CT.north west)+0.667*(CT.north east)$);\draw[->,thick] (CS) -- ++(0,0.5) node[anchor=south,text width=1.5 cm]{Controle-Signalen (CS)};
\coordinate (SS) at ($0.667*(CT.north west)+0.333*(CT.north east)$);\draw[<-,thick] (SS) -- ++(0,0.5)
 node[anchor=south,text width=1.5 cm]{Status-Signalen (SS)};
\coordinate (CI) at (CT.west);\draw[<-,thick] (CI) -- ++(-0.5,0) node[anchor=east,text width=1.5 cm]{Controle-Ingangen (CI)};
\coordinate (CO) at (CT.east);\draw[->,thick] (CO) -- ++(0.5,0) node[anchor=west,text width=1.5 cm]{Controle-Uitgangen (CO)};
\coordinate (COD) at ($0.667*(OL.south east)+0.333*(OL.north east)$);\draw[thick] (COD) -| ($(CO)+(-0.25,0)$) -- (CO);
\coordinate (CSD) at ($0.333*(OL.south east)+0.667*(OL.north east)$);\coordinate (CSE) at ($0.75*(NSL.south east)+0.25*(NSL.north east)+(0.5,0)$);\coordinate (CSF) at ($(CS)+(0,-0.25)$);\draw[thick] (CSD) -| (CSE) |- (CSF) -- (CS);
\coordinate (NSLSS) at ($(NSLC)+(-0.75,0)$);
\draw[thick,->] (SS) |- (NSLC);\draw[thick,->] (CI) -- ++(0.25,0) |- (NSLB);\draw[thick,->] ($(CI)+(0.25,0)$) |- (OLA);\pdot{$(CI)+(0.25,0)$};\pdot{NSLSS};\draw[thick,dashed,->] (NSLSS) |- (OLB);
\end{tikzpicture}
\caption{Algemene vorm van een controller.}
\figlab{generalStructureController}
\end{figure}
Allereerst grijpen we terug naar de definitie van een controller en combineren we deze met de defintie van een sequenti\"ele schakeling. In subsectie \ref{ss:specialProcessorGeneralStructure} hebben we reeds de invoer en uitvoer van een controller besproken. We zien dezelfde structuur op figuur \ref{fig:generalStructureController}. Daarnaast weten we uit hoofdstuk \ref{ch:SeqComp} hoe de algemene sequenti\"ele structuur eruit ziet:
\begin{itemize}
 \item \termen{State Register} ofwel \termen{toestandsregister}: een register die de huidige toestand bijhoudt.
 \item \termen{Next State Logic}: combinatorische logica die de volgende toestand berekent.
 \item \termen{Output Logic} ofwel \termen{uitvoer logica}: een component die het instructiewoord ofwel de controle-signalen berekend, samen met de controle-uitgangen.
\end{itemize}
Beide combinatorische componenten zijn afhankelijk van zowel de controle-ingangen en de huidige toestand bijgehouden door het toestandregister. Daarnaast zullen de statussignalen (de resultaten van de testen in het datapad) de volgende toestand mee helpen bepalen. In het geval van een inputgebaseerd ASM-schema is dit zelfs het geval voor de uitvoer logica. We kunnen dus stellen dat figuur \ref{fig:generalStructureController} de algemene structuur van de controller weergeeft. We zullen dit ontwerp in de volgende subsubsecties aanpassen tot een structuur die gericht is op specifieke eigenschappen van een controller.
\subsubsection{Natuurlijke volgorde van toestanden}
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[subcomp/.style={minimum width=1.5cm,minimum height=2 cm,draw=black,fill=white,thick,rectangle}]
\node[subcomp] (SR) at (0,0) {SReg};
\node[mux2to1,fill=white,rotate=90,thick] (M) at (-1.5,0) {};
\node[subcomp,minimum width=0.5 cm,minimum height=0.25] (INC) at ($(M.data1)+(-0.75,0)$) {$+1$};
\draw[thick,->] (M.output) -- (SR.west);
\draw[thick,->] (INC.east) -- (M.data1);
\node[subcomp] (NSL) at (3,1.25) {\begin{varwidth}{2 cm}\begin{center}Next\\State\\Logic\end{center}\end{varwidth}};
\node[subcomp] (OL) at (3,-1.25) {\begin{varwidth}{2 cm}\begin{center}Output\\Logic\end{center}\end{varwidth}};
\coordinate (CSP) at ($(SR.east)+(1,0)$);
\coordinate (TL) at (M.north |- NSL.north);\coordinate (TL) at ($(TL)+(-0.5,0.5)$);\coordinate (TLA) at ($(TL)+(0.25,-0.25)$);
\pdot{CSP};
\coordinate (NSLA) at ($0.75*(NSL.south west)+0.25*(NSL.north west)$);
\coordinate (NSLB) at ($0.5*(NSL.south west)+0.5*(NSL.north west)$);
\coordinate (NSLC) at ($0.25*(NSL.south west)+0.75*(NSL.north west)$);
\coordinate (OLA) at ($0.75*(OL.south west)+0.25*(OL.north west)$);
\coordinate (OLB) at ($0.5*(OL.south west)+0.5*(OL.north west)$);
\coordinate (OLC) at ($0.25*(OL.south west)+0.75*(OL.north west)$);
\draw[thick] (SR) -- (CSP);\draw[thick,->] (CSP) |- (NSLA);\draw[thick,->] (CSP) |- (OLC);
\draw[thick,->] (NSL.east) -- ++(0.5,0) |- (TL) |- (M.data0);
\draw[thick,->] ($0.5*(NSL.east)+0.5*(NSL.north east)$) -- ++(0.25,0) |- (TLA -| M.selout0) -- (M.selout0);
\begin{pgfonlayer}{background}
\node[subcomp,fill=gray!20, fit=(SR) (NSL) (OL) (M) (INC),inner sep=1cm] (CT) {};
\end{pgfonlayer}
\coordinate (CS) at ($0.333*(CT.north west)+0.667*(CT.north east)$);\draw[->,thick] (CS) -- ++(0,0.5) node[anchor=south,text width=1.5 cm]{Controle-Signalen (CS)};
\coordinate (SS) at ($0.667*(CT.north west)+0.333*(CT.north east)$);\draw[<-,thick] (SS) -- ++(0,0.5)
 node[anchor=south,text width=1.5 cm]{Status-Signalen (SS)};
\coordinate (CI) at (CT.west);\draw[<-,thick] (CI) -- ++(-0.5,0) node[anchor=east,text width=1.5 cm]{Controle-Ingangen (CI)};
\coordinate (CO) at (CT.east);\draw[->,thick] (CO) -- ++(0.5,0) node[anchor=west,text width=1.5 cm]{Controle-Uitgangen (CO)};
\coordinate (COD) at ($0.667*(OL.south east)+0.333*(OL.north east)$);\draw[thick] (COD) -| ($(CO)+(-0.25,0)$) -- (CO);
\coordinate (CSD) at ($0.333*(OL.south east)+0.667*(OL.north east)$);\coordinate (CSE) at ($0.75*(NSL.south east)+0.25*(NSL.north east)+(0.75,0)$);\coordinate (CSF) at ($(CS)+(0,-0.25)$);\draw[thick] (CSD) -- ++(0.25,0) |- (CSE) |- (CSF) -- (CS);
\coordinate (NSLSS) at ($(NSLC)+(-0.75,0)$);\coordinate (SRINC) at ($(SR.east)+(0.25,0)$);\coordinate (SRINCA) at ($(INC.west)+(-0.25,0)$);\coordinate (SRINCA) at (SRINCA |- OLB);
\pdot{SRINC};
\draw[thick,->] (SRINC) |- (SRINCA) |- (INC.west);
\draw[thick,->] (SS) |- (NSLC);\draw[thick,->] (CI) -- ++(0.25,0) |- (NSLB);\draw[thick,->] ($(CI)+(0.25,0)$) |- (OLA);\pdot{$(CI)+(0.25,0)$};\pdot{NSLSS};\draw[thick,dashed,->] (NSLSS) |- (OLB);
\begin{pgfonlayer}{background}
\node[fill=gray!10,draw=black,dotted,thin, fit=(SR) (M) (INC),inner sep=0.5cm] (LR) {};
\end{pgfonlayer}
\end{tikzpicture}
\caption{Controller met natuurlijke volgorde van toestanden.}
\figlab{incrementStructureController}
\end{figure}
Men kan de toestand van een controller enigzinds vergelijken met een programmateller. In de meeste gevallen zal een programma dan ook bestaan uit een reeks toestanden waarbij de volgende toestand vaststaat. Omdat het zoeken van een minimale encodering voor grote toestandstabellen tijdrovend is, zullen we deze optie niet beschouwen. Een logisch gevolg hiervan is dat we de opeenvolgende toestanden opeenvolgende toestandscoderingen geven, in plaats van deze volgende toestandscoderingen voor elke toestand uit te rekenen. We kunnen dit probleem eenvoudig oplossen door een incrementor en een multiplexer te voorzien. Een deel van de volgende toestandlogica bestaat er dan uit om te bepalen of we de toestandcodering incrementeren, in het ander geval dient de volgende toestand logica zelf een adres te berekenen. In veel gevallen leidt dit tot een vereenvoudiging van de uitvoer logica: er zijn immers heel wat toestanden die deze increment functie kunnen gebruiken, indien dit het geval is kunnen we bovendien don't cares
invoeren bij de logica die de volgende encodering berekent. De volgende toestandlogica dient dan ook enkel conditionele volgende toestanden genereren. Figuur \ref{fig:incrementStructureController}. Een oplettende lezer zal misschien reeds opgemerkt hebben dat een register gecombineerd met increment neerkomt op een teller. Vermits we met behulp van de multiplexer kunnen kiezen om het register met 1 op te hogen, ofwel een nieuwe waarde in te laden, hebben we hier een laadbare teller gerealiseerd. Op figuur \ref{fig:incrementStructureController} hebben we de componten die leiden tot deze laadbare teller gemarkeerd met behulp van een lichtgrijze rechthoek.
\subsubsection{Ondersteunen van subroutines}
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[subcomp/.style={minimum width=1.5cm,minimum height=2 cm,draw=black,fill=white,thick,rectangle}]
\node[subcomp] (SR) at (0,0) {SReg};
\node[mux4to1,fill=white,rotate=90,thick] (M) at (-1.35,0) {};
\node[subcomp,minimum width=1.1 cm,minimum height=0.25] (INC) at ($(M.data3)+(-1.25,-0.25)$) {$+1$};
\coordinate (LFD) at (M.data2 -| INC.north);
\node[subcomp,minimum width=1.1 cm,minimum height=1.55 cm,anchor=south] (LIFO) at ($(LFD)+(0,-0.25)$) {LIFO};
\draw[thick,->] (M.output) -- (SR.west);
\draw[thick,->] (LIFO.east |- M.data1) -- (M.data1);
\node[subcomp] (NSL) at (3,1.25) {\begin{varwidth}{2 cm}\begin{center}Next\\State\\Logic\end{center}\end{varwidth}};
\coordinate (TL) at (M.north |- NSL.north);\coordinate (TL) at ($(TL)+(-0.4,0.5)$);\coordinate (TLA) at ($(TL)+(0.25,-0.25)$);
\draw[thick,->] (INC.east) -- (INC.east -| TL) |- (M.data3);\pdot{M.data3 -| TL};\draw[thick,->] (M.data3 -| TL) |- (M.data2 -| LIFO.east);
\node[subcomp] (OL) at (3,-1.25) {\begin{varwidth}{2 cm}\begin{center}Output\\Logic\end{center}\end{varwidth}};
\coordinate (CSP) at ($(SR.east)+(1,0)$);
\pdot{CSP};
\coordinate (NSLA) at ($0.8*(NSL.south west)+0.2*(NSL.north west)$);
\coordinate (NSLB) at ($0.6*(NSL.south west)+0.4*(NSL.north west)$);
\coordinate (NSLC) at ($0.4*(NSL.south west)+0.6*(NSL.north west)$);
\coordinate (NSLD) at ($0.2*(NSL.south west)+0.8*(NSL.north west)$);
\coordinate (OLA) at ($0.75*(OL.south west)+0.25*(OL.north west)$);
\coordinate (OLB) at ($0.5*(OL.south west)+0.5*(OL.north west)$);
\coordinate (OLC) at ($0.25*(OL.south west)+0.75*(OL.north west)$);
\draw[thick] (SR) -- (CSP);\draw[thick,->] (CSP) |- (NSLA);\draw[thick,->] (CSP) |- (OLC);
\draw[thick,->] (NSL.east) -- ++(0.5,0) |- (TL) |- (M.data0);
\draw[thick,->] ($0.5*(NSL.east)+0.5*(NSL.north east)$) -- ++(0.25,0) |- (TLA -| M.selout0) -- (M.selout0);
\begin{pgfonlayer}{background}
\node[subcomp,fill=gray!20, fit=(SR) (NSL) (OL) (M) (INC),inner sep=1cm] (CT) {};
\end{pgfonlayer}
\coordinate (CS) at ($0.333*(CT.north west)+0.667*(CT.north east)$);\draw[->,thick] (CS) -- ++(0,0.5) node[anchor=south,text width=1.5 cm]{Controle-Signalen (CS)};
\coordinate (SS) at ($0.667*(CT.north west)+0.333*(CT.north east)$);\draw[<-,thick] (SS) -- ++(0,0.5)
 node[anchor=south,text width=1.5 cm]{Status-Signalen (SS)};
\coordinate (CI) at (CT.west);\draw[<-,thick] (CI) -- ++(-0.5,0) node[anchor=east,text width=1.5 cm]{Controle-Ingangen (CI)};
\coordinate (CO) at (CT.east);\draw[->,thick] (CO) -- ++(0.5,0) node[anchor=west,text width=1.5 cm]{Controle-Uitgangen (CO)};
\coordinate (COD) at ($0.667*(OL.south east)+0.333*(OL.north east)$);\draw[thick] (COD) -| ($(CO)+(-0.25,0)$) -- (CO);
\coordinate (PuPoD) at ($(NSL.north west)+(-0.25,0)$);\coordinate (PuPo) at (LIFO.north);
\draw[thick,->] (NSLB) -| (PuPoD) -| (PuPo);\draw ($(PuPo)+(0,0.2)$) node[anchor=south west,rotate=90,scale=0.85] {Push/Pop$^*$};
\coordinate (CSD) at ($0.333*(OL.south east)+0.667*(OL.north east)$);\coordinate (CSE) at ($0.75*(NSL.south east)+0.25*(NSL.north east)+(0.75,0)$);\coordinate (CSF) at ($(CS)+(0,-0.25)$);\draw[thick] (CSD) -- ++(0.25,0) |- (CSE) |- (CSF) -- (CS);
\coordinate (NSLSS) at ($(NSLD)+(-0.75,0)$);\coordinate (SRINC) at ($(SR.east)+(0.25,0)$);\coordinate (SRINCA) at ($(INC.west)+(-0.25,0)$);\coordinate (SRINCA) at (SRINCA |- OLB);
\pdot{SRINC};
\draw[thick,->] (SRINC) |- (SRINCA) |- (INC.west);
\draw[thick,->] (SS) |- (NSLD);\draw[thick,->] (CI) -- ++(0.25,0) |- (NSLC);\draw[thick,->] ($(CI)+(0.25,0)$) |- (OLA);\pdot{$(CI)+(0.25,0)$};\pdot{NSLSS};\draw[thick,dashed,->] (NSLSS) |- (OLB);
\begin{pgfonlayer}{background}
\node[fit=(LIFO) (INC) (M),inner sep=0.125cm] (NSTPA) {};
\node[fit=(NSL),inner sep=0.125cm] (NSTPB) {};
\coordinate (NSTPC) at ($(SR.north east)+(0,0.25)$);
\filldraw[dotted,fill=gray!10] (NSTPA.south west) -- (NSTPA.south east) |- (NSTPC) -- (NSTPB.south west) -- (NSTPB.south east) -- (NSTPB.north east) -- (NSTPB.north west) -| (NSTPA.north west) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\caption{Controller met natuurlijke volgorde van toestanden en subroutines.}
\figlab{subroutineStructureController}
\end{figure}
Bij het bouwen van een programma wordt vaak gebruik gemaakt van een subroutine: een klein programma dat we oproepen om een bepaalde opdracht uit te voeren en nadien terugkeert naar de toestand die volgt op de toestand waar we de subroutine hebben opgeroepen. Een probleem bestaat erin dat we niet eenvoudigweg de subroutine kunnen omzetten naar een reeks toestanden en vervolgens naar de eerste toestand van deze subroutine kunnen springen. In dat geval weet de subroutine immers niet meer naar welke toestand men dient terug te springen (deze toestand wordt de \termen{terugkeertoestand} genoemd) nadat de subroutine is uitgevoerd. Een oplossing zou erin kunnen bestaan om in dat geval per oproep van een subroutine de subroutine te kopi\"eren in de structuur. Deze oplossing heeft echter enkele nadelen:
\begin{itemize}
 \item Iedere keer wanneer we een subroutine oproepen dienen we een kopie te maken van alle toestanden. Indien de subroutine $T_s$ verschillende toestanden heeft en we roepen de routine $n$ keer op, resulteert dit in een controller waarvan $n\cdot T_s$ toestanden door de subroutine zijn gegenereerd. Dit leidt dus tot een groot aantal toestanden en complexe logica voor het berekenen van de volgende toestand en de uitvoer.
 \item In sommige programma's roept een subroutine zichzelf op. Dit fenomeen wordt \termen{recursie} genoemd. We kunnen dit fenomeen niet rechtstreeks omzetten in de aangereikte oplossing, omdat we niet altijd vooraf weten hoe diep deze recursie gaat. In dat geval zullen we de subroutine eerst moeten herschrijven in een subroutine zonder recursie.
\end{itemize}
De oplossing bestaat dan ook uit een datastructuur genaamd de \termen{call stack} die -- zoals de naam reeds doet vermoeden -- een vorm van stapelgeheugen is. De oplossing bestaat eruit bij elke oproep naar het stapelgeheugen de terugkeertoestand op de call stack te zetten. Op het moment dat de subroutine is afgelopen, wordt de terugkeertoestand terug uit het stapelgeheugen uitgelezen en in het toestandsregister geplaatst. De callstack ondersteunt ook recursie omdat indien een subroutine zichzelf oproept, ook de terugkeertoestand van deze subroutine op de stapel wordt gezet. Indien we deze wijziging combineren met wat we al hebben bekomen we een structuur met een incrementor, een stapelgeheugen en een multiplexer zoals op figuur \ref{fig:subroutineStructureController}. De volgende toestand logica heeft dan vier verschillende types instructies:
\begin{itemize}
 \item Natuurlijke volgende toestand: het toestandregister wordt met 1 opgehoogd. Dit gebeurt bij toestanden waarbij de volgende toestand vast staat (onafhankelijk van testen).
 \item Specifieke volgende toestand: indien de volgende toestand wel afhankelijk is van testen, of we springen naar een bepaalde toestand in een programma kan de volgende toestand logica zelf een toestand berekenen.
 \item Uitvoeren van een subroutine: in dat geval wordt de natuurlijke volgende toestand van de huidige toestand op de call stack geplaatst, en lezen we de begintoestand van de subroutine in het toestandsregister in.
 \item Terugkeren uit een subroutine: dit is de laatste instructie bij een subroutine. We voeren een pop-operatie uit op de call stack en de terugkeertoestand wordt in het toestandsregister ingelezen. We maken dus de veronderstelling dat we terugspringen naar de volgende natuurlijke toestand van de procedure die we hebben opgeroepen\footnote{We kunnen echter de component aanpassen dat we ook zelf een terugkeertoestand kunnen invoeren. Anderzijds kunnen we, indien dit nodig is, van de terugkeertoestand ook een lege toestand maken en de volgende toestandlogica dan naar het juiste adres laten springen.}.
\end{itemize}
We realiseren deze schakeling door naast de incrementor, ook een een stapelgeheugen te plaatsen. De volgende toestandslogica heeft controle over de multiplexer (die kan kiezen uit het stapelgeheugen, de incrementor of een toestandencodering die hij zelf heeft gegenereerd) samen met de push/pop$^*$-ingang van het stapelgeheugen. Verder kan de volgende toestand logica ook zelf een toestandcodering genereren door deze aan \'e\'en van de data-ingangen van de multiplexer aan te leggen.
\subsubsection{Werken met ``One-Hot'' coderingen}
In het vorige hoofdstuk hebben we het reeds uitgebreid gehad over de one-hot codering. Een one-hotcodering kan de volgende toestand logica drastisch vereenvoudigen. Een probleem is echter dat we bij een one-hot codering het aantal flipflops opdrijven. Een tussenoplossing zou er echter uit kunnen bestaan om een decoder tussen het toestandsregister en de volgende toestand logica te zetten. Merk op dat we verder ook de uitvoer-logica op een gelijkaardige manier kunnen vereenvoudigen.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[subcomp/.style={minimum width=1.5cm,minimum height=2 cm,draw=black,fill=white,thick,rectangle}]
\node[subcomp] (SR) at (0,0) {SReg};
\node[mux4to1,fill=white,rotate=90,thick] (M) at (-1.35,0) {};
\node[subcomp,minimum width=1.1 cm,minimum height=0.25] (INC) at ($(M.data3)+(-1.25,-0.25)$) {$+1$};
\coordinate (LFD) at (M.data2 -| INC.north);
\node[subcomp,minimum width=1.1 cm,minimum height=1.55 cm,anchor=south] (LIFO) at ($(LFD)+(0,-0.25)$) {LIFO};
\draw[thick,->] (M.output) -- (SR.west);
\draw[thick,->] (LIFO.east |- M.data1) -- (M.data1);
\node[subcomp] (DEC) at (2,0) {Decoder};
\node[subcomp] (NSL) at (4,1.25) {\begin{varwidth}{2 cm}\begin{center}Next\\State\\Logic\end{center}\end{varwidth}};
\coordinate (TL) at (M.north |- NSL.north);\coordinate (TL) at ($(TL)+(-0.4,0.5)$);\coordinate (TLA) at ($(TL)+(0.25,-0.25)$);
\draw[thick,->] (INC.east) -- (INC.east -| TL) |- (M.data3);\pdot{M.data3 -| TL};\draw[thick,->] (M.data3 -| TL) |- (M.data2 -| LIFO.east);
\node[subcomp] (OL) at (4,-1.25) {\begin{varwidth}{2 cm}\begin{center}Output\\Logic\end{center}\end{varwidth}};
\coordinate (CSP) at ($(DEC.east)+(0.25,0)$);
\pdot{CSP};
\coordinate (NSLA) at ($0.667*(NSL.south west)+0.333*(NSL.north west)$);
\coordinate (NSLB) at ($0.333*(NSL.south west)+0.667*(NSL.north west)$);
\coordinate (OLA) at (OL.west);
\draw[thick,->] (SR.east) -- (DEC.west);
\draw[thick] (DEC.east) -- (CSP);\draw[thick,->] (CSP) |- (NSLA);\draw[thick,->] (CSP) |- (OLA);
\draw[thick,->] (NSL.east) -- ++(0.5,0) |- (TL) |- (M.data0);
\draw[thick,->] ($0.5*(NSL.east)+0.5*(NSL.north east)$) -- ++(0.25,0) |- (TLA -| M.selout0) -- (M.selout0);
\begin{pgfonlayer}{background}
\node[subcomp,fill=gray!20, fit=(SR) (NSL) (OL) (M) (INC),inner sep=1cm] (CT) {};
\end{pgfonlayer}
\coordinate (CS) at ($0.333*(CT.north west)+0.667*(CT.north east)$);\draw[->,thick] (CS) -- ++(0,0.5) node[anchor=south,text width=1.5 cm]{Controle-Signalen (CS)};
\coordinate (SS) at ($0.667*(CT.north west)+0.333*(CT.north east)$);\draw[<-,thick] (SS) -- ++(0,0.5)
 node[anchor=south,text width=1.5 cm]{Status-Signalen (SS)};
\coordinate (CI) at (CT.west);\draw[<-,thick] (CI) -- ++(-0.5,0) node[anchor=east,text width=1.5 cm]{Controle-Ingangen (CI)};
\coordinate (CO) at (CT.east);\draw[->,thick] (CO) -- ++(0.5,0) node[anchor=west,text width=1.5 cm]{Controle-Uitgangen (CO)};
\coordinate (COD) at ($0.667*(OL.south east)+0.333*(OL.north east)$);\draw[thick] (COD) -| ($(CO)+(-0.25,0)$) -- (CO);
\coordinate (PuPo) at (LIFO.north);\draw[thick,->] (NSLB) -| (PuPo);\draw ($(PuPo)+(0,0.2)$) node[anchor=south west,rotate=90,scale=0.85] {Push/Pop$^*$};
\coordinate (CSD) at ($0.333*(OL.south east)+0.667*(OL.north east)$);\coordinate (CSE) at ($0.75*(NSL.south east)+0.25*(NSL.north east)+(0.75,0)$);\coordinate (CSF) at ($(CS)+(0,-0.25)$);\draw[thick] (CSD) -- ++(0.25,0) |- (CSE) |- (CSF) -- (CS);
\coordinate (NSLSS) at ($(NSLD)+(-0.75,0)$);\coordinate (SRINC) at ($(SR.east)+(0.25,0)$);\coordinate (SRINCA) at ($(INC.west)+(-0.25,0)$);\coordinate (SRINCA) at (SRINCA |- OLB);
\pdot{SRINC};
\draw[thick,->] (SRINC) |- (SRINCA) |- (INC.west);
\coordinate (SRCI) at ($(SR.south)+(0,-0.5)$);\draw[thick,->] (CI) -- ++(0.25,0) |- (SRCI -| DEC) -- (DEC);\draw[thick,->] (SS) |- (NSL.east -| DEC.north) -- (DEC.north);
\begin{pgfonlayer}{background}
\node[subcomp,dotted,fill=gray!10,fit=(NSL) (DEC) (OL),inner sep=0.125cm] (ROM) {};
%\node[fit=(NSL),inner sep=0.125cm] (NSTPB) {};
%\coordinate (NSTPC) at ($(SR.north east)+(0,0.25)$);
%\filldraw[dotted,fill=gray!10] (NSTPA.south west) -- (NSTPA.south east) |- (NSTPC) -- (NSTPB.south west) -- (NSTPB.south east) -- (NSTPB.north east) -- (NSTPB.north west) -| (NSTPA.north west) -- cycle;
\end{pgfonlayer}
\end{tikzpicture}
\caption{Controller met one-hotcodering.}
\figlab{oneHotStructureController}
\end{figure}
Figuur \ref{fig:oneHotStructureController} toont een algemene controller waarbij we een decoder tussen het toestandsregister en de volgende toestand- en uitvoer-logica's plaatsen.
\subsubsection{Programmeerbare controller}
In plaats van specifieke logica te voorzien voor de volgende toestand logica en de uitvoer logica, kunnen we deze componenten ook vervangen door een meer algemene structuur: een vorm van look-up tables. Indien we deze look-up table vervolgens combineren met de decoder bekomen we een geheugen (deze componenten staan gemarkeerd op figuur \ref{fig:oneHotStructureController}). Welk geheugen we gebruiken is in principe arbitrair. Indien we een ROM-geheugen gebruiken kunnen we de controller eenmaal programmeren naar een specifieke controller. Een andere mogelijkheid is om een RAM-geheugen te gebruiken waarbij we de specifieke controller telkens inladen bij het opstarten van het elektronisch circuit. Een voordeel van het gebruik van een RAM-geheugen is dat we bijgevolg het algoritme kunnen wijzigen, op voorwaarde dat alle benodigde hardware op het datapad aanwezig is. Daarentegen betalen we een prijs dat bij het opstarten van de component we eerst de controller moeten inladen wat tijd vergt.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[subcomp/.style={minimum width=1.5cm,minimum height=2 cm,draw=black,fill=white,thick,rectangle}]
\node[subcomp] (SR) at (0,0) {SReg};
\node[mux4to1,fill=white,rotate=90,thick] (M) at (-1.35,0) {};
\node[subcomp,minimum width=1.1 cm,minimum height=0.25] (INC) at ($(M.data3)+(-1.25,-0.25)$) {$+1$};
\coordinate (LFD) at (M.data2 -| INC.north);
\node[subcomp,minimum width=1.1 cm,minimum height=1.55 cm,anchor=south] (LIFO) at ($(LFD)+(0,-0.25)$) {LIFO};
\draw[thick,->] (M.output) -- (SR.west);
\draw[thick,->] (LIFO.east |- M.data1) -- (M.data1);
\node[subcomp] (ROM) at (2,0) {\begin{varwidth}{1.5cm}ROM-geheugen\end{varwidth}};
\coordinate (TL) at (M.north |- NSL.north);\coordinate (TL) at ($(TL)+(-0.4,0.5)$);\coordinate (TLA) at ($(TL)+(0.25,-0.25)$);
\coordinate (ROMSA) at ($0.667*(ROM.south west)+0.333*(ROM.south east)$);
\coordinate (ROMSB) at ($0.333*(ROM.south west)+0.667*(ROM.south east)$);
\coordinate (ROMNA) at ($0.8*(ROM.north west)+0.2*(ROM.north east)$);
\coordinate (ROMNB) at ($0.6*(ROM.north west)+0.4*(ROM.north east)$);
\coordinate (ROMNC) at ($0.4*(ROM.north west)+0.6*(ROM.north east)$);
\coordinate (ROMND) at ($0.2*(ROM.north west)+0.8*(ROM.north east)$);
\draw[thick,->] (INC.east) -- (INC.east -| TL) |- (M.data3);\pdot{M.data3 -| TL};\draw[thick,->] (M.data3 -| TL) |- (M.data2 -| LIFO.east);
\draw[thick,->] (SR.east) -- (ROM.west);
\draw[thick,->] (ROMSA) -- ++(0,-0.5) -| (M.selin0);
\draw[thick,->] (ROMNA) -- ++(0,0.25) -| ($(M.data0)+(-0.25,0)$) -- (M.data0);
\begin{pgfonlayer}{background}
\node[subcomp,fill=gray!20, fit=(SR) (ROM) (M) (INC),inner sep=1.25cm] (CT) {};
\end{pgfonlayer}
\coordinate (CS) at ($0.333*(CT.north west)+0.667*(CT.north east)$);\draw[->,thick] (CS) -- ++(0,0.5) node[anchor=south,text width=1.5 cm]{Controle-Signalen (CS)};
\coordinate (SS) at ($0.667*(CT.north west)+0.333*(CT.north east)$);\draw[<-,thick] (SS) -- ++(0,0.5)
 node[anchor=south,text width=1.5 cm]{Status-Signalen (SS)};
\coordinate (CI) at (CT.west);\draw[<-,thick] (CI) -- ++(-0.5,0) node[anchor=east,text width=1.5 cm]{Controle-Ingangen (CI)};
\coordinate (CO) at (CT.east);\draw[->,thick] (CO) -- ++(0.5,0) node[anchor=west,text width=1.5 cm]{Controle-Uitgangen (CO)};
\draw[thick] (ROM.east) -- (CO);
\coordinate (PuPo) at (LIFO.north);\draw[thick,->] (ROMNB) -- ++(0,0.5) -| (PuPo);

\coordinate (NSLSS) at ($(NSLD)+(-0.75,0)$);\coordinate (SRINC) at ($(SR.east)+(0.25,0)$);\coordinate (SRINCA) at ($(SR.south)+(0,-0.25)$);\coordinate (SRINCB) at ($(INC.west)+(-0.25,0)$);
\pdot{SRINC};
\draw[thick,->] (SRINC) |- (SRINCA) -| (SRINCB) |- (INC.west);
\coordinate (SRCI) at ($(SR.south)+(0,-0.75)$);\draw[thick,->] (CI) -- ++(0.25,0) |- (SRCI -| ROMSB) -- (ROMSB);\draw[thick,->] (SS) -- ++(0,-0.5) -| (ROMNC);
\draw[thick] (CS) -- ++(0,-0.25) -| (ROMND);
\end{tikzpicture}
\caption{Microprogrammeerbare controller.}
\figlab{microprogrammableController}
\end{figure}
Op figuur \ref{fig:microprogrammableController} tonen we een realisatie de microprogrammeerbare controller. Merk op dat we geen aparte geheugens voor de volgende toestand en de uitvoer voorzien. We kunnen beide componenten immers combineren tot \'e\'en geheugen component. Het ROM-geheugen dient dan ook verschillende rijen van bits op te slaan:
\begin{itemize}
 \item Push/Pop bits: wordt gebruikt bij het oproepen of verlaten van een subroutine, ofwel blijft het stapelgeheugen ongewijzigd.
 \item Multiplexer bits: bepalen welke van de drie bronnen van toestandscoderingen we gebruiken: natuurlijke opvolging, eigen adressering of stapelgeheugen.
 \item Toestandsencodering: in het geval men naar een speciale toestand wil gaan (geen natuurlijke opvolging).
 \item Controle-uitgang: bits die de toestand van een algoritme buiten de processor brengen.
 \item Controle-signalen ofwel het instructiewoord: bepaalt welke opdrachten het datapad zal uitvoeren.
\end{itemize}
\subsection{Minimaliseren Datapad}
\label{ss:syntheseFSMDDatapad}
Naast het introduceren van een algemene controller zullen we enkele verbeteringen bij een datapad bespreken. Hiervoor zullen we vier technieken bespreken:
\begin{itemize}
 \item Het samenvoegen van variabelen.
 \item Het samenvoegen van bewerkingen.
 \item Het samenvoegen van verbindingen ofwel ``\termen{bus sharing}''.
 \item Het samenvoegen van registers in een registerbank.
\end{itemize}
Alvorens we al deze optimalisaties bespreken zullen we eerst een ander leidend voorbeeld introduceren. We zullen telkens \'e\'en van de leidende voorbeelden gebruiken op de plaatsen waar dit relevant is.
\subsubsection{Leidend voorbeeld: vierkantswortel benadering}
Een tweede leidende voorbeeld is het benaderen van een vierkantswortel. Veel programma's berekenen vaak de vierkantswortel van de som van twee kwadraten (bijvoorbeeld bij het berekenen van een afstand tussen twee punten). Voor de meeste programma's is het echter niet belangrijk dat deze vierkantswortel met een hoge nauwkeurigheid berekend wordt. Daarom maakt men meestal gebruik van een volgende benadering:
\begin{equation}
\sqrt{x^2+y^2}\approx\max\left(\max\left(\left|x\right|,\left|y\right|\right),0.875\cdot\max\left(\left|x\right|,\left|y\right|\right)+0.5\cdot\min\left(\left|x\right|,\left|y\right|\right)\right)
\end{equation}
Figuur \ref{fig:asmSqrt} toont een ASM-schema die deze vierkantswortel kan uitrekenen. Bemerk dat we ook een controle-ingang $\mbox{start}$ voorzien, die op hoog dient gezet te worden alvorens het algoritme wordt uitgevoerd, en een controle-uitgang $\mbox{ready}$ die aangeeft dat het resultaat berekend is. Daarnaast zijn er twee data-ingangen $A$ en $B$. Daarnaast voorzien we ook een data-uitgang $R$ die het berekende resultaat naar buiten brengt.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[yscale=-1]
\node[asmS] (S01) at (0,0) {\begin{varwidth}{3 cm}$t_1\gets A$\\$t_2\gets B$\end{varwidth}};
\node[asmD] (D01) at (0,1.5) {$\mbox{start}$};\setTrueFalseLabels{D01}
\node[asmS] (S02) at (0,3) {\begin{varwidth}{3 cm}$t_3\gets \left|t_1\right|$\\$t_4\gets \left|t_2\right|$\end{varwidth}};
\node[asmS] (S03) at (0,4.5) {\begin{varwidth}{3 cm}$t_5\gets \max\left(t_3,t_4\right)$\\$t_6\gets \min\left(t_3,t_4\right)$\end{varwidth}};
\node[asmS] (S04) at (3.375,4.5) {\begin{varwidth}{3 cm}$t_7\gets t_5\shrcmd3$\\$t_8\gets t_6\shrcmd1$\end{varwidth}};
\node[asmS] (S05) at (3.375,3) {$t_9\gets t_5-t_7$};
\node[asmS] (S06) at (3.375,1.5) {$t_{10}\gets t_8+t_9$};
\node[asmS] (S07) at (3.375,0) {\begin{varwidth}{3 cm}$t_{11}\gets\max\left(t_5,t_{10}\right)$\end{varwidth}};
\node[asmS] (S08) at (3.375,-1.5) {$\mbox{ready=1}$};
\node[asmN] (N01) at (0,-1.5) {$R=t_{11}$};
\path[->] (S01) edge (D01) (S02) edge (S03) (S03) edge (S04) (S04) edge (S05) (S05) edge (S06) (S06) edge (S07) (S07) edge (S08);
\draw[->] (S08.west) -- (S01.north);
\draw[->] (D01.west) -| ++(-0.75,0.75) -| (S02.north);
\draw[->] (D01.east) -- ++(0.75,0) |- (S01.east);
\begin{pgfonlayer}{background}
\node[asmB,fit=(S01) (D01)] (B00) {};\draw (B00.north west) node[anchor=north east]{$S_0$};
\node[asmB,fit=(S02)] (B01) {};\draw (B01.north west) node[anchor=north east]{$S_1$};
\node[asmB,fit=(S03)] (B02) {};\draw (B02.north west) node[anchor=north east]{$S_2$};
\node[asmB,fit=(S04)] (B03) {};\draw (B03.north east) node[anchor=north west]{$S_3$};
\node[asmB,fit=(S05)] (B04) {};\draw (B04.north east) node[anchor=north west]{$S_4$};
\node[asmB,fit=(S06)] (B05) {};\draw (B05.north east) node[anchor=north west]{$S_5$};
\node[asmB,fit=(S07)] (B06) {};\draw (B06.north east) node[anchor=north west]{$S_6$};
\node[asmB,fit=(S08)] (B07) {};\draw (B07.north east) node[anchor=north west]{$S_7$};
\end{pgfonlayer}
\end{tikzpicture}
\caption{ASM-schema van het vierkantswortel-benaderingsalgoritme.}
\figlab{asmSqrt}
\end{figure}
Indien we dit ASM-schema op de eerder genoemde wijze zouden implementeren zouden we volgende componenten nodig hebben:
\begin{itemize}
 \item 11 registers (van een arbitrair aantal bits).
 \item 2 absolute waarde functionele eenheden.
 \item 2 maximum functionele eenheden.
 \item 1 minimum functionele eenheid.
 \item 1 opteller functionele eenheden.
 \item 1 aftrekker functionele eenheid.
 \item 1 shift 3 posities naar rechts functionele eenheid.
 \item 1 shift 1 positie naar rechts functionele eenheid.
\end{itemize}
Het is duidelijk dat dit ASM-schema een grote kost met zich teweeg brengt. We zullen in de volgende subsubsecties dan ook de implementatie significant verbeteren.
\begin{figure}[hbt]
\centering
\begin{sprocessor}[0.75/1.25/1.3/1.4/0.25/0.8]{t1/$t_1$/1/1,t2/$t_2$/1/1,t3/$t_3$/1/1,t4/$t_4$/1/1,t5/$t_5$/1/1,t6/$t_6$/1/1,t7/$t_7$/1/1,t8/$t_8$/1/1, t9/$t_9$/1/1,t10/$t_{10}$/1/1,t11/$t_{11}$/1/1}{abs1/$\abs$,abs2/$\abs$,max1/$\max$,min/$\min$,shr3/$\shrcmd3$,shr1/$\shrcmd1$,sub/$-$,add/$+$,max2/$\max$}{}
\sprbtf{t1}{abs1}{0};
\sprbtf{t2}{abs2}{-0.2};
\sprbtf{t3}{max1}{-0.3};
\sprbtf{t4}{max1}{0.3};
\sprbtf{t3}{min}{0};
\sprbtf{t4}{min}{0.3};
\sprbtf{t5}{shr3}{0};
\sprbtf{t6}{shr1}{0};
\sprbtf{t5}{sub}{-0.2};
\sprbtf{t7}{sub}{0.2};
\sprbtf{t8}{add}{-0.2};
\sprbtf{t9}{add}{0.2};
\sprbtf{t5}{max2}{-0.3};
\sprbtf{t10}{max2}{0};
\spfutr{max2}{t11}{0};
\spfutr{add}{t10}{0};
\spfutr{sub}{t9}{0};
\spfutr{shr1}{t8}{0};
\spfutr{shr3}{t7}{0};
\spfutr{min}{t6}{0};
\spfutr{max1}{t5}{0};
\spfutr{abs2}{t4}{0};
\spfutr{abs1}{t3}{0};
\end{sprocessor}
\caption{Implementatie van het datapad van de benaderende vierkantswortel volgens de basisprincipes.}
\figlab{datapad-generic}
\end{figure}
\subsubsection{Kostprijsberekening}
Alvorens we een goedkopere realisatie van de processor in kwestie kunnen bekomen, dienen we eerst te weten hoeveel elk component precies kost. Hiervoor kunnen we de implementatie van bijvoorbeeld een multiplexer in \'e\'en van de vorige hoofdstukken herbekijken, en de prijs uitrekenen. We zullen in deze subsubsectie echter een bondig overzicht geven die de kostprijs van de belangrijkste componenten die we zullen tegenkomen samenvat. Per component zullen we de kostprijs zowel in transistoren als in het aantal logische cellen in een FPGA weergeven. Verder zullen we ook telkens de componenten in functie van 1 bit uitdrukken, bijvoorbeeld een 1 bit register. Het vermenigvuldigen met het aantal bits geeft een ruwe schatting maar ervaring uit vorige hoofdstukken zou moeten leren dat we soms ook heel wat transistoren kunnen uitsparen omdat we sommige deelcircuits kunnen hergebruiken.
\begin{table}[hbt]
\centering
\begin{tabular}{lrrrrrr}
\toprule
&3-state buffer&\multicolumn{4}{c}{multiplexer}&register\\
\midrule
\# Transistoren&10&12&18&24&30&44\\
\# Logische cellen&0&1&2&2&3&1\\
\bottomrule
\toprule
&Half Adder&Full Adder&Aftrekker&Opteller/Aftrekker\\
\midrule
\# Transistoren&18&36&38&48\\
\# Logische cellen&2&2&2&2\\
\end{tabular}
\caption{Samenvatting van de kostprijs van de belangrijkste componenten}
\label{tbl:costComponentsProcessor}
\end{table}
\subsubsection{Variabelen samenvoegen}
Een belangrijke verbetering is het reduceren van het aantal variabelen en dus het aantal registers. We merken immers op in figuur \ref{fig:asmSqrt} dat de meeste variabelen slechts \'e\'enmaal op een waarde gezet worden, en daarna -- meestal in de volgende toestand -- uitgelezen worden. Vanaf dat moment worden deze variabelen niet meer gebruikt, bijgevolg levert het niets op om hun waarde effectief bij te houden. We kunnen de registers die eerst de waarde van de ene variabele bijhielden echter hergebruiken om de waarde van een andere variabele bij te houden. Hiervoor maken we gebruik van een \termen{levensduurtabel}. Een levensduurtabel is een tabel waarin de variabelen horizontaal worden voorgesteld, en de toestanden verticaal. We markeren een gegeven cel indien we in de gegeven of een latere toestand de waarde van de variabele uitlezen nadat de waarde is toegewezen. Zo zien we bijvoorbeeld op het ASM-schema (figuur \ref{fig:asmSqrt}), dat de variabele $t_5$ toegewezen wordt in toestand $S_2$ en we de
waarde uitlezen in toestanden $S_3$, $S_4$ en $S_6$. Dit betekent dus dat de \termen{levensduur} van $t_5$ zich uitstrekt van $S_3$ tot en met $S_6$. Men kan zich misschien afvragen waarom de toestand waarin we de waarde toewijzen niet ook deel uitmaakt van de levensduur. De reden is omdat op dat moment we nog geen register hebben waarin we de variabele opslaan. Let wel: er dient een register te bestaan waarin we plannen de waarde te zullen opslaan. In toestand $S_2$ wordt echter enkel de waarde van $t_5$ berekent en aangelegd op \'e\'en van de registers. Het register heeft echter de waarde nog niet opgeslagen. Dit doet het bij de klokflank tussen $S_2$ en $S_3$. We stellen de levensduur tabel op door voor elke variabele uit te rekenen wanneer welke variabelen actief zijn. De levensduurtabel van het leidend voorbeeld staat in tabel \ref{tbl:variableLifespanExample}. Onder de rij van variabelen vermelden we telkens het totaal aantal variabelen die in de gegeven toestand actief zijn.
\begin{table}[hbt]
\centering
\begin{tabular}{c|cccccccc}
&$S_0$&$S_1$&$S_2$&$S_3$&$S_4$&$S_5$&$S_6$&$S_7$\\\hline
$t_1$&	&$\bullet$&	&	&	&	&	&\\
$t_2$&	&$\bullet$&	&	&	&	&	&\\
$t_3$&	&	&$\bullet$&	&	&	&	&\\
$t_4$&	&	&$\bullet$&	&	&	&	&\\
$t_5$&	&	&	&$\bullet$&$\bullet$&$\bullet$&$\bullet$&\\
$t_6$&	&	&	&$\bullet$&	&	&	&\\
$t_7$&	&	&	&	&$\bullet$&	&	&\\
$t_8$&	&	&	&	&$\bullet$&$\bullet$&	&\\
$t_9$&	&	&	&	&	&$\bullet$&	&\\
$t_{10}$&	&	&	&	&	&	&$\bullet$&\\
$t_{11}$&$\cdot$&	&	&	&	&	&	&$\bullet$\\\hline
$\#$&1&2&2&2&3&3&2&0\\
\end{tabular}
\caption{Levensduurtabel van het vierkantswortel voorbeeld.}
\label{tbl:variableLifespanExample}
\end{table}
\paragraph{Formeel algoritme}We hebben tabel \ref{tbl:variableLifespanExample} opgesteld door te redeneren over de levensduurte van een bepaalde variabele. We kunnen de levensduur echter ook berekenen met een formeel algoritme. Dit algoritme is geen leerstof die behoort tot het opleidingsonderdeel ``Digitale Elektronica en Processoren'', maar is desalniettemin ook nuttig voor andere opleidingsonderdelen zoals bijvoorbeeld ``compilerconstructies'', In compilerconstructies wordt het genereren van een dergelijke tabel ook wel de ``liveness analyse genoemd''. In \cite{books/cu/Appel2002} wordt zo'n algoritme aangereikt. In het algoritme zal men eerst code opdelen in toestanden. Dit hoeven we hier niet meer te doen: dit zijn immers de toestanden van het ASM-schema. Verder dient elke toestand ook drie verzamelingen bij te houden:
\begin{itemize}
 \item $\succst{n}$: dit is een verzameling toestanden die op toestand $n$ kan volgen. Voor een ASM-blok zonder beslissingskader bestaat de toestand uit juist \'e\'en toestand. Voor ASM blokken met beslissingskaders uit \'e\'en of meerdere toestanden.
 \item $\usestt{n}$: dit is een verzameling van variabelen die in toestand $n$ gebruikt worden om berekeningen uit te voeren. Voor toestand $S_5$ is dit dus: $\usestt{S_5}=\left\{t_8,t_9\right\}$
 \item $\defstt{n}$: dit is de verzameling van alle variabelen die in een toestand $n$ gedefinieerd worden. Indien we niet weten of een variabele in een bepaalde toestand zal gedefinieerd worden
\end{itemize}
We dienen vervolgens de volgende twee sets te berekenen per toestand:
\begin{itemize}
 \item $\instt{n}$: een variabele zit in $\instt{n}$ voor een toestand $n$ wanneer er een uitvoer-pad bestaat waarbij de variabele levend is bij het binnenkomen van die toestand.
 \item $\outstt{n}$: een variabele zit in $\outstt{n}$ voor een toestand $n$ wanneer er een uitvoer-pad bestaat waarbij de variabele levend is bij het verlaten van die toestand.
\end{itemize}
Het algoritme die deze sets kan berekenen staat in \algoref{alg:calculatingLiveness}.
\begin{algorithm}[hbt]
\caption{Berekenen van liveness.}\label{alg:calculatingLiveness}
\begin{algorithmic}[1]
\Function{Liveness}{$\succst{n}$,$\usestt{n}$,$\defstt{n}$}
\ForAll{$n$}
\State $\instt{n}\gets\emptyset$
\State $\outstt{n}\gets\emptyset$
\EndFor
\Repeat
\ForAll{$n$}
\State $\inastt{n}\gets\instt{n}$
\State $\outastt{n}\gets\outstt{n}$
\State $\instt{n}\gets\usestt{n}\cup\left(\outstt{n}\setminus\defstt{n}\right)$
\State $\outstt{n}\gets\displaystyle\cup_{s\in\succst{n}}\instt{s}$
\EndFor
\Until{$\forall n: \inastt{n}=\instt{n}\wedge\outastt{n}=\outstt{n}$}
\State \Return $\left(\instt{n},\outstt{n}\right)$
\EndFunction
\end{algorithmic}
\end{algorithm}
Het algoritme werkt op basis van least-fixed-point theorie. Hierbij berekenen we de sets door ze te initialiseren als lege sets. En vervolgens deze telkens te updaten. Wanneer we een iteratie bereiken waarbij geen enkele set aangepast wordt, weten we dat dit in de volgende iteratie ook niet zal gebeuren. Bijgevolg kunnen we stoppen. In tabel \ref{tbl:lifenessEvolution} staan de $\succst{n}$, $\usestt{n}$ en $\defstt{n}$ tabellen samen met de nodige iteraties om de $\instt{n}$ en $\outstt{n}$ set uit te rekenen. We kunnen opmerken dat de $\instt{n}$ set dus overeenkomt met de levensduurtabel (zie tabel \ref{tbl:variableLifespanExample}).
\begin{table}[hbt]
\centering
\small{\begin{tabular}{c|ccc|cc|cc|cc}
$n$&$\succst{n}$&$\usestt{n}$&$\defstt{n}$&$\instti{n}{0}$&$\outstti{n}{0}$&$\instti{n}{1}$&$\outstti{n}{1}$&$\instti{n}{2}$&$\outstti{n}{2}$\\\hline
$S_0$&\accol{S_0,S_1}&$\emptyset$&\accol{t_1,t_2}&	$\emptyset$&		\accol{t_1,t_2}&	$\emptyset$&		\accol{t_1,t_2}&	$\emptyset$&		\accol{t_1,t_2}\\
$S_1$&\accol{S_2}&\accol{t_1,t_2}&\accol{t_3,t_4}&	\accol{t_1,t_2}&	\accol{t_3,t_4}&	\accol{t_1,t_2}&	\accol{t_3,t_4}&	\accol{t_1,t_2}&	\accol{t_3,t_4}\\
$S_2$&\accol{S_3}&\accol{t_3,t_4}&\accol{t_5,t_6}&	\accol{t_3,t_4}&	\accol{t_5,t_6}&	\accol{t_3,t_4}&	\accol{t_5,t_6}&	\accol{t_3,t_4}&	\accol{t_5,t_6}\\
$S_3$&\accol{S_4}&\accol{t_5,t_6}&\accol{t_7,t_8}&	\accol{t_5,t_6}&	\accol{t_5,t_7}&	\accol{t_5,t_6}&	\accol{t_5,t_7,t_8}&	\accol{t_5,t_6}&	\accol{t_5,t_7,t_8}\\
$S_4$&\accol{S_5}&\accol{t_5,t_7}&\accol{t_9}&	\accol{t_5,t_7}&	\accol{t_8,t_9}&	\accol{t_5,t_7,t_8}&	\accol{t_5,t_8,t_9}&	\accol{t_5,t_7,t_8}&	\accol{t_5,t_8,t_9}\\
$S_5$&\accol{S_6}&\accol{t_8,t_9}&\accol{t_{10}}&	\accol{t_8,t_9}&	\accol{t_5,t_{10}}&	\accol{t_5,t_8,t_9}&	\accol{t_5,t_{10}}&	\accol{t_5,t_8,t_9}&	\accol{t_5,t_{10}}\\
$S_6$&\accol{S_7}&\accol{t_5,t_{10}}&\accol{t_{11}}&	\accol{t_5,t_{10}}&	\accol{t_{11}}&		\accol{t_5,t_{10}}&	\accol{t_{11}}&		\accol{t_5,t_{10}}&	\accol{t_{11}}\\
$S_7$&\accol{S_0}&\accol{t_{11}}&$\emptyset$&	\accol{t_{11}}&		$\emptyset$&		\accol{t_{11}}&		$\emptyset$&		\accol{t_{11}}&		$\emptyset$
\end{tabular}}
\caption{De evolutie van de $\instt{n}$- en $\outstt{n}$-set op basis van het leidend voorbeeld (zie figuur \ref{fig:asmSqrt})}
\label{tbl:lifenessEvolution}
\end{table}
\paragraph{Nut}Men kan zich terecht afvragen wat het nut is van het opstellen van zo'n tabel. Wanneer welke variabele actief is, is niet zo nuttig. Het interessante aspect zit hem eerder in de onderste rij: het aantal actieve variabelen per toestand. Dit getal specificeert immers hoeveel registers we in die toestand eigenlijk nodig hebben om de variabelen te bewaren. De overige variabelen dienen we immers niet meer op te slaan, ze worden verder nergens meer gebruikt. Vermits we in elke toestand slechts een aantal registers nodig hebben, is het totaal aantal benodigde registers niets anders dan het maximum van de onderste rij over alle toestanden. In het geval van het leidend voorbeeld is dit dus:
\begin{equation}
\begin{array}{l|l}
N_{\small{\mbox{reg.}}}=\max{\left(1,2,2,2,3,3,2,0\right)}=3&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
We kunnen dus onze schakeling implementeren met drie registers op voorwaarde dat een register de waarde van verschillende variabelen op verschillende tijdstippen bijhoudt. Een eenvoudige methode is aan elk van deze drie registers een lijst met variabelen associ\"eren die dit register zal bijhouden. De enige voorwaarde is dat de variabelen in geen enkele toestand allebei actief zijn. Deze methode zal sowieso tot het minimaal aantal registers leiden, maar introduceert een nieuw probleem: we zullen multiplexers voor de ingang van deze registers moeten plaatsen en bovendien lopen we een gelegenheid mis om multiplexers te elimineren die de waarde van een register doorgeven aan een functionele eenheid. Daarom zullen we extra tabellen opstellen.
\paragraph{Functionele-eenhedentabel}
Een tweede tabel die we zullen opstellen is de \termen{functionele-eenhedentabel}. Deze tabel bevat horizontaal de toestanden en verticaal de types functionele eenheden. In elke cel schrijven we in, hoeveel functionele eenheden van het specifieke type we in de specifieke toestand nodig hebben. Zo zien we bijvoorbeeld op figuur \ref{fig:asmSqrt} dat we in toestand $S_2$ zowel een component nodig hebben die het minimum berekent als een component die het maximum berekent. In toestand $S_1$ hebben we twee functionele eenheden nodig die elk de absolute waarde berekenen. Indien we dit voor alle toestanden doen, bekomen we tabel \ref{tbl:functionalunittableexample}.
\begin{table}[hbt]
\centering
\begin{tabular}{c|cccccccc|c}
	&$S_0$	&$S_1$	&$S_2$	&$S_3$	&$S_4$	&$S_5$	&$S_6$	&$S_7$	&$\#$\\\hline
abs	&	&2	&	&	&	&	&	&	&2\\
max	&	&	&1	&	&	&	&1	&	&1\\
min	&	&	&1	&	&	&	&	&	&2\\
shr	&	&	&	&2	&	&	&	&	&2\\
$-$	&	&	&	&	&1	&	&	&	&1\\
$+$	&	&	&	&	&	&1	&	&	&1\\\hline
$\#$	&0	&2	&2	&2	&1	&1	&1	&0	&9\\
\end{tabular}
\caption{Functionele-eenhedentabel van het leidend voorbeeld (zie figuur \ref{fig:asmSqrt})}
\label{tbl:functionalunittableexample}
\end{table}
De enige potenti\"ele moeilijkheid aan het opstellen van deze tabel is de definitie van ``type functionele eenheid''. Men kan zich afvragen of bijvoorbeeld een shift over 3 bits bijvoorbeeld tot hetzelfde type behoort als een shift over 1 bit. In geval van twijfel kan het geen kwaad om een onderscheid te maken (en dus een rij in de tabel te voorzien voor $\mbox{shr1}$ en $\mbox{shr3}$). Als algemene definitie kunnen we stellen dat twee functionele eenheden tot hetzelfde type behoren wanneer we hardware kunnen voorzien die beide operaties op dezelfde component uitvoert. Indien we dus beslissen om de shift te implementeren met behulp van de verbindingen, is een shift over drie bits een ander operatie dan een shift over 1 bit. Wanneer we echter met een schuifregister werken, kunnen beide operaties op hetzelfde schuifregister worden uitgevoerd.
\paragraph{Verbindingentabel, Invoer- en uitvoertabellen}
Een andere tabel is de zogenaamde \termen{verbindingentabel}. Deze tabel bevat horizontaal de variabelen, en verticaal de functionele eenheden (niet verwarren met ``type functionele eenheid''). In een cel plaatsen we een ``I'' wanneer de variabele als invoer dient voor de functionele eenheid, en ``O'' wanneer het resultaat van deze functionele eenheid wordt weggeschreven in de variabele. We gaan er hier altijd van uit dat we in de verschillende toestanden verschillende functionele eenheden gebruiken. Hierdoor ligt het aantal functionele eenheden in deze tabel meestal hoger dan het uiteindelijke aantal functionele eenheden in de implementatie. In deze cursus zullen we de functionele eenheden dan ook nummeren. Zo maken we in toestand $S_1$ gebruik van twee functionele eenheden die de absolute waarde berekenen: abs1 en abs2. Hierbij zorgen $t_1$ en $t_2$ respectievelijk voor de invoer bij abs1 en abs2. De resultaten worden weggeschreven naar respectievelijk $t_3$ en $t_4$. Daarom noteren we in de tabel bij
cellen \brak{t_1,\mbox{abs1}} en \brak{t_2,\mbox{abs2}} een ``I'' en in cellen \brak{t_3,\mbox{abs1}} en \brak{t_4,\mbox{abs2}} een ``O''. Indien we dit voor alle toestanden doen, bekomen we tabel \ref{tbl:connectiontableexample}.
\begin{table}[hbt]
\centering
\begin{tabular}{c|ccccccccccc}
	&$t_1$	&$t_2$	&$t_3$	&$t_4$	&$t_5$	&$t_6$	&$t_7$	&$t_8$	&$t_9$	&$t_{10}$	&$t_{11}$\\\hline
abs1	&I	&	&O	&	&	&	&	&	&	&		&\\
abs2	&	&I	&	&O	&	&	&	&	&	&		&\\
max1	&	&	&I	&I	&O	&	&	&	&	&		&\\
min	&	&	&I	&I	&	&O	&	&	&	&		&\\
shr 3	&	&	&	&	&I	&	&O	&	&	&		&\\
shr 1	&	&	&	&	&	&I	&	&O	&	&		&\\
$-$	&	&	&	&	&I	&	&I	&	&O	&		&\\
$+$	&	&	&	&	&	&	&	&I	&I	&O		&\\
max2	&	&	&	&	&I	&	&	&	&	&I		&O
\end{tabular}
\caption{Verbindingentabel van het leidend voorbeeld (zie figuur \ref{fig:asmSqrt})}
\label{tbl:connectiontableexample}
\end{table}
Als laatste stellen we ook een set \termen{invoer- en uitvoertabellen} op. Deze tabellen worden gedeeltelijk afgeleid uit de verbindingentabel (in dit voorbeeld tabel \ref{tbl:connectiontableexample}). In deze tabel hebben we enkel een onderscheid gemaakt tussen invoer en uitvoer. Sommige functionele elementen hebben echter verschillende ingangen. Door variabelen toe te wijzen aan een specifieke ingang maken we de tabel dus concreter. In sommige gevallen staat deze ingang vast. In toestand $S_4$ trekken we bijvoorbeeld $t_7$ van $t_5$ af. Het spreekt voor zich dat we dus $t_5$ verbinden met de eerste ingang en $t_7$ met de tweede ingang. Bij sommige functionele eenheden kunnen we echter kiezen. In dat geval is de operatie die door de functionele eenheid wordt uitgevoerd ``commutatief''. Formeler kunnen we stellen dat een functie $f$ commutatief is indien:
\begin{equation}
f\left(\vec{x}\right)=f\left(\sigma\vec{x}\right)\mbox{ voor elke permutatie $\sigma$}
\end{equation}
Concrete voorbeelden van zulke operaties zijn optellen, minimum en maximum. Sommige functionele eenheden hebben meer dan twee ingangen. Ook hier kan er commutativiteit spelen. Soms is de operatie volledig commutatief en is dus elke permutatie geldig. In andere gevallen is er sprake van gedeeltelijke commutativiteit en wordt slechts een subset van permutaties ondersteund. Het toewijzen van ingangen kunnen we natuurlijk willekeurig doen. Toch loont het de moeite om dit op een intelligentere manier te doen. In het leidend voorbeeld (zie figuur \ref{fig:asmSqrt}) zien we bijvoorbeeld dat we zowel in toestand $S_2$ en $S_6$ een maximum berekenen. De kans is relatief groot, dat we in de toekomst deze twee bewerkingen op dezelfde functionele eenheid zullen uitvoeren. In toestand $S_2$ berekenen we $\max\left(t_3,t_4\right)$, in toestand $S_6$ $\max\left(t_5,t_{10}\right)$. Indien we echter in toestand $S_6$, $\max\left(t_5,t_3\right)$ hadden willen uitrekenen, was het zinvol geweest om deze operatie aan te passen
naar $\max\left(t_3,t_5\right)$. Indien we dan later de twee functionele eenheden zouden samenvoegen, dienen we geen multiplexer voor de eerste ingang te plaatsen. In het algemeen geldt meestal volgende regel:
\begin{quote}
Wijs dezelfde variabele zoveel mogelijk aan dezelfde ingangen en uitgangen toe.
\end{quote}
Bij wijze van voorbeeld zullen we deze regel toepassen op het leidend voorbeeld. Hierbij zijn variabelen $t_1$,$t_2$, $t_6$ triviaal: ze worden uitsluitend in functionele eenheden met maar \'e\'en ingang gebruikt. Daarom kennen we dus deze ingangen toe aan:
\begin{equation}
\begin{array}{lr}
\left(\left\langle t_1,\mbox{abs1}\right\rangle,\left\langle t_2,\mbox{abs2}\right\rangle,\left\langle t_6,\mbox{shr 1}\right\rangle\right)\mapsto\left(I_1,I_1,I_1\right)&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
Vervolgens kunnen we $t_5$ en $t_7$ toewijzen: beide variabelen zijn immers betrokken in een aftrekking. In deze bewerking is $t_5$ verplicht gebonden aan ingang $I_1$, $t_7$ is gebonden aan ingang $t_7$:
\begin{equation}
\begin{array}{lr}
\left(\left\langle t_5,-\right\rangle,\left\langle t_7,-\right\rangle\right)\mapsto\left(I_1,I_2\right)&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
We kijken eerst of we de toewijzingen van $t_5$ en $t_7$ kunnen uitbreiden. $t_5$ is verder nog betrokken in $\mbox{shr 3}$ en $\mbox{max2}$, dit zijn beide commutatieve functionele eenheden. We zullen dus ook voor deze operaties $t_5$ toekennen aan ingang $I_1$. $t_7$ is in geen enkele andere operatie betrokken. We vatten samen:
\begin{equation}
\begin{array}{lr}
\left(\left\langle t_5,\mbox{shr 3}\right\rangle,\left\langle t_5,\mbox{max2}\right\rangle\right)\mapsto\left(I_1,I_1\right)&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
Nu we $t_7$ aan deze functionele eenheden hebben toegewezen, kunnen we de andere variabelen die in deze operaties betrokken zijn toewijzen: $\mbox{max2}$ heeft een twee ingangen en aan de andere ingang dient $t_{10}$ te staan:
\begin{equation}
\begin{array}{lr}
\left(\left\langle t_{10},\mbox{max2}\right\rangle\right)\mapsto\left(I_2\right)&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
Voor de overige variabelen hebben we niet meteen een aanwijzing. Daarom zullen we deze eenvoudigweg aan een ingang toewijzen. Zo is $t_3$ betrokken in $\mbox{max1}$ en $\mbox{min}$. Bij beide operaties kennen we $t_3$ toe aan $I_1$. Een logisch gevolg is dat $t_4$ toegewezen wordt aan ingang $I_2$. $t_8$ wijzen we ook arbitrair toe aan $I_1$ voor de $+$ operatie, bijgevolg wijzen we $t_9$ toe aan $I_2$.
\begin{equation}
\begin{array}{lr}
\left(\left\langle t_3,\mbox{max1}\right\rangle,\left\langle t_3,\mbox{min}\right\rangle,\left\langle t_4,\mbox{max1}\right\rangle,\left\langle t_4,\mbox{min}\right\rangle,\left\langle t_8,+\right\rangle,\left\langle t_9,+\right\rangle\right)\mapsto\left(I_1,I_1,I_2,I_2,I_1,I_2\right)&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
Vermits elke eenheid maar \'e\'en uitgang heeft kunnen we ook deze aspecten triviaal oplossen:
\begin{equation}
\begin{array}{lr}
\left(\begin{array}{c}
\left\langle t_3,\mbox{abs1}\right\rangle\\
\left\langle t_4,\mbox{abs2}\right\rangle\\
\left\langle t_5,\mbox{max1}\right\rangle\\
\left\langle t_6,\mbox{min}\right\rangle\\
\left\langle t_7,\mbox{shr 3}\right\rangle\\
\left\langle t_8,\mbox{shr 1}\right\rangle\\
\left\langle t_9,-\right\rangle\\
\left\langle t_{10},+\right\rangle\\
\left\langle t_{11},\mbox{max2}\right\rangle
\end{array}\right)\mapsto\left(\begin{array}{c}
O_1\\O_1\\O_1\\O_1\\O_1\\O_1\\O_1\\O_1\\O_1
\end{array}\right)&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
Indien we nu alle voorgaande informatie samenvatten in een tabel, bekomen we de invoer- en uitvoertabellen zoals in tabel \ref{tbl:inputtableexample}.
\begin{table}[hbt]
\centering
\small{\begin{tabular}{c|cccccc|cccc|ccccccccc}
	&\multicolumn{6}{c|}{\bf In $I_1$}		&\multicolumn{4}{c|}{\bf In $I_2$}&\multicolumn{9}{c}{\bf Out $O_1$}\\
	&$t_1$	&$t_2$	&$t_3$	&$t_5$	&$t_6$	&$t_8$	&$t_4$	&$t_7$	&$t_8$	&$t_9$	&$t_3$	&$t_4$	&$t_5$	&$t_6$	&$t_7$	&$t_8$	&$t_9$	&$t_{10}$&$t_{11}$\\\hline
abs1	&$\bullet$&	&	&	&	&	&	&	&	&	&$\bullet$&	&	&	&	&	&	&	&\\
abs2	&	&$\bullet$&	&	&	&	&	&	&	&	&	&$\bullet$&	&	&	&	&	&	&\\
max1	&	&	&$\bullet$&	&	&	&$\bullet$&	&	&	&	&	&$\bullet$&	&	&	&	&	&\\
min	&	&	&$\bullet$&	&	&	&$\bullet$&	&	&	&	&	&	&$\bullet$&	&	&	&	&\\
shr 3	&	&	&	&$\bullet$&	&	&	&	&	&	&	&	&	&	&$\bullet$&	&	&	&\\
shr 1	&	&	&	&	&$\bullet$&	&	&	&	&	&	&	&	&	&	&$\bullet$&	&	&\\
$-$	&	&	&	&$\bullet$&	&	&	&$\bullet$&	&	&	&	&	&	&	&	&$\bullet$&	&\\
$+$	&	&	&	&	&	&$\bullet$&	&	&$\bullet$&	&	&	&	&	&	&	&	&$\bullet$&\\
max2	&	&	&	&$\bullet$&	&	&	&	&	&$\bullet$&	&	&	&	&	&	&	&	&$\bullet$
\end{tabular}}
\caption{Invoer- en uitvoertabellen van het leidend voorbeeld (zie figuur \ref{fig:asmSqrt})}
\label{tbl:inputtableexample}
\end{table}
We zetten hier de variabelen op de horizontale as, en de functionele eenheden op de verticale as. Variabelen die aan geen enkele functionele eenheid bijdragen hebben we weggelaten uit de kolommen: bijvoorbeeld variabele $t_1$ is nergens verbonden met een ingang $I_2$, bijgevolg staat deze ook niet in dat deel van de tabel. Het weglaten van deze kolommen is vanzelfsprekend optioneel.
\paragraph{Onsamenvoegbaarheid en Prioriteit}
Nu we deze tabellen hebben opgesteld, kunnen we met het echte werk beginnen: het samenvoegen van registers. Een eerste probleem die we moeten oplossen is bepalen wanneer twee variabelen eenzelfde register kunnen delen. Allereerst kunnen we opmerken dat een variabele eigenlijk niet gebonden is aan een register: we zouden bijvoorbeeld dezelfde variabele in de ene toestand in register 1 kunnen bewaren en de andere toestand in register 2. Dit kan er toe leiden dat we inderdaad tot zeer compacte configuraties komen, maar in de meeste gevallen, maakt het het optimaliseren hopeloos ingewikkeld. Daarom gebruiken we doorgaans de vuistregel:
\begin{quote}
We kennen een variabele toe aan strikt \'e\'en register.
\end{quote}
De vraag blijft in welke omstandigheden we twee variabelen niet in hetzelfde register kunnen opslaan. Een algemene regel is:
\begin{quote}
Twee variabelen kunnen niet in hetzelfde register worden opgeslagen indien de twee variabelen leven in \'e\'en of meer toestanden.
\end{quote}
We kunnen dit formaliseren met behulp van de sets die we berekend hebben in het deel over de lifeness analyse:
\begin{equation}
\forall t_i,t_j\in\mbox{Variabelen}, t_i\neq t_j:\mbox{NietSamenvoegen}\left(t_i,t_j\right)\Leftrightarrow\left(\exists s\in S: t_i\in\instt{s}\wedge t_j\in\instt{s}\right)
\end{equation}
Op basis van deze definitie kunnen we de volledige relatie berekenen van variabelen die we kunnen niet kunnen samenvoegen:
\begin{equation}
\begin{array}{ccc}
\brak{t_1,t_2}&\brak{t_3,t_4}&\brak{t_5,t_6}\\
\brak{t_5,t_7}&\brak{t_5,t_8}&\brak{t_5,t_9}\\
\brak{t_5,t_{10}}&\brak{t_7,t_8}&\brak{t_8,t_9}
\end{array}
\label{eqn:asmSqrtIncompatible}
\end{equation}
Toegegeven dat er negen paren van variabelen botsen, maar dit geeft ruimte voor een groot aantal manieren om variabelen samen te voegen. De schaduwzijde van het feit dat veel configuraties mogelijk zijn, is dat er een serieuze kans bestaat dat we een foute configuratie uitkiezen. Om meer gericht op zoek te gaan naar welke variabelen we kunnen samennemen, zullen we een heuristiek ontwikkelen: een functie die aangeeft in welke mate het de moeite loont om twee variabelen samen te nemen. Deze functie heeft de signatuur $h:V\times V\rightarrow\mathbb{N}$, waarbij $V$ de set van variabelen voorstelt, en $\mathbb{N}$ de set van natuurlijke getallen (met 0). Een interessante metriek kunnen we opstellen op basis van de invoer- en uitvoertabellen (zie tabel \ref{tbl:inputtableexample}). De heuristiek defini\"eren we dan als:
\begin{quote}
Het aantal in- en uitgangen die de twee variabelen gemeenschappelijk hebben met elkaar bij functionele eenheden die het potentieel hebben om samengenomen te worden.
\end{quote}
De argumentatie is de volgende: indien we effectief functionele eenheden samennemen, zal dit er meestal toe leiden dat verschillende registers naar eenzelfde ingang van deze samengestelde functionele eenheid worden geleid. Indien alle variabelen die deze ingang gemeenschappelijk hebben, echter in hetzelfde register opgeslagen zitten, zijn deze multiplexers overbodig. Formeel kunnen we deze functie dus defini\"eren als:
\begin{equation}
\forall t_i,t_j,t_i\neq t_j:\mbox{prioriteit}\left(t_i,t_j\right)=\#\left\{\begin{array}{l|l}
&\forall\brak{t_i,f_a,c},\brak{t_j,f_b,c}\in\mbox{Verbindingen}, a<b,\\
\brak{f_a,f_b,c}&\exists F\in\mbox{SamenvoegbareFunctioneleEenheden},\\
&f_a,f_b\in F
\end{array}\right\}
\label{eqn:priorityMergingVariables}
\end{equation}
Ook deze definitie zullen we toepassen op leidend voorbeeld. We verwachten dat we $\mbox{max1}$ en $\mbox{max 2}$ kunnen samennemen alsook $+$ en $-$. Daarom wordt de set \mbox{SamenvoegbareFunctioneleEenheden} gelijk aan:
\begin{equation}
\begin{array}{ll}
\mbox{SamenvoegbareFunctioneleEenheden}=\accol{\accol{\mbox{max1},\mbox{max2}},\accol{+,-}}&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
De \mbox{Verbindingen}-set hebben we eigenlijk al opgesteld en kunnen we bekijken in de in- en uitvoertabellen (zie tabel \ref{tbl:inputtableexample}). De set bestaat uit tuples met als volgorde: \brak{\mbox{variable},\mbox{functionele eenheid},\mbox{verbinding}}. De \mbox{Verbindingen} bevat dus onder andere de volgende elementen:
\begin{equation}
\begin{array}{ll}
\mbox{Verbindingen}=\accol{\brak{t_1,\mbox{abs1},I_1},\brak{t_3,\mbox{abs1},O_1},\brak{t_2,\mbox{abs2},I_1},\brak{t_4,\mbox{abs1},O_1},\ldots}&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
??
\begin{equation}
\begin{array}{lll}
\mbox{prioriteit}\brak{t_3,t_5}=1&\mbox{prioriteit}\brak{t_4,t_{10}}=1&\mbox{prioriteit}\brak{t_5,t_8}=1\\
\mbox{prioriteit}\brak{t_5,t_{11}}=1&\mbox{prioriteit}\brak{t_7,t_9}=1&\mbox{prioriteit}\brak{t_9,t_{10}}=1
\end{array}
\label{eqn:asmSqrtPriority}
\end{equation}
\paragraph{Opstellen van een compatibiliteitsgraaf}
Met de informatie uit de vorige paragraaf kunnen we een \termen{compatibiliteitsgraaf} opstellen. Een compatibiliteitsgraaf is een graaf waarbij de \termen{knopen} (ofwel \termen{nodes}) entiteiten voorstellen die al dan niet compatibel met elkaar zijn (in dit geval dus de variabelen). Verder bevat de graaf twee soorten bogen:
\begin{enumerate}
 \item \termen{Incompatibiliteitsranden}: dit zijn bogen tussen twee knopen die onverenigbaar met elkaar zijn. In het geval van de compatibiliteitsgraaf die we hier aan het opstellen zijn, zijn dit dus de paren uit vergelijking (\ref{eqn:asmSqrtIncompatible}). We stellen de bogen voor met stippellijnen.
 \item \termen{Prioriteitsranden}: dit zijn bogen tussen twee knopen die net goed verenigbaar zijn, en die dus waarschijnlijk een belangrijk voordeel opleveren wanneer ze samengevoegd worden. We hebben deze bogen berekend met de prioriteitsfunctie uit vergelijking (\ref{eqn:priorityMergingVariables}). In dit geval komt dit dus neer op de bogen in vergelijking (\ref{eqn:asmSqrtPriority}). We stellen de bogen voor met volle lijnen. Bovendien hebben de bogen natuurlijk een label: de waarde van de prioriteit.
\end{enumerate}
Een uitgewerkte compatibiliteitsgraaf voor het leidend voorbeeld staat op figuur \ref{fig:asmSqrtCompatibilityGraph} (de gevulde gebieden laten we voorlopig nog buiten beschouwing). De bedoeling van een compatibiliteitsgraaf is om een grafisch hulpmiddel te bieden om de variabelen optimaal samen te voegen. Op basis van de graaf moeten we op zoek gaan naar een \termen{max-cut graph partitioning}: het opdelen van de graaf in een minimaal aantal groepen zodat het totale gewicht van alle groepen samen maximaal is. Hierbij is het \termen{totale gewicht} van een groep de som van alle prioriteitsranden waarbij beide knopen in de groep zitten. De partitionering van de graaf dient verder volledig te zijn: elke knoop dient tot juist \'e\'en groep te behoren. Het bekomen van een max-cut graph partitioning is een niet-triviaal probleem en valt niet onder deze cursus. We zullen in de volgende paragraaf een methode ontwikkelen waarmee we grafisch tot een redelijke partitionering zullen komen.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[auto,node distance=2cm]
\node[compatibilitynode] (t1) {$t_1$};
\node[compatibilitynode,below of=t1] (t2) {$t_2$};
\node[compatibilitynode,right of=t1] (t3) {$t_3$};
\node[compatibilitynode,below of=t3] (t4) {$t_4$};
\node[compatibilitynode,right of=t3] (t11) {$t_{11}$};
\node[compatibilitynode,below of=t11] (t10) {$t_{10}$};
\node[compatibilitynode,right of=t11] (t5) {$t_5$};
\node[compatibilitynode,below of=t5] (t9) {$t_9$};
\node[compatibilitynode,right of=t9] (t7) {$t_7$};
\node[compatibilitynode,right of=t7] (t8) {$t_8$};
\node[compatibilitynode,above of=t8] (t6) {$t_6$};
\foreach \a/\b/\o in {t1/t2/,t3/t4/,t5/t10/,t5/t9/,t5/t7/,t5/t8/,t5/t6/,t7/t8/,t8/t9/bend left} {
  \path [thick,dashed] (\a) edge [\o] (\b);
}
\foreach \a/\b/\t/\o in {t3/t5/1/bend left,t11/t5/1/,t4/t10/1/,t10/t9/1/,t9/t7/1/} {
  \path [thick] (\a) edge [\o] node {\t} (\b);
}
\begin{pgfonlayer}{bg}
\foreach \tim/\off/\vars in {1/t5/,1/t7/,1/t8/,2/t5/{t3,t11},2/t8/{t6,t8},2/t7/{t4,t9,t10},3/t5/{t1,t3,t11},3/t7/{t2,t4,t9,t10}} {
  \node[fit=(\off),inner sep=3*\tim pt] (fitnode) {};
  \foreach \var in \vars {
    \node[fit=(\var),inner sep=3*\tim pt] (thick\var) {};
    \node[fit=(fitnode) (thick\var),inner sep=0pt] (fitnode) {};
  }
  \node [compatibilitygroup,fit=(fitnode)] {};
}
\end{pgfonlayer}
\end{tikzpicture}
\caption{De evolutie van de compatibiliteitsgraaf voor de variabelen.}
\figlab{asmSqrtCompatibilityGraph}
\end{figure}
\paragraph{Partitioneren van de compatibiliteitsgraaf}
Het bekomen van een optimale partitionering zullen we in drie stappen bewerkstelligen:
\begin{enumerate}
 \item Zoek een \termen{kliek}: een kliek is een groep knopen waarbij er tussen elke twee knopen een incompatibiliteitsrand zit. In het leidend voorbeeld kunnen we dus een kliek beschouwen met de knopen $\accol{\accol{t_5},\accol{t_7},\accol{t_8}}$. Deze variabelen vormen de oorsprong van de partities.
 \item \label{item:partitioningCompatibilityStepB} Voeg knopen toe op basis van de prioriteitsranden: we gaan de prioriteitsranden van groot naar klein af. Telkens wanneer er juist \'e\'en van de knopen al toegevoegd is aan een partitie zullen we proberen de andere knoop ook aan de partitie toe te voegen. Dit kan enkel wanneer er geen incompatibiliteitsrand tussen de knoop van de partitie en de knoop die we willen toevoegen zit. Telkens wanneer we erin slagen om zo'n knoop toe te voegen, overlopen we alle bogen opnieuw. We stoppen wanneer we bij geen enkele boog meer een knoop kunnen toevoegen. Indien twee bogen hetzelfde gewicht hebben, is de volgorde arbitrair. Toegepast op het voorbeeld kunnen we dus de volgorde volledig zelf kiezen. We kiezen de volgorde op basis van de knoop met de laagste index. In het geval beide bogen dezelfde kleinste knoop gemeenschappelijk hebben, dient de andere knoop als ``tiebreak''. We behandelen de knopen dus in volgende volgorde:
\begin{equation}
\begin{array}{ll}
\brak{t_3,t_5,1}<\brak{t_4,t_{10},1}<\brak{t_5,t_{11},1}<\brak{t_7,t_9,1}<\brak{t_9,t_{10},1}&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
Vervolgens beginnen we met toevoegen. De eerste boog die aan de voorwaarden voldoet is $\brak{t_3,t_5,1}$, we voegen dus $t_3$ toe aan de partitie van $t_5$. Daarna volgt $t_{11}$ die eveneens aan $t_5$ wordt toegevoegd. De volgende bogen zijn $\brak{t_7,t_9,1}$, $\brak{t_9,t_{10},1}$ en $\brak{t_4,t_{10},1}$. We voegen dus $t_9$, $t_{10}$ en $t_4$ toe aan de partitie van $t_7$. Hiermee hebben we alle prioriteitsranden met succes kunnen oplossen. De partitie achter deze stap is dan ook: $\accol{\accol{t_3,t_5,t_{11}},\accol{t_4,t_7,t_9,t_{10}},\accol{t_8}}$.
 \item \label{item:partitioningCompatibilityStepC} Wijs de overige knopen toe: de laatste stap bestaat er uit om de knopen toe te wijzen die nog vrij zijn. Dit kunnen we arbitrair doen: we voegen een knoop toe aan een partitie naar keuze. Dit kan zolang er geen incompatibiliteitsrand tussen een knoop in de partitie en de knoop die we willen toevoegen zit. Indien dit wel zo is, zullen we een andere partitie moeten kiezen. In het geval voor iedere partitie er een incompatibiliteitsrand bestaat, richt de knoop zijn eigen partitie op. Vervolgens kunnen we weer naar stap \ref{item:partitioningCompatibilityStepB} terugkeren om eventuele prioriteitranden op te lossen met de nieuwe partitie, om vervolgens weer stap \ref{item:partitioningCompatibilityStepC} uit te voeren. Zo zullen we in het leidend voorbeeld $t_1$ aan de partitie van $t_5$ toevoegen. $t_2$ kunnen we niet aan diezelfde partitie toevoegen, want tussen $t_1$ en $t_2$ ligt immers een incompatibiliteitsrand. Daarom voegen we $t_2$ toe aan de partitie van $t_7$. Tot slot dienen we nog $t_6$ toe te voegen. Hiervoor hebben we de keuze tussen de partities van $t_7$ en $t_8$. We kiezen hier voor de partitie van $t_8$, maar het alternatief is ook correct. Na deze stap hebben we alle knopen toegewezen en is de partitie de volgende:
\begin{equation}
\begin{array}{ll}
\accol{\accol{t_1,t_3,t_5,t_{11}},\accol{t_2,t_4,t_7,t_9,t_{10}},\accol{t_6,t_8}}&\mbox{(leidend voorbeeld)}
\end{array}
\end{equation}
\end{enumerate}
\paragraph{Minimalisering}
\begin{figure}[hbt]
\centering
\begin{sprocessor}[1.25/4.6/1.3/1.4/0.25/0.8]{t1/{$t_1$}/1/4,t2/{$t_2$}/1/5,t6/{$t_6$}/1/2}{abs1/$\abs$,abs2/$\abs$,max1/$\max$,min/$\min$,shr3/$\shrcmd3$,shr1/$\shrcmd1$,sub/$-$,add/$+$,max2/$\max$}{}
\sprbtf{t1}{abs1}{0};
\sprbtf{t2}{abs2}{-0.2};
\sprbtf{t1}{max1}{-0.3};
\sprbtf{t2}{max1}{0.3};
\sprbtf{t1}{min}{0};
\sprbtf{t2}{min}{0.3};
\sprbtf{t1}{shr3}{0};
\sprbtf{t6}{shr1}{0};
\sprbtf{t1}{sub}{-0.2};
\sprbtf{t2}{sub}{0.2};
\sprbtf{t6}{add}{-0.2};
\sprbtf{t2}{add}{0.2};
\sprbtf{t1}{max2}{-0.3};
\sprbtf{t2}{max2}{0};
\spfutr{max2}{t1}{0};
\spfutr{add}{t2}{0};
\spfutr{sub}{t2}{1};
\spfutr{shr1}{t6}{0};
\spfutr{shr3}{t2}{2};
\spfutr{min}{t6}{1};
\spfutr{max1}{t1}{1};
\spfutr{abs2}{t2}{3};
\spfutr{abs1}{t1}{2};
\end{sprocessor}
\caption{Implementatie van het datapad van het leidend voorbeeld na het minimaliseren van de variabelen.}
\figlab{datapad-minimal-variables}
\end{figure}
\figref{datapad-minimal-variables} toont de implementatie van het datapad nadat we de variabelen hebben gereduceerd. De figuur toont drie registers. Elke registers krijgt de naam van een van de element van de partitie\footnote{In werkelijkheid vertegenwoordigt het register alle variabelen in de partitie. We hadden het register $t_1$ dus ook bijvoorbeeld $t_3$ kunnen noemen.}. Vermits het aantal registers op drie staat, zal ook het aantal verbindingen van de registers naar de functionele eenheden gereduceerd worden. Een register vertegenwoordigt een groep variabelen, bijgevolg trekken we een lijn van een register naar alle functionele eenheden die invoer uitlezen uit minstens \'e\'en van de vertegenwoordigde variabelen. De verbinding gebeurt uiteraard met de relevante invoerlijnen. Bijvoorbeeld de min component berekent het minimum tussen $t_3$ en $t_4$ respectievelijk op ingang 1 en 2. Omdat $t_3$ vertegenwoordigd wordt door het register $t_1$, verbinden we dit register met de eerste ingang. $t_4$ wordt dan weer vertegenwoordigd door register $t_2$. Bijgevolg verbinden we dit register met de tweede ingang.
\paragraph{}
Het samenvoegen van registers levert ook nog een ander probleem op: wat doet men met de uitvoer van de functionele eenheden. In \figref{datapad-generic} komt de uitvoer van een functionele eenheid altijd in \'e\'en register terecht. Omdat we hier de registers samenvoegen in drie algemene registers lukt dit niet. We kunnen de uitvoer van de functionele eenheden verbinden met het register die de relevante variabele vertegenwoordigt. We kunnen echter geen uitgangen combineren. Dit kan tot kortsluiting leiden en bovendien is het onduidelijk welke uitvoer er in dat geval in het register zou worden ingelezen. We kunnen dit probleem oplossen met behulp van multiplexers. Bij iedere register waar meerdere uitgangen van functionele eenheden toekomen plaatsen we een multiplexer met voldoende data-ingangen. De uitgang van de multiplexer verbinden we vervolgens met het register. Ten slotte zijn de selectie-ingangen van de multiplexer de verantwoordelijkheid van de controller. De controller dient bijgevolg te bepalen uit welke functionele eenheid de data moet worden ingelezen die in het register zal worden geplaatst.
\paragraph{}
Wanneer we een multiplexer introduceren, zal de controller extra logica moeten voorzien om de selectie-ingangen te besturen. Anderzijds verdwijnt de logica voor de set- en reset-ingangen van de registers die wegvallen. Ook moet de we logica voorzien voor de set- en reset-ingangen van de gegroepeerde registers. In deze paragraaf beschrijven we kort hoe we de logica bepalen voor de selectie-ingangen van de multiplexers. Als voorbeeld nemen we register $t_1$. Een eerste aspect is het voorzien van de set- en reset-ingangen, indien \'e\'en van de oorspronkelijke registers zo'n ingang voorzag. Dus voor het uiteindelijke register $t_1$ moeten we enkel een set-ingang voorzien (verbonden met de controller). Dit komt omdat de originele registers voor $t_1$, $t_3$, $t_5$ en $t_{11}$ uitsluitend een set-ingang voorzien. Een tweede aspect is wanneer set- en reset-ingangen actief moeten worden. Omdat een samengevoegd register alle oorspronkelijke registers vertegenwoordigt, moeten de set- en reset-ingangen actief zijn, wanneer dit bij minstens \'e\'en van de originele registers het geval was. Concreet laadt het originele register $t_1$ een waarde in, in toestand $0$, $t_3$ doet dit in toestand $1$, $t_5$ in toestand $2$ en $t_{11}$ ten slotte in toestand $6$. Bijgevolg moet de set-ingang van het samengevoegde register $t_1$ dus actief zijn in toestanden $0$, $1$, $2$ en $6$. In alle andere toestand moet het signaal laag zijn. Hetzelfde geldt voor (hier niet aanwezige) reset-ingangen. Indien we de controller dus minimaal willen aanpassen kunnen we een OR-poort plaatsen die als invoer de uitvoer naar de register neemt en zelf het signaal op de set- en reset-ingangen van de samengevoegde registers bepaalt. In de praktijk zal het opnieuw synthetiseren van de logica goedkoper zijn. Een tweede type logica die we moeten synthetiseren is het signaal op de selectie-ingangen. We weten dat het originele register $t_1$ in toestand $0$ data moest inladen die op dat moment op data-ingang $A$ van de processor staat. Deze data staat op $11$ bij de multiplexer. Bijgevolg moet op dat moment ook deze waarde aan de selectie-ingangen van multiplexer staan. Analoog staat in toestand $1$, $10$ op de selectie-ingangen. In toestand $2$ is het signaal $01$, en in toestand $6$ is dit $00$. In de andere toestanden moeten we natuurlijk ook een signaal op de selectie-ingangen zetten. Omdat de waarde die de multiplexer doorgeeft toch niks uitmaakt, kunnen we hiervoor gebruik maken van don't cares. Meestal maakt men multiplexers waarbij het aantal data-ingangen machten van twee is. Wanneer we er echter minder data-ingangen gebruikt worden, kunnen we op verschillende ingangen dezelfde data aanleggen. In zo'n situatie kunnen we dan kiezen tussen \'e\'en van de data-ingangen die het signaal aanlegt. Dit leidt dus tot meer don't cares en bijgevolg een mogelijk nog compactere implementatie. Zo zien we dat bij de multiplexer van $t_2$ we meermaals data-ingang $B$ aanleggen. Dit zorgt ervoor dat behalve de hoogste bit, we vrije keuze hebben welke waarde wordt aangelegd. \tblref{datapad-minimal-variables-controller} geeft de stuursignalen van alle componenten weer.
\begin{table}[hbt]
\centering
\begin{tabular}{c|ccc|cccc|cc}
Toestand&$a$&$b$&$c$&$d$&$e$&$f$&$g$&$h$&$i$\\\hline
0&1&1&1&1&-&-&1&0&-\\
1&1&0&1&1&1&1&0&0&-\\
2&1&1&0&0&-&-&-&1&1\\
3&0&-&-&1&0&1&0&1&0\\
4&0&-&-&1&1&0&0&0&-\\
5&0&-&-&1&0&0&0&0&-\\
6&1&0&0&0&-&-&-&0&-\\
7&0&-&-&0&-&-&-&0&-
\end{tabular}
\caption{Stuursignalen voor de verschillende toestanden na samenvoegen van registers.}
\tbllab{datapad-minimal-variables-controller}
\end{table}
\paragraph{}
Het samenvoegen van registers gaat dus gepaard met de introductie van multiplexers en extra combinatorische logica in de controller. Dit is een van de redenen waarom het moeilijk is om te voorspellen of een optimalisatie effectief tot goedkopere implementaties zal leiden.
\subsubsection{Bewerkingen samenvoegen (``functional-unit sharing'')}
In het leidend voorbeeld zien we verschillende functionele eenheden. Sommige van deze functionele eenheden voeren echter dezelfde bewerking in een andere toestand uit. Het is mogelijk goedkoper deze bewerkingen met dezelfde functionele eenheid uit te voeren. Anderzijds zijn sommige functionele eenheden zeer gelijkaardig. In \sscref{??} hebben we de implementatie van een schakeling besproken die getallen kan optellen en aftrekken. Functionele eenheden die gelijkaardige bewerkingen uitvoeren kunnen meestal worden samengevoegd in schakelingen die beide bewerkingen kunnen uitvoeren, en waarbij de resulterende schakeling goedkoper is dan de som van de twee aparte functionele eenheden. Het samenvoegen van functionele eenheden wordt \termen{functional-unit sharing} genoemd omdat een functionele eenheid tussen verschillende toestanden wordt gedeeld.
\paragraph{Gelijkaardige bewerkingen samenvoegen}
Een probleem in dit proces is dat het samenvoegen van twee functionele eenheden in een nieuwe functionele eenheid geen sinecure is, en meestal enige ervaring vereist. We zullen in doorheen deze subsectie verschillende functionele eenheden combineren om de lezer een notie te geven over de principes hierachter. Meestal zoekt men naar logica die beide functionele eenheden gemeenschappelijk hebben. Daarna moeten extra ingangen bepalen welke bewerking wordt uitgevoerd door de overige logica aan te sturen.
\paragraph{Compatibiliteitsgrafe}
Eenmaal we de kostprijs berekend hebben van het samenvoegen van verschillende functionele eenheden, dienen we een keuze te maken welke bewerkingen we effectief zullen samenvoegen. Hiervoor zullen we dezelfde werkwijze met de compatibiliteitsgrafe hanteren. In de compatibiliteitsgrafe hebben de componenten de volgende betekenis:
\begin{enumerate}
 \item Knopen: de knopen stellen bewerkingen voor, dus de originele functionele eenheden.
 \item Incompatibiliteitsranden: twee bewerkingen zijn niet verenigbaar, wanneer ze een toestand gemeenschappelijk hebben waarin ze beiden actief zijn.
 \item Prioriteitsranden: twee of meer\footnote{Soms kan men drie of meer bewerkingen samenvoegen in \'e\'en nieuwe functionele eenheid.} bewerkingen die men kan samenvoegen delen een prioriteitsrand. Het gewicht is de winst in kostprijs (transistors of logische blokken) bij het samenvoegen.
\end{enumerate}
\figref{compatibilitygraph-functionals-original} toont de initi\"ele compatibiliteitsgraaf met de incompatibiliteitsranden.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[auto,node distance=2cm]
\node[compatibilitynode] (f1) {abs1};
\node[compatibilitynode,below of=f1] (f2) {abs2};
\node[compatibilitynode,right of=f1] (f3) {min};
\node[compatibilitynode,below of=f3] (f4) {max1};
\node[compatibilitynode,right of=f4] (f5) {max2};
\node[compatibilitynode,right of=f5] (f9) {+};
\node[compatibilitynode,above of=f9] (f8) {-};
\node[compatibilitynode,right of=f8] (f6) {shr 3};
\node[compatibilitynode,right of=f9] (f7) {shr 1};
\foreach \a/\b/\o in {f1/f2/,f3/f4/,f6/f7/} {
  \path [thick,dashed] (\a) edge [\o] (\b);
}
\end{tikzpicture}
\caption{Oorspronkelijke compatibiliteitsgrafe bij het samenvoegen van bewerkingen.}
\figlab{compatibilitygraph-functionals-original}
\end{figure}
\paragraph{Multiplexers}
Wanneer twee functionele eenheden worden samengevoegd, delen ze een deel van de ingangen. Het is mogelijk dat de ingangen van beide functionele eenheden verbonden zijn met andere registers. In dat geval moeten extra multiplexers bepalen welk register de invoer levert voor de functionele eenheid. Multiplexers brengen echter een extra kost met zich mee. Zelfs wanneer de samengestelde functionele eenheid goedkoper is, zal de resulterende schakeling daarom niet noodzakelijk goedkoper zijn. De extra kosten die met het invoeren of aanpassen van multiplexers gepaard gaan, moeten dus ook in rekening worden gebracht. \figref{minimal-functionals-multiplexer} illustreert dit concept. Aanvankelijk zijn er twee functionele eenheden $\mbox{FU1}$ en $\mbox{FU2}$, elk met eigen in- en uitgangen. Wanneer we de functionele eenheden in een nieuwe functionele eenheid $\mbox{FU1\&2}$ onderbrengen, introduceren we twee multiplexers. Ook de controller zal extra stuursignalen moeten implementeren: het bedienen van de multiplexers vereist extra logica. Soms zal de samengestelde functionele eenheid ook extra stuursignalen vereisen. Dit is het geval wanneer de twee functionele eenheden niet dezelfde bewerking uitvoeren, en de controller dus moet bepalen welke opdracht zal worden uitgevoerd. Indien sommige registers dezelfde zijn (bijvoorbeeld $A$ en $C$ op de figuur), kunnen we multiplexers weglaten.
\importtikzfigure{minimal-functionals-multiplexer}{Minimaliseren van bewerkingen introduceert multiplexers.}
\paragraph{Minimum en Maximum bewerking}
In het leidend voorbeeld berekenen we het minimum en maximum. Deze schakelingen hebben we niet gedefinieerd in \chpref{combinatoric}. De schakeling is echter vrij eenvoudig: we berekenen eerst het verschil tussen de twee getallen. Indien het verschil positief is, zullen we met behulp van multiplexers het tweede getal teruggeven, in het andere geval geven we de waarde terug op de eerste invoer. In het geval van het maximum draaien we de multiplexer om. Een schematische voorstelling staat op \figref{minimal-functionals-minimum}
\begin{figure}[hbt]
\centering
\subfigure[Minimum]{\importtikz{minimal-functionals-minimum}}
\subfigure[Carry-logica]{\importtikz{minimal-functionals-carry}}
\subfigure[Minimax]{\importtikz{minimal-functionals-minimax}}
\caption{Implementatie van een minimum-component.}
\end{figure}
geeft dit proces schematisch weer. Vermits we bij het verschil enkel ge\"interesseerd zijn in het teken, hoeven we de overige bits niet uit te rekenen. Bijgevolg moeten we ook enkel de carry-logica implementeren. \figref{minimal-functionals-carry} toont een mogelijke implementatie van deze carry-logica. De schakeling is bijgevolg een gereduceerde versie van \figref{fulladder-implementation}. Wanneer we de kostprijs van de carry-logic uitrekenen komen we uit op 20 transistors per bit\footnote{Op een constante kostprijs na, die we hier niet beschouwen. Als het aantal bits vrij groot is, maakt de constante kostprijs meestal niet veel uit.}. Een multiplexer kost 12 transistors per bit. Bijgevolg kost een minimum- of maximum-component 32 transistors per bit.
\paragraph{}
De compatibiliteitsgrafe op \figref{compatibilitygraph-functionals-original} toont dat het samenvoegen van de $\mbox{min}$ en $\mbox{max1}$ bewerking niet mogelijk is. Beide bewerkingen worden immers in dezelfde toestand gebruikt. We kunnen echter wel $\mbox{max1}$ en $\mbox{max2}$ samenvoegen. Door het samenvoegen sparen we 32 transistors per bit uit. We dienen echter rekening te houden met de mogelijke introductie van multiplexers. In dit geval hebben we geluk: $\mbox{max1}$ neemt als invoer variabelen $t_3$ en $t_4$ voorgesteld door registers $t_1$ en $t_2$. $\mbox{max2}$ neemt als invoer variabelen $t_5$ en $t_{10}$ die ook worden opgeslagen in registers $t_1$ en $t_2$. In dit geval dienen we dus geen extra multiplexers te introduceren, de totale winst is dan ook 32 transistors per bit zoals aangeduid op \figref{compatibilitygraph-functionals-final}.
\paragraph{}
We kunnen er ook voor opteren om $\mbox{min}$ en $\mbox{max2}$ samen te voegen. \figref{minimal-functionals-minimax} toont een functionele eenheid die zowel het minimum als maximum kan uitrekenen. De schakeling verschilt slechts op \'e\'en punt van \figref{minimal-functionals-minimum}: er staat een XNOR\footnote{Een XOR-poort is ook correct indien het stuursignaal wordt ge\"inverteerd, alleen kost een XOR-poort meer.}-poort tussen het tekenen van het verschil een de multiplexer. Met behulp van het stuursignaal kan men dus beslissen om het signaal uit het verschil om te draaien of te behouden. Door het signaal om te draaien, kan men dus de andere data-ingang bij de multiplexer selecteren. Omdat de XNOR-poort maar eenmalig in de schakeling moet worden verwerkt, stijgt de kostprijs per bit niet. Ook hier hebben we geluk met de registers: beide functionele eenheden halen hun invoer uit dezelfde registers. De totale winst is dus opnieuw 32 transistors per bit.
\paragraph{Abs\&max}
Een volgende combinatie die we uitproberen is het berekenen van een absolute waarde en het maximum. Omdat we in de vorige paragraaf besproken hebben dat het minimum en maximum zeer gelijkaardig zijn, gelden alle uitspraken ook voor een component $\mbox{abs\&min}$. Allereerst dienen we een component te introduceren die de absolute waarde kan uitrekenen. Een mogelijke implementatie staat op \figref{minimal-functionals-abs}.
\begin{figure}[hbt]
\centering
\subfigure[Abs]{\importtikz{minimal-functionals-abs}}
\subfigure[Abs per bit]{\importtikz{minimal-functionals-absbit}}
\subfigure[Abs\&max per bit]{\importtikz{minimal-functionals-absmax}}
\caption{Implementatie van abs en abs\&max.}
\end{figure}
De meest significante bit bepaalt in complementvoorstelling het teken van het getal. Het teken stuurt vervolgens de selectie-ingang van een multiplexer aan. Indien het getal negatief is, wordt het tegengestelde van het oorspronkelijke getal doorgelaten. In het andere geval wordt het getal zelf doorgelaten. We moeten per bit het tegengestelde uitrekenen en voor elke bit dienen we ook een multiplexer te voorzien. Deze implementatie per bit wordt voorgesteld op \figref{minimal-functionals-absbit}. Op basis van deze schakeling zetten we de kostprijs van een $\mbox{abs}$ bewerking op 32 transistors per bit. We kunnen beide componenten samenvoegen, door per bit een schakeling te implementeren zoals op \figref{minimal-functionals-absmax}. De component berekent ofwel het maximum van de twee data-ingangen, of de absolute waarde van de tweede data-ingang. De schakeling werkt als volgt: de full adders berekenen samen met de NOT-poort het verschil tussen $D$ (voorgesteld door de $d_i$-bits) en $B$ (voorgesteld door de $b_i$-bits), het resultaat is een getal $S$ (voorgesteld door de $s_i$-bits). Indien we de absolute waarde berekenen (dit betekent dat het signaal $\mbox{Max/Abs*}$ laag staat), is $D$ gelijk aan $0$, bijgevolg is $S=-B$. In het geval we het maximum berekenen is $S=A-B$. Indien we de absolute waarde berekenen, zullen we op basis van het teken van $B$ de multiplexer aansturen, en beslissen of we ofwel $B$ doorlaten (in het geval $B$ positief is), ofwel $S=-B$. Dit hangt louter af van de hoogste bit van $B$ zoals voorgesteld in \tblref{minimal-functionals-absmaxmux}. In het geval we het maximum berekenen zal het teken van $S$ de multiplexer aansturen. Indien de teken-bit $s_{n-1}$ laag is ($S$ is positief), laten we $A$ door. $S$ is immers positief wanneer $A\geq B$. In het andere geval laten we $B$ door. Op basis van de tekens van $B$, $S$ en de operatie die we willen uitvoeren (absolute waarde of maximum), moeten we dus de stuursignalen $m_0$ en $m_1$ voor de multiplexer bepalen. Deze stuursignalen zijn voor de multiplexers van alle bits gelijk. Omdat we de logica dus maar eenmalig moeten implementeren zullen we de kostprijs hiervan verwaarlozen. De kost per bit omvat echter de multiplexer (18 transistors per bit), de full adder (36 transistors per bit), de AND-poort (6 transistors per bit) en de NOT-poort (2 transistors per bit). In totaal maakt dit dus 62 transistors per bit.
\importtabulartable{minimal-functionals-absmaxmux}{Multiplexer selectie-ingangen bij abs\&max.}
\paragraph{}
Nu we een samengesteld component hebben ge\"implementeerd, kunnen we de mogelijke winst berekenen. Er zijn verschillende manieren hoe we een dergelijk component kunnen gebruiken. Hieronder beschouwen we alle mogelijkheden:
\begin{equation}
\acclarray{
\accl{\mbox{abs1},\mbox{min}},\accl{\mbox{abs1},\mbox{max1}},\accl{\mbox{abs1},\mbox{max2}}\\
\accl{\mbox{abs2},\mbox{min}},\accl{\mbox{abs2},\mbox{max1}},\accl{\mbox{abs2},\mbox{max2}}\\
\accl{\mbox{abs1},\mbox{max1},\mbox{max2}},\accl{\mbox{abs2},\mbox{max1},\mbox{max2}}}
\eqnlab{minimal-functionals-combinations}
\end{equation}
We zullen niet alle combinaties bespreken. De mogelijke winsten staan op \figref{compatibilitygraph-functionals-final}. Enkel de scenario's die interessant zijn worden besproken. Als eerste voorbeeld nemen we $\mbox{abs1}$ en $\mbox{max1}$. De twee functionele eenheden apart kosten $64$ transistors per bit. Wanneer we de twee functionele eenheden samenvoegen, dan verwachten we slechts $62$ transistors per bit te betalen. Een probleem vormt echter de registers: $\mbox{abs1}$ haalt de gegevens uit register $t_1$, terwijl $\mbox{max1}$ deze uit de registers $t_1$ en $t_2$ haalt. Vermits de samengestelde component voor de absolute waarde de tweede ingang neemt, betekent dit dat we een multiplexer moeten plaatsen die kiest tussen register $t_1$ en $t_2$. Dit concept is ge\"illustreerd in \figref{minimal-functionals-absmax-mux}.
\importtikzfigure{minimal-functionals-absmax-mux}{Het combineren van $\mbox{abs1}$ en $\mbox{max1}$ introduceert een multiplexer.}
We kunnen echter een eigenschap van het maximum uitbuiten: deze operator is commutatief. Het maakt dus niet uit of deze component het maximum van $t_1$ en $t_2$ berekent, of van $t_2$ en $t_1$. Door de bedrading van het maximum om te draaien, vervalt de noodzaak om een multiplexer in te voeren. De totale winst bij het combineren is dus $2$ transistors per bit. Ditzelfde principe kan men toepassen bij het samenvoegen van alle combinaties in \eqnref{minimal-functionals-combinations} met twee bewerkingen.
\paragraph{}
We kunnen ook drie functionele eenheden in een nieuwe functionele eenheid combineren. Vermits we twee functionele eenheden hebben die de absolute waarde uitrekenen en twee die het maximum uitrekenen kunnen we verschillende combinaties uitproberen. Dit kan zolang niet beide absolute waardes door dezelfde component worden uitgerekend. De twee bewerkingen zijn immers incompatibel. Als voorbeeld nemen we $\mbox{abs1}$, $\mbox{max1}$ en $\mbox{max2}$. Vermits $\mbox{max1}$ en $\mbox{max2}$ commutatieve operaties zijn maakt de volgorde van de data-ingangen niet uit. Omdat de bewerkingen die we combineren allemaal op dezelfde registers werken, zullen we dus geen extra multiplexers moeten introduceren. De oorspronkelijke kostprijs per bit was 32 transistors voor $\mbox{abs1}$, 32 transistors voor $\mbox{max1}$ en 32 voor $\mbox{max2}$, wat dus samen $96$ transistors per bit betekent. De totale winst is dus $34$ transistors per bit. Een probleem is hoe we de winsten met drie of meer functionele eenheden in een compatibiliteitsgrafe voorstellen. We kunnen immers geen boog tussen drie knopen trekken. Twee bogen die de drie knopen verbinden kan dan weer tot verwarring leiden: de twee bogen kunnen als twee afzonderlijke prioriteitsranden beschouwd worden. Daarom voert men meestal een gevulde knoop die de prioriteitsrand voorstelt. Vanuit de knoop vertrekken bogen naar de bewerkingen op dewelke de prioriteitsrand betrekking heeft. Op de knoop zelf noteren we de winst. Deze notatie staat ook op \figref{compatibilitygraph-functionals-final}.
\paragraph{Add\&Sub}In \figrefpag{addsub-twocomplement-implementation} bespraken we reeds hoe we een component kunnen realiseren die zowel een optelling als een aftrekking kan uitvoeren. Op basis van een stuur-signaal kan men beslissen welke operatie uiteindelijk zal worden uitgevoerd. In deze paragraaf bespreken we de mogelijke winst die dit oplevert. Allereerst berekenen we de kostprijs per bit van een aparte opteller en aftrekker. Een opteller kost per bit een full adder, dit komt dus neer op een kostprijs van $36$ transistors per bit. Een aftrekker voorziet per bit een full adder en een NOT-poort. De kostprijs is bijgevolg $38$ transistors per bit. De totale kostprijs van de twee afzonderlijke componenten is dus $74$ transistors per bit. Bij een component die beide bewerkingen uitvoert vervangen we de NOT-poort door een XOR-poort zodat we kunnen kiezen of we de bits inverteren. De kostprijs per bit wordt dus opgedreven naar $48$ transistors per bit. Dit betekent dus een winst van $26$ transistors per bit. Wanneer we echter naar de bedrading kijken, zien we dat de optelling data uitleest uit registers $t_1$ en $t_2$. De aftrekking werkt met de registers $t_6$ en $t_2$. Bijgevolg moeten we een multiplexer introduceren die $12$ transistors per bit kost. De totale winst wordt dus $14$ transistors per bit.
\begin{figure}[hbt]
\centering
\subfigure[Opteller per bit]{\importtikz{minimal-functionals-addbit}}
\subfigure[Aftrekker per bit]{\importtikz{minimal-functionals-subbit}}
\subfigure[Opteller/aftrekker per bit]{\importtikz{minimal-functionals-addsubbit}}
\subfigure[Opteller/aftrekker per bit met multiplexer]{\importtikz{minimal-functionals-addsubbitmux}}
\caption{Implementatie van een opteller, aftrekker en opteller/aftrekker.}
\end{figure}
\paragraph{Add\&Max}We kunnen ook proberen om een optelling een het maximum in \'e\'en bewerking samen te voegen. Rekenkundig zijn beide bewerkingen niet direct met elkaar verwant. We kunnen echter op \figref{minimal-functionals-absmax} vaststellen dat we om het teken van het verschil te berekenen, full adders kunnen gebruiken. Vermits deze componenten de basis vormen van de optelling, is er een vermoeden dat in termen van poorten beide operaties een deel van de logica delen. \figref{minimal-functionals-addmaxbit}
\importtikzfigure{minimal-functionals-addmaxbit}{De implementatie van $\mbox{add\&max}$ per bit.}
toont de implementatie per bit voor een zo'n component. Indien we een optelling willen uitrekenen, zal de XOR-poort voor elke bit eenvoudigweg de waarde van $b_i$ doorlaten. Bijgevolg zullen de full adders de optelling van $A$ (voorgesteld door de $a_i$'s) en $B$ (voorgesteld door de $b_i$'s) uitrekenen. Het komt er op neer in dat stadion de waarde $S$ (voorgesteld door de $s_i$'s) bij alle multiplexers door te laten. In het geval we het maximum berekenen is het signaal $\mbox{Max/Add*}$ hoog. Bijgevolg doet de XOR-poort dienst als een NOT-poort voor $b_i$. Het gevolg is dat $S=A-B$. Het teken van $S$ wordt mee in de logica van de selectie-ingangen voor de multiplexer genomen en bepaalt dus of we ofwel $A$ zullen doorlaten (indien $S\geq 0$) ofwel $B$ (indien $S<0$). Het bepalen van de selectie-ingangen van de multiplexer vereist natuurlijk ook logica. \tblref{minimal-functionals-addmaxmux}
\importtabulartable{minimal-functionals-addmaxmux}{Multiplexer selectie-ingangen bij $\mbox{add\&max}$.}
beschrijft in welke omstandigheden welke selectie-ingangen vereist zijn. Een eenvoudige implementatie die geen extra kosten met zich meebrengt is $m_1=\mbox{Max/Add*}$ en $m_1=s_{n-1}$.
\paragraph{}
De kosten van een $\mbox{add\&max}$-component bestaan uit drie delen: de multiplexer kost $18$ transistoren per bit, de XOR-poort $12$ transistoren per bit en de full adder $36$ transistoren per bit. Samen maakt dit dus $66$ transistoren per bit. Nu we de kostprijs berekend hebben, kunnen we bepalen wat een dergelijk component kan opleveren. We kunnen de component op drie verschillende manieren gebruiken:
\begin{equation}
\accl{\accl{+,\mbox{max1}},\accl{+,\mbox{max2}},\accl{+,\mbox{max1},\mbox{max2}}}
\end{equation}
Bij alle combinaties komen we hetzelfde probleem tegen: de opteller haalt data uit registers $t_6$ en $t_2$ terwijl de beide componenten die het maximum berekenen dit halen uit de registers $t_1$ en $t_2$. Doordat beide bewerkingen commutatief zijn kunnen we de ingangen schikken zoals we wensen. Het resultaat blijft echter dat we minimum $1$ multiplexer moeten introduceren aan $12$ transistors per bit. De kostprijs van een opteller is $36$ transistors per bit en het maximum kost $32$ transistors per bit. Indien we dus een opteller samenvoegen met \'e\'en maximum-component bekomen we dus een verlies van $10$ transistors per bit. Dit duidt ook meteen aan dat het samenvoegen van bewerkingen niet altijd goedkoper is. Het rendeert echter wel wanneer we de opteller combineren met twee maximum componenten. In dat geval maken we $22$ transistoren per bit winst. Deze winst staat ook op \figref{compatibilitygraph-functionals-final}. Verliezen worden niet op een compatibiliteitsgrafe gezet. Men zal immers dergelijke prioriteitsranden altijd vermijden omdat het de kostprijs alleen maar verder verhoogt.
\paragraph{Abs\&Add\&Max}Tot dusver hebben we telkens twee types bewerken samengevoegd, eventueel is er wel sprake van meerdere functionele eenheden. Het is echter ook mogelijk meer dan twee types bewerkingen samen te voegen in een nieuwe functionele eenheid. Componenten die drie of meer bewerkingen werden al kort besproken onder de naam ``Arithmetic Logic Unit (ALU)'' in \sscrefpag{alu}. Het valt op dat combinaties met de absolute waarde, de opteller en het maximum op \figrefs{minimal-functionals-absmax,minimal-functionals-addmaxbit} een soortgelijk patroon vertonen: een full adder met daaronder een multiplexer die ofwel het resultaat van de full adder ofwel dit van de originele ingangen doorlaat. Meestal zijn de ingangen van de full adder ook voorzien van poorten. Het samenvoegen van bewerkingen kan dus mogelijk de transistoren uitsparen die betrokken zijn in de full adder en de multiplexer. \figref{minimal-functionals-absaddmaxbit} toont de implementatie per bit van een component die zowel een optelling, absolute waarde en maximum kan uitrekenen.
\importtikzfigure{minimal-functionals-absaddmaxbit}{De implementatie van $\mbox{abs\&add\&max}$ per bit.}
Hiervoor werkt de component met twee stuursignalen: $\mbox{Abs}$ en $\mbox{Add}$. Indien $\mbox{Abs}$ hoog staat en $\mbox{Add}$ laag, wordt de absolute waarde uitgerekend. Bij $\mbox{Abs}$ laag en $\mbox{Add}$ hoog berekent de component de optelling. Wanneer beide laag staan wordt het maximum uitgerekend. Dit systeem werkt als volgt: wanneer $\mbox{Abs}$ hoog staat, zal het resultaat van de AND-poort $0$ zijn\footnote{Bemerk dat we de negatie nemen van $\mbox{Abs}$ als tweede invoer op de AND-poort.}. Verder zal in alle gevallen waarbij $\mbox{Add}$ laag staat, wordt het signaal ge\"inverteerd (dit zijn dus alle toestanden behalve de optelling). Hieruit kunnen we drie situaties afleiden: bij een optelling is $S=A+B$, bij het berekenen van een absolute waarde is $S=-B$ en bij het berekenen van het maximum stellen we $S=A-B$. Het komt er dus op neer dat de selectie-ingangen van de multiplexer op basis van enerzijds het soort bewerking, en anderzijds het teken van $S$ en $B$, de juiste data moeten doorlaten. De relevante selectie-ingangen voor de verschillende situaties staan op \tblref{minimal-functionals-absaddmaxmux}.
\importtabulartable{minimal-functionals-absaddmaxmux}{Multiplexer selectie-ingangen bij $\mbox{abs\&add\&max}$.}
De kostprijs per bit voor deze component bedraagt $72$ transistors per bit: $18$ voor de multiplexer, $36$ voor de full adder, $12$ voor de XOR-poort en $6$ voor de AND-poort. We kunnen verder opnieuw heel wat mogelijkheden beschouwen bij het combineren van functionele eenheden:
\begin{equation}
\acclarray{\accl{\mbox{abs1},\mbox{max1},+},\accl{\mbox{abs1},\mbox{max2},+},\accl{\mbox{abs1},\mbox{max1},\mbox{max2},+}\\\accl{\mbox{abs2},\mbox{max1},+},\accl{\mbox{abs2},\mbox{max2},+},\accl{\mbox{abs2},\mbox{max1},\mbox{max2},+}}
\end{equation}
Een eigenschap die we zeker kunnen uitbuiten is dat alle beschouwde bewerkingen commutatief zijn. $\mbox{abs1}$ haalt bijvoorbeeld data uit register $t_1$. Dit betekent dus dat we dit register op de tweede ingang moeten aanleggen. Door de operanden van de maximum-bewerkingen om te draaien vermijden we echter dat we hiervoor een multiplexer moeten invoeren. De optelling leest de gegevens echter uit registers $t_6$ en $t_2$. We zullen dus sowieso een multiplexer moeten introduceren die kiest tussen het register $t_6$ en een ander register ($t_1$ of $t_2$ afhankelijk van de gekozen combinatie). Een dergelijke multiplexer komt met een kost van $12$ transistors per bit. Indien we bijvoorbeeld $\mbox{abs2}$ combineren met de twee maximum-bewerkingen en de opteller, kunnen we de schakeling implementeren zoals op \figref{minimal-functionals-absaddmaxbitmux}. In deze schakeling wordt de data van $B$ (voorgesteld door de $b_i$'s) opgehaald uit register $t_2$. Het getal $A$ (voorgesteld door de $a_i$'s) halen we uit register $t_1$ en $D$ (voorgesteld door de $d_i$'s) uit register $t_6$. De $2$-naar-$1$ multiplexer kiest bijgevolg uit een van de twee registers (register $t_6$ wordt enkel gekozen bij een optelling).
\begin{figure}[hbt]
\centering
\importtikzsubfigure{minimal-functionals-absaddmaxbitmux}{Generische multiplexer.}
\importtikzsubfigure{minimal-functionals-absaddmaxbitmuxand}{Samenstelling met poort.}
\caption{Methodes bij het introduceren van een multiplexer bij een samengestelde functionele eenheid.}
\end{figure}
Een aspect die we echter kunnen uitbuiten is de AND-poort die vlak onder deze multiplexer staat. Het resultaat van de AND-poort bestaat immers uit drie gevallen: $a_i$, $d_i$ of $0$. We kunnen dus de AND-poort en de $2$-naar-$1$ multiplexer samenvoegen in een $3$-naar-$1$ multiplexer. \figref{minimal-functionals-absaddmaxbitmuxand} toont de implementatie door de AND-poort en de multiplexer samen te drukken. De kostprijs blijft in dit geval constant (al is dat niet altijd zo). Al kan er nog een reden zijn om dit te doen: de tijdsduur van het kritische pad. Wanneer het signaal door een $3$-naar-$1$ multiplexer gaat, is dit sneller dan door een $2$-naar-$1$ multiplexer gevolgd door een AND-poort. Vermits het kritische pad de te realiseren kloksnelheid bepaalt, is dit een niet onbelangrijke factor.
\paragraph{}
Concreet realiseren we de volgende winsten: wanneer we een combinatie maken met \'e\'en maximum-bewerking is de originele kostprijs $100$ transistors per bit. De samengestelde component kost $72$ transistors per bit: $18$ transistors voor de multiplexer, $36$ voor de full adder, $12$ voor de XOR-poort en $6$ voor de AND-poort. Verder dienen we ook een multiplexer van $12$ transistors per bit te implementeren. De winst is dus $16$ transistors per bit. Wanneer we een samenstelling maken met de twee maximum-bewerkingen, besparen we alle transistoren betrokken in de tweede maximum bewerking: $32$ transistors per bit. De totale winst is dus $48$ transistors per bit.
\paragraph{Abs\&Add\&Max\&Sub}In de component die de absolute waarde, de optelling en het maximum samenvoegt in \'e\'en functionele eenheid valt op dat in sommige omstandigheden de full adder het verschil van de twee operanden uitrekent. Dit effect is afkomstig van het maximum: we berekenen immers het verschil om te bepalen welk register we zullen doorlaten. Door minimale veranderingen kunnen we een component implementeren die in het geval we een verschil willen uitrekenen, de onderste multiplexer het resultaat van het verschil doorlaat. Hiervoor zullen we teruggrijpen naar \figref{minimal-functionals-absaddmaxbit}. We beschouwen ook een extra stuursignaal: $\mbox{Sub}$. We dienen de schakeling per bit niet aan te passen, deze is dus volledig identiek aan \figref{minimal-functionals-absaddmaxbit}. We dienen alleen de logica die de selectie-ingangen van de multiplexer berekent aan te passen. De nieuwe logica staat in \tblref{minimal-functionals-absaddmaxsubmux}.
\importtabulartable{minimal-functionals-absaddmaxsubmux}{Multiplexer selectie-ingangen bij $\mbox{abs\&add\&max\&sub}$.}
\paragraph{}
De kostprijs verschilt niet van deze van \mbox{Abs\&Add\&Max}: $72$ transistors per bit.
\begin{equation}
\acclarray{\accl{\mbox{abs1},\mbox{max1},+,-},\accl{\mbox{abs1},\mbox{max2},+,-},\accl{\mbox{abs1},\mbox{max1},\mbox{max2},+,-}\\\accl{\mbox{abs2},\mbox{max1},+,-},\accl{\mbox{abs2},\mbox{max2},+,-},\accl{\mbox{abs2},\mbox{max1},\mbox{max2},+,-}}
\end{equation}
\paragraph{Min\&Sub} We onderzoeken ook het samenvoegen van minimum- en verschil-bewerkingen. Uit de implementatie van minumum en maximum weten we al dat we daarvoor het teken van het verschil moeten berekenen. Daarom verwachten we dat het samenvoegen van de componenten winst kan opleveren. \figref{minimal-functionals-minsubbit} toont de implementatie per bit van zo'n component.
\importtikzfigure{minimal-functionals-minsubbit}{De implementatie van $\mbox{min\&sub}$ per bit.}
De full adder rekent altijd het verschil uit: $S=A-B$. Ofwel wordt vervolgens op basis van het teken van $S$ een getal doorgelaten (in het geval van een minimum-bewerking), ofwel wordt $S$ zelf doorgelaten (wanneer we het verschil uitrekenen).
\importtabulartable{minimal-functionals-minsubbitmux}{Multiplexer selectie-ingangen bij $\mbox{min\&sub}$.}
\tblref{minimal-functionals-minsubbitmux} toont hoe we de stuur-signalen van de multiplexer moeten implementeren.
\paragraph{}
De kostprijs per bit bestaat uit de multiplexer ($18$ transistors), de full adder ($36$ transistors) en de NOT-poort ($2$ transistors). Dit maakt dus samen $56$ transistors per bit. In de schakeling komt maar \'e\'en minimum-bewerking en \'e\'en verschil bewerking voor. Dit is ook de enige combinatie die we kunnen uitproberen voor deze samengestelde functionele eenheid. Beide originele functionele eenheden halen bovendien gegevens uit dezelfde registers, bijgevolg worden geen extra multiplexers ge\"introduceert. De kostprijs van de twee afzonderlijke functionele eenheden is $70$ transistors per bit. We maken dus $14$ transistors winst per bit.
\paragraph{Abs\&Min\&Sub}
Bij het berekenen van de absolute waarde maken we een keuze tussen het ingevoerde getal en de negatie van dat getal. Vermits we in de schakeling van \mbox{Min\&Sub} de negatie van een ingevoerd getal berekenen, hopen we deze hardware te kunnen hergebruiken. We proberen dus een \mbox{Abs\&Min\&Sub} component te implementeren. We moeten echter wel extra logica voorzien: het is immers de bedoeling dat de full adders de negatie zullen leveren, maar dan moet de eerste operand wel op $0$ worden gezet. Dit kan men doen door over een AND-poort te voorzien die wanneer het stuur-signaal op de AND-poort $0$ is, zal de AND-poort ook $0$ op de linkse ingang van de full adder aanleggen. We bekomen dus de schakeling op \figref{minimal-functionals-absminsubbit}.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{minimal-functionals-absminsubbit}{Algemene implementatie.}
\importtikzsubfigure{minimal-functionals-absminsubbitmux}{Met multiplexer.}
\caption{De implementatie van $\mbox{abs\&min\&sub}$ per bit.}
\end{figure}
\tblref{minimal-functionals-absminsubbitmux} ten slotte, toont de logica bij de selectie-ingangen van de multiplexer. We beschouwen een verschil-bewerking wanneer zowel \mbox{Abs} en \mbox{Min} allebei op $0$ staan.
\importtabulartable{minimal-functionals-absminsubbitmux}{Multiplexer selectie-ingangen bij $\mbox{abs\&min\&sub}$.}
\paragraph{}
De kostprijs per bit van deze samengestelde component is $62$ transistoren: $36$ van de full adder, $6$ van de AND-poort, $2$ voor de NOT-poort en $18$ voor de multiplexer. Er zijn twee verschillende combinaties van functionele eenheden die we kunnen samenstellen met deze samengestelde functionele eenheid:
\begin{equation}
\accl{\accl{\mbox{abs1},\mbox{min},-},\accl{\mbox{abs2},\mbox{min},-}}
\end{equation}
Indien we \mbox{abs1} betrekken in de combinatie, ontstaat er echter een probleem met de ingangen. De aftrekker berekent immers het verschil tussen de waarde in registers $t_1$ en $t_2$. Omdat een verschil operator niet commutatief is, mogen we dus de volgorde van de ingangen niet kiezen. \mbox{abs1} berekent echter de absolute waarde van $t_1$. Hierdoor moet $t_1$ op de tweede ingang worden aangelegd. Het gevolg is dus dat we een multiplexer moeten introduceren zoals op \figref{minimal-functionals-absminsubbitmux}. Dit drijft de kostprijs op naar $74$ transistors per bit. De originele kostprijs van de afzonderlijke functionele eenheden is $102$ transistoren: $32$ voor de absolute waarde, $32$ voor de minimum en $38$ voor het verschil. De winst is dus $40$ transistoren per bit voor een combinatie met \mbox{abs1} en $28$ transistoren per bit voor een combinatie met \mbox{abs2}.
\paragraph{Combinaties met schuif-operaties over een vast aantal bits}In de processor komen ook twee schuif-bewerkingen voor: $\mbox{shr 1}$ en $\mbox{shr 3}$. Kunnen we deze operaties niet combineren met andere functionele eenheden? Vermits een schuif-bewerking over een vast aantal bits\footnote{Merk op dat dit niet geldt voor een schuif-operatie over een variabel aantal bits, hiervoor wordt een schuifoperator gebruikt (zie \sscrefpag{shiftoperators}).} wordt ge\"implementeerd met behulp van bekabeling, worden er geen transistoren gebruikt. Het combineren met enig ander component zal bijgevolg nooit winst opleveren (het combineren zal immers altijd nieuwe logica introduceren, tenzij de originele bewerkingen niet optimaal werden ge\"implementeerd).
\paragraph{Uiteindelijk compatibiliteitsgrafe} Nu we een groot aantal combinaties hebben uitgeprobeerd bekomen we de compatibiliteitsgrafe of \figref{compatibilitygraph-functionals-final}. Op de prioriteitsranden staat de winst in transistors per bit.
\importtikzfigure{compatibilitygraph-functionals-final}{De uiteindelijke compatibiliteitsgrafe bij het samenvoegen van bewerkingen.}
\paragraph{Optimaliseren van een meervoudige compatibiliteitsgraaf}
Bij de compatibiliteitsgraaf hebben we de max-cut methode gebruikt om tot een goed resultaat te komen. Dit algoritme is echter minder geschikt voor compatibiliteitsgrafes met prioriteitsranden met drie of meer knopen. Het algoritme werkt minder goed vanaf het moment dat de winst op een prioriteitsrand voor drie of meer knopen verschilt van de som van de winsten van prioriteitsranden tussen twee van de knopen. Daarom zullen we gebruik maken van een gretig\footnote{Engels: greedy.} algoritme. We zoeken de prioriteitrand met de meeste winst. Alle betrokken knopen worden vervolgens in een aparte partitie ondergebracht. De knopen samen met prioriteitsranden die betrokken zijn in minstens \'e\'en van de knopen worden vervolgens uit de grafe verwijderd waarna we het proces herhalen.
\paragraph{}
\importalgorithmicalgorithm{compatibilitygraph-multiple}{Het bepalen van sterke samengestelde functionele eenheden.}
\algoref{alg:compatibilitygraph-multiple} formaliseert het principe. In het algoritme beschouwen we $V$, de verzameling van oorspronkelijke bewerkingen. In het geval van het leidend voorbeeld is $V$ dus:
\begin{equation}
V_0=\accl{\mbox{abs1},\mbox{abs2},\mbox{min},\mbox{max1},\mbox{max2},-,+,\mbox{shr1},\mbox{shr3}}
\end{equation}
$E$ is de verzameling van prioriteitsranden. We stellen een element $e\in E$ voor als een verzameling knopen $e\subseteq V$. Bijgevolg is $E\subseteq\powset{V}$. $l:E\rightarrow\NNN$ ten slotte is een functie die de prioriteitsranden afbeeldt op een geheel getal die de winst\footnote{De winst drukt men niet noodzakelijk uit in transistoren per bit: in het geval van een ontwerp op een FPGA zal men bijvoorbeeld het aantal logische blokken nemen.} voorstelt. In het leidend voorbeeld zijn $E$ en de functie $l$ dus:
\begin{equation}
E_0:l=\acclarray{\accl{\mbox{abs1},\mbox{min}}:2,\accl{\mbox{abs1},\mbox{min},-}:28,\accl{\mbox{abs2},\mbox{max1},\mbox{max2},-,+}:92
\\\accl{\mbox{abs2},\mbox{max1},\mbox{max2}}:34,\accl{\mbox{abs2},\mbox{max1},\mbox{max2},+}:54,\accl{\mbox{min},-}:14
\\\accl{\mbox{max1},\mbox{max2}}:32,\accl{\mbox{max1},\mbox{max2},+}:22,\accl{-,+}:14}
\end{equation}
Met $X:f$ de set $X'$ waarbij elk element $x\in X$ verreikt is met de waarde $\fun{f}{x}$. Het element met de hoogste waarde in $E_0$ is $\accl{\mbox{abs2},\mbox{max1},\mbox{max2},-,+}$ met $92$ transistoren winst per bit. We nemen bijgevolg deze prioriteitsrand en voegen deze toe aan de partitie-verzameling:
\begin{equation}
\calP_1=\accl{\accl{\mbox{abs2},\mbox{max1},\mbox{max2},-,+}}
\end{equation}
We verwijderen vervolgens de knopen uit $V$ en de interfererende prioriteitsranden uit $E$:
\begin{eqnarray}
V_1&=&\accl{\mbox{abs1},\mbox{min},\mbox{shr1},\mbox{shr3}}\\
E_1:l&=&\accl{\accl{\mbox{abs1},\mbox{min}}:2}
\end{eqnarray}
Er blijft nog \'e\'en prioriteitsrand over die we bijgevolg selecteren. We voegen deze toe aan de partitie en verwijderen de relevante knopen en bogen:
\begin{eqnarray}
\calP_2&=&\accl{\accl{\mbox{abs2},\mbox{max1},\mbox{max2},-,+},\accl{\mbox{abs1},\mbox{min}}}\\
V_2&=&\accl{\mbox{shr1},\mbox{shr3}}\\
E_2:l&=&\emptyset
\end{eqnarray}
We merken dat de verzameling met prioriteitsranden $E_2$ leeg is. We voegen de resterende knopen bijgevolg als enkelvoudige partities toe:
\begin{equation}
\calP_3=\accl{\accl{\mbox{abs2},\mbox{max1},\mbox{max2},-,+},\accl{\mbox{abs1},\mbox{min}},\accl{\mbox{shr1}},\accl{\mbox{shr3}}}
\end{equation}
Nu we deze partitionering hebben gerealiseerd, kunnen we een nieuwe processor implementeren. \figref{sprocessor-minfun} toont de realisatie na het minimaliseren van de functionele eenheden.
\importtikzfigure{sprocessor-minfun}{Implementatie van het datapad na optimalisatie van de bewerkingen.}
\subsubsection{Verbindingen samenvoegen (``bus sharing'')}
Niet alleen transistoren bepalen de kostprijs in een processor. Ook de bedrading vormt een niet te onderschatten kost. Doorgaans bevatten registers echter een groot aantal bits: $16$, $32$ of $64$ bits vormen geen uitzondering. Wanneer we dus een groot aantal verbindingen moeten leggen tussen de registers en de functionele eenheden loopt de kostprijs dus wel op. Daarom tracht men meestal dezelfde verbinding te gebruiken om data van de registers naar de functionele eenheden te brengen. Dit concept wordt dan ook \termen{bus sharing} genoemd: het delen van verbindingen. Om het aantal verbindingen te verminderen, moeten we echter multiplexers of tri-state buffers introduceren. Het verminderen van de verbindingen komt dus met een kostprijs. Anderzijds bevatten sommige functionele eenheden zelf al multiplexers. Wanneer we twee of meer verbindingen kunnen samenvoegen die op de data-ingangen staan van een multiplexer van een functionele eenheid, kan deze multiplexer worden gereduceerd of zelfs worden ge\"elimineerd.
\importtikzfigure{minimal-bus-merge}{Het samenvoegen van verbindingen kan multiplexers elimineren.}
\figref{minimal-bus-merge} illustreert het principe van bus sharing. In plaats van de originele twee verbindingen bekomen we na de transformatie \'e\'en verbinding die gedeeld wordt door de twee registers. Om te voorkomen dat beide registers tegelijk data op de bus plaatsen voorzien we multiplexers. Indien een functionele eenheid aanvankelijk met behulp van een multiplexer kiest vanuit welk register data kan worden uitgelezen, kan deze bij het samenvoegen van de verschillende registers worden ge\"elimineerd. In dit opzicht is het soms zelfs mogelijk om van deze operatie een neutrale operatie te maken. Merk echter op dat een 2-naar-1 multiplexer 12 transistoren per bit kost, terwijl een tri-state buffer 10 transistoren per bit kost. In het voorbeeld maken we dus 8 transistoren per bit verlies. Dit impliceert echter niet dat we altijd verlies maken: stel dat verschillende functionele eenheden met behulp van een multiplexer het uit te lezen register bepaalden, kan het samenvoegen van verbindingen zelfs winst opleveren.
\paragraph{Compatibiliteitsgrafe}Net als de twee vorige optimalisaties zullen we opnieuw gebruik maken van een compatibiliteitsgrafe. In deze compatibiliteitsgrafe zijn de knopen logischerwijs de verbindingen. Een eerste probleem is dat er twee soorten verbindingen zijn: \termen{operanden} (van registers naar functionele eenheden) en \termen{resultaten} (van functionele eenheden naar registers). Omdat de twee soorten verbindingen geen effect op elkaar hebben, worden ze apart geoptimaliseerd. We zullen dus twee compatibiliteitsgrafes aanmaken. Twee verbindingen zijn incompatibel wanneer ze in dezelfde toestand actief\footnote{Een verbinding wordt uiteraard altijd gebruikt en zal altijd een signaal overbrengen. Met actief bedoelen we dat het resultaat ook effectief zal gebruikt worden. Bij bijvoorbeeld de resultaten betekent dit dat de data in de registers zal worden geladen.} gebruikt worden en gegevens van een verschillende aansturing dragen. Met aansturing bedoelen we een register bij een operand en een functionele eenheid bij een resultaat. Tot slot dienen we ook de prioriteitsranden te introduceren. Er is een voorkeur om twee verbindingen te gebruiken wanneer ze de aansturing delen (en dus tri-state buffers besparen) of eenzelfde gebruiker\footnote{Een gebruiker is een functionele eenheid in het geval van een operand en een register in het geval van een resultaat.} hebben (en dus multiplexers besparen).
\paragraph{}
Om een compatibiliteitsgrafe op te stellen, zullen we twee nieuwe tabellen introduceren: een \termen{operand-tabel} en een \termen{resultaten-tabel}. Deze tabellen bevatten in de verticale dimensie de verbindingen van het specifieke type (operanden of resultaten) en in de horizontale dimensie de verschillende toestanden die het algoritme doorloopt. Een cel wordt gemarkeerd wanneer in de gegeven toestand de verbinding actief gebruikt wordt. We zullen dit doen op basis van het algoritme op \figrefpag{asmSqrt} en de verbindingen op \figref{sprocessor-minfun}.
\paragraph{}
\begin{table}[hbt]
\centering
\importtabularsubtable{minimal-bus-operand}{Operand-tabel.}
\importtabularsubtable{minimal-bus-result}{Resultaten-tabel.}
\caption{Operand- en resultaten-tabel van het leidend voorbeeld.}
\tbllab{minimal-bus-all}
\end{table}
In toestand $S_0$ wordt de data ingelezen in de registers $t_1$ en $t_2$. Bijgevolg gebruiken we $2$ verbindingen: $r_1:\mbox{In1}\rightarrow t_1$ en $r_4:\mbox{In2}\rightarrow t_2$. We markeren dan ook deze cellen in \tblref{minimal-bus-result}. In toestand $S_2$ wordt de absolute waarde van beide registers berekend en wordt het resultaat opnieuw in de registers opgeslagen. Hiervoor wordt de data van registers $t_1$ en $t_2$ respectievelijk naar \mbox{FU1} en \mbox{FU2} geleid. Bijgevolg zijn de verbindingen $o_2:t_1\rightarrow\mbox{FU1}.1$ en $o_6:t_2\rightarrow\mbox{FU2}.2$ actief. Omdat het resultaat ook terug in de registers moet worden geladen, zijn ook resultaten-verbindingen actief: $r_2:\mbox{FU1}\rightarrow t_1$ en $r_5:\mbox{FU2}\rightarrow t_2$. Analoog berekenen we de actieve verbindingen van de andere verbindingen en bekomen de waarden in \tblrefs{minimal-bus-operand,minimal-bus-result}.
\paragraph{}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{compatibilitygraph-connections-a}{Operanden (registers naar functionele eenheden).}
\importtikzsubfigure{compatibilitygraph-connections-b}{Resultaten (functionele eenheden naar registers).}
\caption{De compatibiliteitsgrafes bij het samenvoegen van verbindingen.}
\end{figure}
Op basis van de opgestelde tabellen kunnen we de compatibiliteitsgrafes opstellen. Twee verbindingen zijn immers incompatibel wanneer er een kolom bestaat waar beide verbindingen tegelijk actief zijn en de aansturing verschilt. Zo kunnen we uit \tblref{minimal-bus-operand} dat $o_1$ compatibel is met alle andere verbindingen: de verbinding is actief in toestand $S_7$, een toestand waarin geen enkele andere verbinding actief is. $o_2$ is echter wel incompatibel met andere verbindingen. $o_2$ is immers actief in toestanden $S_1$ en $S_2$. In die toestanden zijn volgende verbindingen actief: $o_3$, $o_4$, $o_6$. Van deze verbindingen wordt $o_4$ ook aangestuurd door register $t_1$. De verbindingen $o_3$ en $o_6$ worden echter aangestuurd door register $t_2$. Bijgevolg is $o_2$ incompatibel met $o_3$ en $o_6$.  Analoog berekenen we alle incompatibiliteitsranden van de operanden en de resultaten:
\begin{eqnarray}
I_o&=&\accl{\tupl{o_2,o_3},\tupl{o_2,o_6},\tupl{o_3,o_4},\tupl{o_4,o_6},\tupl{o_5,o_6},\tupl{o_7,o_8}}\\
I_r&=&\accl{\tupl{r_1,r_4},\tupl{r_2,r_5},\tupl{r_3,r_7},\tupl{r_6,r_8}}
\end{eqnarray}
Vervolgens berekenen we de prioriteitsranden. $o_1$ wordt aangestuurd door register $t_1$. Andere operanden die door dit register worden aangestuurd zijn $o_2$, $o_4$ en $o_7$. We hoeven bij eenzelfde aansturing niet te controleren op het bestaan van een incompatibiliteitsrand. Eenzelfde aansturing is immers een voldoende voorwaarde om te stellen dat deze niet zal bestaan. $o_1$ wordt verder gebruikt door \mbox{Out}. Vermits dit de enige verbinding is die hiervan gebruik maakt, levert het delen van de gebruiker geen extra prioriteitsranden op. We tekenen bijgevolg prioriteitsranden tussen $o_1$ en $o_2$, $o_4$ en $o_7$. Vervolgens beschouwen we verbinding $o_4$ op basis van de aansturing vinden we prioriteitsranden met $o_1$, $o_2$ en $o_7$. Daarnaast is er een andere verbinding die dezelfde gebruiker deelt: $o_5$. Omdat beide verbindingen niet tegelijk actief zijn, is er geen sprake van een incompatibiliteitsrand. Daarom tekenen we ook een prioriteitsrand tussen $o_4$ en $o_5$. Indien we dit proces verder zetten bekomen we de volgende prioriteitsranden:
\begin{eqnarray}
P_o&=&\accl{\tupl{o_1,o_2},\tupl{o_1,o_4},\tupl{o_1,o_7},\tupl{o_2,o_4},\tupl{o_2,o_7},\tupl{o_3,o_6},\tupl{o_4,o_5},\tupl{o_4,o_7},\tupl{o_5,o_8}}\\
P_r&=&\accl{\tupl{r_1,r_2},\tupl{r_1,r_3},\tupl{r_2,r_3},\tupl{r_2,r_7},\tupl{r_3,r_5},\tupl{r_4,r_5},\tupl{r_4,r_6},\tupl{r_5,r_6},\tupl{r_7,r_8}}
\end{eqnarray}
De compatibiliteitsgrafen van de twee types verbindingen worden voorgesteld in \figrefs{compatibilitygraph-connections-a,compatibilitygraph-connections-b}. Nadat we de max-cut methode op de grafen toepassen bekomen we de volgende partities:
\begin{eqnarray}
\calP_o&=&\accl{\accl{o_1,o_2,o_4,o_5,o_7},\accl{o_3,o_6,o_8}}\\
\calP_r&=&\accl{\accl{r_1,r_2,r_7,r_8},\accl{r_3,r_4,r_5,r_6}}
\end{eqnarray}
\paragraph{Uiteindelijke implementatie}
\importtikzfigure{sprocessor-mincon}{De implementatie van het datapad na het minimaliseren van de verbindingen.}
\subsubsection{Registers samenvoegen in registerbank (``register port sharing'')}
Registers voorzien niet enkel logica om gegevens op te slaan. Er is ook logica vereist om nieuwe data op te slaan of om de data uit te lezen. We kunnen echter opmerken dat niet steeds alle registers hun data in elke toestand beschikbaar moeten stellen of nieuwe gegevens moeten opslaan. Door registers te groeperen in een registerbank kunnen we besparen op de implementatie van deze functies. Verder kunnen we het aantal multiplexers en tri-state buffers mogelijk reduceren omdat het aantal ingangen en uitgangen van een registerbank beperkter zijn. Dit proces, ook wel \termen{register port sharing} genoemd, zullen we in deze subsectie bespreken.
\paragraph{}
Alvorens we het aantal registers kunnen reduceren dienen we eerst te onderzoeken hoeveel lees- en schrijfpoorten\footnote{Met poort wordt geen logische (AND, OR, NOT,...) poort bedoelt, maar een toegangspunt waar men data kan uitlezen of wegschrijven.} we dienen te introduceren voor de registerbank(en). Hiervoor stellen we eerst een \termen{registertoegangstabel} ofwel ``\termen{Register Access Table}'' op. Op basis van deze tabel kunnen we dan opnieuw minimaliseren met bijvoorbeeld de max-cut methode of in eenvoudige gevallen zelfs exhaustief zoeken.
\paragraph{Registertoegangstabel}Een registertoegangstabel is een tabel met in de verticale dimensie de verschillende registers en de horizontale dimensie de verschillende toestanden. Een cel wordt gemarkeerd als leeg, \termen{lees (R)}, \termen{schrijf (W)} of \termen{lees/schrijf (RW)}. De cel specificeert of we in de gegeven toestand uit het gegeven register gegevens uitlezen en/of wegschrijven. We kunnen een registertoegangstabel opstellen met behulp van het ASM-schema op \figref{asmSqrt} of bijvoorbeeld de operand- en resultaten-tabellen op \tblref{minimal-bus-all}. Wanneer een operand-verbinding aangestuurd door een register $t_i$ actief is in toestand $S_j$, dan zetten we een R in de overeenkomstige cel van de registertoegangstabel. Wanneer er een resultaten-verbinding actief is in deze toestand, plaatsen we een W in de cel.
\paragraph{}
Zo zien we in \tblref{minimal-bus-operand} dat in toestand $S_0$ dat geen enkele verbinding actief is. Bijgevolg plaatsen we in de kolom van toestand $S_0$ geen R. In toestand $S_1$ zijn de operand-verbindingen $o_2$ en $o_6$ actief. De overeenkomstige register die aansturen zijn $t_1$ en $t_2$. We plaatsen dus in de rijen $t_1$ en $t_2$ in kolom $S_1$ een R. Analoog berekenen we de leestoegang van de andere cellen:
\begin{equation}
R=\acclarray{
\tupl{t_1,S_1},\tupl{t_1,S_2},\tupl{t_1,S_3},\tupl{t_1,S_4}\\
\tupl{t_1,S_6},\tupl{t_1,S_7},\tupl{t_2,S_1},\tupl{t_2,S_2},\tupl{t_2,S_4}\\
\tupl{t_2,S_5},\tupl{t_2,S_6},\tupl{t_6,S_3},\tupl{t_6,S_5}
}
\end{equation}
We berekenen op een gelijkaardige manier de schrijftoegang van de verschillende registers. Met behulp van \tblref{minimal-bus-result} kunnen we vaststellen dat in toestand $S_0$ de resultaten-verbindingen $r_1$ en $r_4$ actief zijn. Vermits $r_1$ en $r_4$ data laten inlezen in register $t_1$ en $t_2$, schrijven we W in de cellen $\tupl{t_1,S_0}$ en $\tupl{t_2,S_0}$. In toestand $S_1$ zien we opnieuw activiteit op de  verbindingen naar $t_1$ en $t_2$ bijgevolg schrijven we opnieuw W in de volgende kolom. Wanneer we dit proces verder toepassen, bekomen we de volgende lijst van schrijftoegangen:
\begin{equation}
W=\acclarray{
\tupl{t_1,S_0},\tupl{t_1,S_1},\tupl{t_1,S_2},\tupl{t_1,S_6}\\
\tupl{t_2,S_0},\tupl{t_2,S_1},\tupl{t_2,S_3}\\
\tupl{t_2,S_4},\tupl{t_2,S_5},\tupl{t_6,S_2},\tupl{t_6,S_3}
}
\end{equation}
De uiteindelijke registertoegangstabel staat in \tblref{minreg-readwrite}.

\importtabulartable{minreg-readwrite}{Registertoegangstabel van het leidend voorbeeld.}
\paragraph{}
Een registerbank bevat een set van registers. Een belangrijke vraag is hoeveel lees en schrijfpoorten we moeten voorzien in een registerbank vermits dit in grote mate de kostprijs zal bepalen. De aantallen worden bepaald door de registers die de registerbank vertegenwoordigt. In elke toestand wordt er immers data ingelezen en weggeschreven in deze registers. Het aantal leespoorten is dan ook gelijk aan het maximale aantal leesoperaties van de betrokken registers in een bepaalde toestand. Analoog stelt men het aan schrijfpoorten gelijk aan het maximale aantal schrijfoperaties van deze registers in een toestand.
\paragraph{}
We zullen dit concept illustreren met twee voorbeelden. Stel dat we een registerbank opstellen die de registers $t_1$ en $t_6$ groepeert. Vermits in toestand $S_2$ naar beide registers wordt geschreven, moeten we twee schrijfpoorten voorzien. Vermits de registerbank slechts twee registers vertegenwoordigt kan dit aantal onmogelijk groter worden.  Verder kunnen we ook vaststellen dat in toestand $S_3$ uit de twee registers data wordt uitgelezen. Bijgevolg is het aantal leespoorten ook gelijk aan twee.
\paragraph{}
Indien we een registerbank met de drie registers $t_1$, $t_2$ en $t_6$ beschouwen is de situatie echter anders. Er bestaat immers geen enkele toestand waar uit alle registers tegelijk data wordt uitgelezen. Evenmin bestaat er een toestand waarin data in alle betrokken registers wordt weggeschreven. In elke toestand zijn er maximum twee leesbewerkingen en twee schrijfbewerkingen. We dienen dus $2$ leespoorten en $2$ schrijfpoorten te voorzien, terwijl we drie registers beschouwen.
\paragraph{}
Alvorens de registers samen te voegen in een registerbank, zullen we eerst onderzoeken of het wel interessant is om alle registers in eenzelfde registerbank onder te brengen. Misschien is het interessanter om bijvoorbeeld twee of drie registerbanken te voorzien. Het feit dat we slechts drie registers beschouwen, laat ons toe alle mogelijkheden te onderzoeken. Er zijn in totaal $5$ partities:
\begin{equation}
\calP_{\mbox{\small registerbank}}=\acclarray{
\accl{\accl{t_1},\accl{t_2},\accl{t_6}}\\
\accl{\accl{t_1},\accl{t_2,t_6}}\\
\accl{\accl{t_1,t_2},\accl{t_6}}\\
\accl{\accl{t_1,t_6},\accl{t_2}}\\
\accl{\accl{t_1,t_2,t_6}}
}
\end{equation}
Het aantal lees- en schrijfpoorten per partitionering in registerbanken staan in \tblref{minreg-config}. We kunnen vaststellen dat het groeperen van alle registers in \'e\'en registerbank de meeste voordelige implementatie is.
\importtabulartable{minreg-config}{Registerbank-configuraties voor het leidend voorbeeld.}
\subsubsection{Vergelijking van de verschillende optimalisaties}
\importtabulartable{minimal-comparison}{Vergelijking van de kostprijs na de verschillende optimalisaties.}
Om de verschillende optimalisaties samen te vatten, presenteren we \tblref{minimal-comparison} die de implementaties na de verschillende optimalisaties samenvat. We drukken de kostprijs uit volgens twee systemen: het aantal transistoren bij een ASIC implementatie en het aantal logische blokken wanneer we de processor implementeren op een FPGA. Verder bepalen we ook het aantal verbindingen. We delen het aantal transistoren verder op in vier categorie\"en: registers, functionele eenheden, registers naar functionele eenheden en functionele eenheden naar register. De laatst twee bepalen het aantal transistoren die betrokken zijn in de tri-state buffers aan de uitgangen van de aansturing en de multiplexers aan de ingangen van de ontvangers. In het geval van een FPGA kunnen we enkel een onderscheid maken tussen registers en functionele eenheden. De reden is dat een FPGA altijd multiplexers voorziet aan de in en uitgangen en we bijgevolg er de logica tussen registers en functionele eenheden geen extra logische blokken vereist. Merk op dat de kostprijs telkens is uitgedrukt per bit. Indien de registers bijvoorbeeld 32 bit getallen voorstellen moet men de kostprijs ongeveer vermenigvuldigen met $32$ om een benaderende kostprijs uit te rekenen.
\subsection{Andere optimalisaties}
\label{ss:syntheseFSMDOptimal}
\subsubsection{Minimaal instructiewoord}
De verzameling van stuursignalen noemt men doorgaans het \termen{instructiewoord}. Het is immers een verzameling van bits die voor het datapad de operatie die moet worden uitgevoerd verder specificeert. Een typisch datapad bestaat uit \'e\'en of meer registerbanken, een paar tellers, een paar afzonderlijke registers, \'e\'en of meer aritmetische logische eenheden (ALU), een schuifoperator en een vergelijker. Al deze componenten introduceren stuursignalen. \figref{instructionword-example} toont een voorbeeld van hoe zo'n instructiewoord er kan uitzien. Per bit bevat de figuur een korte beschrijving van de betekenis van de bit.
\importtikzfigure{instructionword-example}{Een voorbeeld van een instructiewoord.}
\paragraph{}
In de meeste gevallen kan men echter het instructiewoord verkleinen met behulp van verschillende assumpties. Een eerste assumptie is bijvoorbeeld dat niet alle functionele eenheden (ALU, schuifregister,...) tegelijk actief zullen zijn. In plaats van voor elke functionele eenheid een reeks bits in het instructiewoord te voorzien, kunnen we enkele bits reserveren die bepalen of een sequentie aan stuursignalen bedoeld zijn voor de ene functionele eenheid of de andere.
\paragraph{}
Een andere reductie omvat het gebruik van tri-state buffers. Tri-state buffers verhinderen dat uitvoer van registers of functionele eenheden tegelijk op dezelfde verbindingen worden gezet. Bijgevolg zijn de stuursignalen van de tri-state buffers exclusief: slechts \'e\'en van de stuursignalen van de tri-state buffers is tegelijk actief. In plaats van voor iedere tri-state buffer een bit in het instructiewoord te voorzien, kunnen we in bits een getal uitdrukken die bepaalt welke tri-state buffer nu de data op de verbinding moet zetten. Voor $n$ tri-state buffers wordt het instructiewoord dus gereduceerd van $n$ bits naar $\ceil{\log_2n}$ bits.
\paragraph{}
Bij wijze van voorbeeld zullen we nog enkele voorbeelden geven gebaseerd op het instructiewoord van \figref{instructionword-example}.
\begin{enumerate}
 \item De eerste operandbus bevat ofwel gegevens afkomstig van de de registerbank (leespoort 1) ofwel het register.We kunnen dus ofwel \mbox{RFOE1} ofwel \mbox{ROE} elimineren. We besparen $1$ bit.
 \item De tweede operandbus bevat ofwel gegevens afkomstig van de de registerbank (leespoort 2) ofwel de teller.We kunnen dus ofwel \mbox{RFOE2} ofwel \mbox{COE} elimineren. We besparen $1$ bit.
 \item In een registerbank is het signaal ``read-enabled (RE)'' altijd gelijk aan het stuursignaal op het tri-state buffer (RFOE). We kunnen dus voor beide leespoorten ofwel \mbox{RE$i$} ofwel \mbox{RFOE$i$} elimineren. We besparen $2$ bits (we beschouwen immers twee leespoorten).
 \item De resultaatbus bevat het resultaat van ofwel de ALU ofwel de schuifoperator. We kunnen dus opnieuw het stuursignaal van \'e\'en van de tri-state buffers wegwerken: ofwel \mbox{AOE} ofwel \mbox{SOE}. We besparen $1$ bit.
 \item De ALU en barrelshifter worden nooit tegelijk gebruik (de resultaten kunnen immers niet tegelijk op de bus worden geplaatst). Op basis van de tri-state buffer die de output op de bus plaatst, weten we welke component actief is. De overige bits die voor de instructie instaan (\mbox{F0}, \mbox{F1}, \mbox{F0}, \mbox{SH2}, \mbox{SH1}, \mbox{SH0} en \mbox{D}), kunnen worden gedeeld. We besparen bijgevolg $3$ bits.
 \item Bij de teller zijn de increment (\mbox{C}) en het inladen van de nieuwe waarde (\mbox{L}) exclusief. We besparen $1$ bit.
\end{enumerate}
Op basis van deze maatregelen hebben $9$ bits op het instructiewoord bespaard.
\subsubsection{``Chaining'': meerdere bewerkingen per klokcyclus}
Naast de eerder beschreven optimalisaties, kunnen we ook het ASM-schema zelf aanpassen. De argumentatie om dit te doen is een analyse van het tijdsgedrag. Elke klokcyclus wordt de data van de registers uitgelezen en voeren de functionele eenheden hierop bewerkingen uit. Niet alle functionele bewerkingen vereisten echter dezelfde hoeveelheid tijd om het resultaat te berekenen. We kunnen bijvoorbeeld denken aan de schuifoperaties met een vast aantal bits. Vermits hierbij geen logica moet worden ge\"implementeerd, wordt zo'n operatie in theorie onmiddellijk uitgevoerd. We kunnen echter analyseren wat er vervolgens met de gegevens van de functionele eenheid zal worden gedaan. Indien het mogelijk is om de volgende operatie in dezelfde klokcyclus uit te voeren kan dit tot besparingen leiden. Het groeperen van operaties die na elkaar moeten worden uitgevoerd noemen we \termen{chaining}. \figref{chaining} illustreert dit principe.
\paragraph{}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{chaining-asm}{ASM-schema.}
\importtikzsubfigure{chaining}{Datapad.}
\caption{De chaining-transformatie.}
\figlab{chaining-general}
\end{figure}
Wanneer we het ASM-schema en het datapad aanpassen zoals op \figref{chaining-general}, voeren we een chaining transformatie uit. In het ASM-schema worden twee operaties $f_1$ en $f_2$ uitgevoerd. We kunnen de twee operaties samenvoegen in een operatie $f$ met $\fun{f}{x,y}=\fun{f_2}{\fun{f_1}{x},y}$. Alvorens we een chaining-transformatie kunnen uitvoeren, moeten we echter \'e\'en voorwaarde controleren: alle operanden moeten beschikbaar zijn alvorens we de gegroepeerde functie uitvoeren. Indien $z$ bijvoorbeeld nog niet beschikbaar is in de eerste toestand, kunnen we $f$ nog niet berekenen.
\subsubsection{``Multicycling'' en ``Pipelining'': meerdere klokcycli per bewerking}
\paragraph{Multicycling}
Ook in omgekeerde richting kunnen we mogelijk winst boeken. Door een instructie ``uit te smeren'' over verschillende toestanden kunnen we mogelijk de schakeling goedkoper maken, of de kloksnelheid verhogen. Dit concept noemen we \termen{multicycling}. In het leidend voorbeeld dienen we bijvoorbeeld het verschil te berekenen tussen twee getallen. Het verschil wordt doorgaans gerealiseerd met een functionele eenheid die dit in twee ``stappen'' zal uitrekenen: eerst nemen we de negatie van het tweede getal, waarna we vervolgens met behulp van een keten van full adders het eerste getal en de negatie van het tweede getal optellen. Omdat de twee stappen een sequentieel karakter vertonen\footnote{Men kan de twee stappen niet tegelijk uitvoeren of ze laten overlappen}, zouden we ervoor kunnen opteren om twee toestanden te voorzien. We voorzien dus geen aftrekker, maar voorzien twee functionele eenheden: een opteller en een componenten die de negatie van het getal kan berekenen.
\paragraph{}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{multicycling-asm}{ASM-schema.}
\importtikzsubfigure{multicycling}{Datapad.}
\caption{De multicycling-transformatie.}
\figlab{multicycling-general}
\end{figure}
\figref{multicycling-general} beschrijft de transformatie die gepaard gaat met de introductie van multicycling. In het ASM-schema wordt een complexe functie $f$ uitgerekend die we kunnen opsplitsen in twee functies $f_1$ en $f_2$ zodat $\fun{f}{x,y}=\fun{f_1}{\fun{f_2}{x},y}$. In het ASM-schema wordt de functie uitgesmeerd over twee toestanden. Dit hoeft niet te betekenen dat we de tweede toestand moeten introduceren: we kunnen bijvoorbeeld ook de $f_2$-bewerking naar de volgende (al bestaande) toestand schuiven. In het datapad wordt in het algemeen een register ge\"introduceerd. Dit hoeft echter niet de betekenen dat we ook effectief een nieuw register zullen nodig hebben. Door de minimalisatie van de variabelen, kunnen we eventueel het ge\"introduceerde register elimineren. Als voorwaarde om deze transformatie uit te voeren stellen we \'e\'en voorwaarde: de bewerking moet zijn uitgevoerd alvorens andere bewerkingen het resultaat zullen gebruiken als operand.
\paragraph{}
De voordelen van multicycling zijn tweeledig. Allereerst kunnen we mogelijk hardware besparen in de functionele eenheden. Een opteller is immers goedkoper dan een aftrekker. Wanneer elders in het algoritme bijvoorbeeld nog een negatie moet worden berekend, kunnen we mogelijk de ge\"introduceerde functionele eenheid delen waardoor dit geen extra kosten met zich meebrengt. Verder valt op te merken dat wanneer we operaties kunnen herleiden naar kleinere basis-instructies, de kans groter is dat complexe operaties een deel van die basis-instructies zullen delen. Een eerste winst is dus mogelijk de kostprijs van de functionele eenheden.
\paragraph{}
Daarnaast kunnen we mogelijk de kloksnelheid opdrijven. Stel bijvoorbeeld dat de aftrekker de traagste operatie is in heel het proces, zal deze functionele eenheid de kloksnelheid bepalen. Het is echter mogelijk dat alle overige functionele eenheden significant sneller resultaten berekenen. Door een verschil-operatie op te splitsen in twee operaties die apart sneller presteren kunnen we mogelijk de kloksnelheid opdrijven. Indien de verschil-operatie vrij zeldzaam is, kan dit dus de doorvoer van het algoritme significant verhogen.
\paragraph{}
Multicycling komt in de meeste gevallen echter met een kostprijs. Allereerst valt in de praktijk de snelheidswinst meestal tegen. Stel bijvoorbeeld dat in het algoritme alleen verschil-bewerkingen worden uitgevoerd. De periode van het kloksignaal is in de realisatie van dit algoritme $1~\mbox{v}$\footnote{We introduceren hier een tijdseenheid \mbox{v}: de tijd die het proces nodig heeft om een verschil uit te rekenen en in te klokken.}. We kunnen deze periode vervolgens opdelen in $3$ delen\footnote{De verhoudingen van de delen is louter fictief en dient enkel ter illustratie.}: $0.35~\mbox{v}$ om de negatie te berekenen, $0.35~\mbox{v}$ voor de optelling en $0.3~\mbox{v}$ om de waarde in het register in te klokken. Merk op dat de tijd in dit fictieve voorbeeld mooi verdeeld is over de twee deeloperaties en dus ideaal is voor multicycling. Toch zullen we de kloksnelheid niet kunnen verdubbelen: de tussenresultaten (de negatie van het tweede getal) moeten immers ook in een register worden opgeslagen. De periode van een deelbewerking wordt bijgevolg $0.65~\mbox{v}$. We besparen bijgevolg $35\%$ op de klokfrequentie.
\paragraph{}
Een tweede kost heeft betrekking op de kostprijs. De kostprijs van de functionele eenheden kan in principe afnemen, maar introduceert extra logica ter hoogte van de controller. We introduceren immers een nieuwe ``deel-toestand'': een toestand waarin we de negatie van de tweede operand hebben berekend. Verder dienen we mogelijk nieuwe registers te introduceren om tussenresultaten in weg te schrijven\footnote{In het geval van een verschil-bewerking is dit niet het geval omdat we na de negatie van de tweede operand, de originele operand niet meer nodig hebben. In het algemeen is dit echter niet het geval.}. Bovendien introduceren we mogelijk nieuwe verbindingen, multiplexers en tri-state buffers om de resultaten van de extra functionele eenheden in de correcte registers weg te schrijven.
\paragraph{}
Multicycling is echter wel een populaire techniek voor operaties die buitenproportioneel veel tijd vragen. Dit is meestal het geval bij bijvoorbeeld RAM-geheugen. Men merkt op dat sinds de jaren~'80 de processorsnelheid significant werd opgedreven terwijl de RAM-geheugens deze evolutie niet hebben gevolgd. Indien we dus een toestand zouden voorzien om een cel uit het RAM-geheugen uit te lezen, zou de processorsnelheid hoogstens gelijk zijn aan deze van het RAM-geheugen. Een processor en geheugen werken dan ook eerder onafhankelijk van elkaar. Op geregelde tijdstippen geeft de processor een opdracht aan het RAM-geheugen om een cel uit te lezen en vervolgens enkele toestanden later te controleren of de gegevens reeds in de registers of cache zitten. De \verb+80x86+ instructieset kent zelfs ``prefetching''-instructies: instructies waarmee men de opdracht kan geven om data in de cache in te laden zodat op het moment dat de data effectief nodig is, deze meteen kan worden uitgelezen.
\paragraph{Pipelining}
Het uitsmeren van instructies over verschillende toestanden maakt ook een ander effect mogelijk: \termen{pipelining}. Pipelining is een uitvoeringsstrategie naast \termen{sequenti\"ele uitvoering} en \termen{parallelle uitvoering}.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{execution-sequential}{Sequentieel.}
\importtikzsubfigure{execution-parallel}{Parallel.}
\importtikzsubfigure{execution-pipelining}{Pipelining.}
\caption{De verschillende uitvoeringsstrategie\"en: sequentieel, parallel en pipelining.}
\figlab{execution-models}.
\end{figure}
\paragraph{}
\figref{execution-models} toont de verschilende uitvoeringsstrategie\"en naast elkaar. Als voorbeeld gebruiken we het wassen van kledij. In het geval van sequenti\"ele uitvoer beschikken we over \'e\'en wasmachine, \'e\'en droogkast en \'e\'en strijkijzer. Kledij wordt eerst in de wasmachine gestopt, vervolgens gedroogd en daarna gestreken. Wanneer we een grote hoeveelheid kledij moeten wassen, herhalen we dit mechanisme. Indien elke opdracht $\Delta t$ in beslag neemt, betekent dit dus dat we $\bigoh{3\cdot k\cdot\Delta t}$ tijd nodig hebben om alles te verwerken met $k$ de hoeveelheid kledij. Dit proces staat beschreven in \figref{execution-sequential}.
\paragraph{}
Men kan de doorvoer echter opdrijven door meer infrastructuur te voorzien. Indien we elke machine in het $n$-voud aankopen en over $n$ arbeiders beschikken, kunnen we de doorvoer opdrijven met ongeveer $\bigoh{n}$. De gemiddelde tijd die het wassen van alle kledij in beslag neemt wordt dus gereduceerd tot $\bigoh{3\cdot k\cdot\Delta t/n}$. Het probleem is echter dat de kosten ook stijgen met een factor $\bigoh{n}$. Bovendien wordt de versnelling niet altijd gerealiseerd. Meestal is er een vorm van boekhouding nodig die bepaalt wie welke taak precies zal uitvoeren\footnote{De maximaal te realiseren versnelling wordt geformaliseerd met de ``Wet van Amadahl''.}. Dit proces staat beschreven in \figref{execution-parallel}.
\paragraph{}
Tot slot is er pipelining. In het geval van pipelining beschikken we opnieuw over \'e\'en wasmachine, droogkast en strijkijzer. In plaats van echter alles na elkaar uit te voeren, werken de machines continu. Op het moment dat de wasmachine immers klaar is, verhuist de gewassen kledij naar de droogkast, maar stopt men nieuwe kledij in de wasmachine. Het gevolg is dat wanneer er $s$ stappen in het proces zijn, we de doorvoer kunnen opdrijven met $\bigoh{s}$ ten opzichte van het sequentieel proces, zonder de kosten voor de infrastructuur op te drijven. Dit proces staat beschreven in \figref{execution-pipelining}. Men kan pipelining ook vergelijken met het principe van de lopende band: we voorzien telkens \'e\'en machine voor elke bewerking en het resultaat schuift van machine naar machine.
\paragraph{}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{pipelining-asm}{ASM-schema.}
\importtikzsubfigure{pipelining}{Datapad.}
\caption{De pipelining-transformatie.}
\figlab{pipelining-general}
\end{figure}
\figref{pipelining-general} beschrijft het transformatieproces bij pipelining. Wanneer twee identieke operaties dicht op elkaar volgen, kunnen we beide bewerkingen uitsmeren in de tijd en tegelijk parallelle uitvoer introduceren. De transformatie van het datapad is erg gelijkaardig aan dat van multicycling. Merk echter op dat we ook een nieuw register introduceren voor $z$. De reden is dat terwijl we de $f_2$ voor de eerste keer uitvoeren, we ook de operanden van de tweede instructie moeten uitvoeren. We kunnen een pipelining-transformatie uitvoeren op voorwaarde dat alle resultaten zijn uitgerekend alvorens ze door andere bewerkingen worden uitgevoerd en de instructies betrokken in het pipelining proces onafhankelijk van elkaar kunnen worden uitgevoerd.
\paragraph{}
We kunnen pipelining op vier niveaus toepassen:
\begin{enumerate}
 \item Functionele eenheden: in dit niveau splitsen we de bewerkingen op in deelbewerkingen en bewaren we de tussenresultaten in registers.
 \item Datapad: indien we werken met een trage registerbank (bijvoorbeeld RAM-geheugen) gebruiken we meestal ook pipelining.
 \item Controller.
 \item Het ASM-schema: we kunnen het ASM-schema herschrijven, bijvoorbeeld door de verschil-instructie op te splitsen in een negatie-instructie en een optelling-instructie. Dit hoeft niet te betekenen dat we meer toestanden introduceren: sommige omstandigheden laten toe dat we een onderdeel van de instructie gewoon doorschuiven naar de volgende toestand. Op basis van het aangepaste schema zullen we mogelijk meer hardware introduceren, maar door het minimaliseren van het datapad kunnen we dit mogelijk terug ontdubbelen.
\end{enumerate}
In moderne processoren implementeert men pipelining op nagenoeg alle niveaus in de zogenaamde \termen{generische instructiecyclus}. De generische instructiecyclus is een beschrijving in welke onderdelen een gegeven instructie wordt uitgevoerd:
\begin{enumerate}
 \item Lees een instructie.
 \item Bereken de adressen (indien de instructie operanden uit bepaalde geheugenadressen haalt).
 \item Lees de operand(en) uit.
 \item Voer de bewerking uit.
 \item Schrijf het resultaat weg.
\end{enumerate}
\paragraph{}
Pipelining komt echter ook met enkele problemen. Om de snelheid effectief met \bigoh{s} op te drijven, dienen de deelstappen precies evenveel tijd te vragen. In de praktijk is het niet eenvoudig een proces zo op te delen. Wanneer dit niet te realiseren valt geldt de ``Wet van de zwakste schakel'': het traagste deelproces bepaalt hoelang het duurt alvorens data zal worden uitgelezen. Verder is pipelining ook enkel interessant wanneer we kort na elkaar een groot aantal maal de operatie moeten uitvoeren. Indien we slechts \'e\'enmaal de operatie uitvoeren blijft de rekentijd ongeveer dezelfde. We kunnen dus stellen dat de doorvoer (``\termen{throughput}'') wordt verhoogd, maar de vertraging (``\termen{latency time}'') ongeveer dezelfde blijft. Net als bij multicycling dienen we ook opnieuw extra registers te voorzien om de tussenresultaten in op te slaan. Deze register verhogen de kostprijs en zullen bovendien een deel van de tijdswinst tenietdoen omdat het wegschrijven van tussenresultaten in de registers ook tijd vergt.
\paragraph{}
\importtikzfigure{execution-pipelining-feedback}{Terugkoppeling verhindert pipelining.}
We kunnen ook niet zomaar elk proces uitvoeren volgens de pipelining uitvoeringsstrategie. Pipelining vereist dat de opeenvolgende stappen eerder onafhankelijk van elkaar kunnen werken. Stel bijvoorbeeld dat de tweede operatie echter een operand nodig heeft die in de vorige instructie wordt berekend, treedt er een probleem op. Bij deze vorm van terugkoppeling verliezen we de performantie-winst. De pipeline wordt gestopt tot het resultaat van de eerste operatie beschikbaar is om vervolgens de tweede operatie uit te voeren. \figref{execution-pipelining-feedback} illustreert dit principe. Stel dat instructie $2$ bijvoorbeeld $t_4\leftarrow t_1-t_3$ berekent en instructie $3$ vervolgens $t_5\leftarrow t_2-t_4$. We kunnen opmerken dat instructie $3$ als operand een resultaat gebruikt dat wordt berekend door instructie $2$. Bijgevolg worden er geen nieuwe instructies in de pipeline ge\"injecteerd, tot instructie 2 volledig is uitgevoerd.
\subsection{Besluit}
Als algemene conclusie kunnen we stellen dat het zeer moeilijk is om de optimale implementatie te vinden. Dit aspect wordt bovendien bemoeilijkt omdat de optimalisaties op verschillende niveaus elkaar be\"invloeden: de minimalisatie van het aantal registers kan ertoe leiden dat we de functionele eenheden op een andere manier zullen optimaliseren. Daarom zullen we ons meestal tevreden stellen met heuristieken: benaderende methodes zoals bijvoorbeeld het max-cut algoritme. Sommige methodes zijn echter meer geschikt voor optimalisatie bij het ene niveau tegenover het andere. Bovendien is de beste keuze afhankelijk van de gekozen technologie: als we een schakeling implementeren op een FPGA zullen we logische blokken optimaliseren in plaats van transistoren.
\paragraph{}
Het algoritme herschrijven biedt ook veel mogelijkheden. Soms kunnen we hierdoor pipelining mogelijk maken of een functionele eenheid alsnog hergebruiken. Wanneer we echter het algoritme aanpassen, moeten we ook opnieuw het datapad minimaliseren.
\paragraph{}
Minimaliseren van het datapad is bijgevolg een complex proces waarbij het nagenoeg onmogelijk is om een globaal optimale implementatie te bekomen.
\section{Tijdsgedrag}
\seclab{timeFSMD}
\label{s:timeFSMD}
Hoewel een niet-programmeerbare processor in wezen een sequenti\"ele schakeling is, en we het tijdsgedrag omtrent sequenti\"ele schakelingen al hebben besproken, zullen we in deze sectie tijdsaspecten bespreken die enkel relevant zijn voor niet-programmeerbare processoren.
\subsection{Kritisch pad}
Een belangrijk aspect is deze van het kritisch pad. We hebben al besproken dat het kritisch pad bepaalt hoe snel een verandering aan de ingang effect heeft op de uitgang. In een processor is er niet altijd een in- of uitgang. Wel moet op het moment van een klokflank de correcte data op de ingang van de registers staan. Bovendien dienen we ook de controller in rekening te brengen die waar nodig de functionele eenheden configureert, en ook bepaalt welke data er bijvoorbeeld uit de registers wordt uitgelezen.
\paragraph{}
Concreet komt het kritische pad nog altijd neer op het langste combinatorische pad. De verleiding is groot om hierbij enkel het datapad in rekening te brengen: namelijk vanuit een register door een functionele eenheid naar een register. Om te beantwoorden aan de formele definitie dient men dus de controller mee in rekening te brengen. Bovendien is het nagenoeg altijd zo dat het kritische pad zowel door de controller en het datapad loopt. Een typisch kritisch pad vertrekt dan ook vanuit bijvoorbeeld de ingang van een register die de toestand van de controller bijhoudt. Hierdoor wordt een nieuwe toestand in de registers van de controller geklokt. Vervolgens loopt het kritische pad doorheen de uitvoer-logica van de controller naar bijvoorbeeld een register van waaruit data dan door een functionele eenheid loopt om vervolgens ofwel terug te keren als status-signaal naar de controller of als resultaat-signaal naar de flipflop.
\paragraph{}
Het concreet bepalen van het kritisch pad is geen sinecure. Meestal stelt men tabellen op per functionele eenheid/register om te bepalen hoelang het signaal onderweg is, en wordt op basis van de tabellen dan het kritische pad bepaald. Meestal kan men het kritisch pad ook niet meteen vertalen naar de klokfrequentie: men dient meestal enige buffer te nemen die te wijten is aan meta-stabiliteit, lange lijnen, enzovoort.
\subsection{Verschoven kloksignalen (``clock skew'')}
\ssclab{clockSkew}
In het vorige hoofdstuk hebben we het reeds gehad over ``skew''. Een speciaal geval van skew die in de context van processoren belangrijk wordt is \termen{clock skew}, dit is de verschuiving van het kloksignaal. Processoren zijn immers grote en complexe schakelingen. Een constante doorheen de schakeling is echter dat de controller, de registers en eventuele RAM-geheugens allemaal afhankelijk zijn van \'e\'en en hetzelfde kloksignaal. Het gevolg is dat een verandering die aanvangt bij de klok zelf niet altijd op alle plaatsen in de schakeling op hetzelfde moment wordt waargenomen. Oorzaken van de vertraging zijn:
\begin{enumerate}
 \item Vertraging op de verbinding
 \begin{enumerate}
  \item Een verbinding die over de volledige schakeling loopt is relatief lang. Hoewel de snelheid van een elektrisch signaal twee derde van de lichtsnelheid bedraagt, is de frequentie zeer hoog en kan een relatief kleine afstand toch een significant tijdsverschil betekenen in verhouding tot de periode van de klok.
  \item Wanneer we werken met een FPGA doorloopt een kloksignaal meestal \'e\'en of meerdere schakelmatrices. Deze matrices zijn opgebouwd uit poorten die een significante vertraging teweeg brengen.
 \end{enumerate}
 \item Combinatorische logica op het klokpad
 \begin{enumerate}
  \item Sommige schakelingen werken met een clock-enabled. Een clock-enabled werkt door het kloksigaal door een AND-poort te sturen. Deze AND-poort levert een extra vertraging op.
  \item Een \termen{Klokbuffer}: een poort mag slechts een beperkte fan-out hebben. Het kloksignaal wordt echter gepropageerd naar een zeer groot aantal componenten. Men propageert het signaal dan ook door een hi\"erarchische structuur van klokbuffers. Wanneer componenten echter niet aangesloten zijn op dezelfde diepte van deze hi\"erarchie, ontstaat er een tijdsverschil.
 \end{enumerate}
 \item Verschillende daal- en stijgtijden: door verschillende capacitieve belasting (tussen bijvoorbeeld twee klokbuffers) zijn de vertragingen op lange lijnen -- zelfs al zijn ze identiek in lengte -- niet altijd gelijk. Wanneer een bepaalde lijn bijvoorbeeld een grote oppervlakte aan metaal vertegenwoordigt, stijgt de capaciteit van de virtuele condensator.
\end{enumerate}
\paragraph{Clock enabled bij laadbare registers}
In registers werken we vaak met een clock enabled. Dit is een belangrijke oorzaak van clock skew en kan zelfs leiden tot het inklokken van foute waarden: wanneer de data aan de ingang zelf afhankelijk is van de klok en sneller wordt aangepast dan de het signaal door de AND-poort propageert, wordt soms de nieuwe waarde opgeslagen.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{loadregi-mux}{Met multiplexer.}
\importtikzsubfigure{loadregi-cle}{Met clock enabled.}
\caption{Laadbaar registers}
\figlab{loadregi}
\end{figure}
Er zijn dan ook grofweg twee technieken om een selectief op bepaalde klokflanken nieuwe waarden op te slaan:
\begin{enumerate}
 \item Met behulp van een multiplexer (zoals bij \figref{loadregi-mux});
 \item Met behulp van een AND-poort (zoals bij \figref{loadregi-cle}).
\end{enumerate}
Zoals zo vaak is geen van de twee technieken altijd te verkiezen: beide implementaties hebben hun voor- en nadelen. Zo kost register met multiplexer $6$ transistoren per bit meer dan een AND-poort. Ook het energie-verbruik ligt hoger: het kloksignaal komt immers in de flipflop terecht waar een groot aantal transistoren zullen schakelen. Dit verbruik is nutteloos wanneer we geen nieuwe gegevens willen inklokken en we dus opnieuw dezelfde waarde op de data-ingang aanbieden. Anderzijds is een multiplexer een vrij veilige optie. De nadelen van een AND-poort zijn dat dit typisch clock-skew introduceert omdat het kloksignaal duidelijk vertraging oploopt wanneer het door de AND-poort propageert. Wanneer het kloksignaal hoog is, mag de ``clock enabled'' bovendien niet zomaar worden veranderd: de flipflop zou dit immers interpreteren als een veranderend kloksignaal. Het vereist dus wat ontwerpervaring om implementatie met een AND-poort veilig te stellen.
\subsection{Synchroniseren van asynchrone ingangen}
Ondanks voorzichtig ontwerp van een niet-programmeerbare processor, komt invoer doorgaans van buiten de schakeling. Deze data wordt misschien ook door een synchrone schakeling -- bijvoorbeeld een processor -- aangeboden, maar het synchroniseren van verschillende klokken is onmogelijk. Zelfs in eenzelfde synchrone schakeling kunnen bovendien synchronisatieproblemen ontstaan, bijvoorbeeld wanneer bepaalde delen van de schakeling sneller resultaten berekenen. Dergelijke effecten maken het echter niet evident om logica te ontwikkelen: meestal gaan we ervan uit dat tijdens berekeningen van de processor de ingang niet zomaar een andere waarde aanneemt. Stel dat de processor afwisselend de twee getallen aan de ingang optelt en aftrekt maken we meestal de assumptie dat halverwege de optelling de operanden niet veranderen. Om asynchrone veranderingen op te vangen gebruikt men doorgaans flipflops die de waarden aan de ingangen op vaste momenten inlezen. De data-uitgangen van deze flipflops zijn gedurende een klokflank stabiel.
\paragraph{}
Dit is echter de theorie en ook hier kunnen dingen foutlopen. Een signaal moet immers een tijdje op de ingang van een flipflop worden aangelegd voor de klokflank om het correct in te klokken. Indien de gegevens op tijd worden aangelegd is er dus geen probleem. Wanneer de gegevens echter kort voor de klokflank worden aangeleverd kunnen er verschillende problemen ontstaan:
\begin{itemize}
 \item De gegevens komen te laat waardoor de oude gegevens na de klokflank op de uitgang van de flipflops worden aangelegd. De gegevens komen dan meestal met vertraging van \'e\'en klokflank wel beschikbaar. Dit wordt ge\"illustreerd in periode $a$ op \figref{synchronization-problems}.
 \item Een deel van de gegevens wordt correct ingeklokt, een ander deel wordt foutief ingelokt, dit kan ertoe leiden dat de flipflops invoer aanleggen die zelfs niet mogelijk werd geacht. Dit wordt ge\"illustreerd in periode $b$ op \figref{synchronization-problems}.
 \item \'E\'en of meer flipflops komen in een metastabiele toestand terecht: er wordt noch $0$ noch $1$ op de ingang aangelegd. Het duurt een zekere tijd voor een flipflop uit dergelijke toestand gaat. Dit effect kan ook optreden wanneer de nieuwe data al lang op de flipflop wordt aangelegd. Dit wordt ge\"illustreerd in periode $c$ op \figref{synchronization-problems}.
\end{itemize}
Aan de eerste twee problemen is weinig te verhelpen. In de praktijk zal men dit meestal oplossen met een synchronisatiesignaal: men stuurt bijvoorbeeld het kloksignaal mee op \'e\'en van de verbindingen tussen de twee circuits, of in het geval er maar af en toe data op de ingang komt te staan kondigt men dit aan door de ingangen met de regelmaat van de klok te laten veranderen van signaal\footnote{Dit is het geval bij Ethernet (IEEE 802.3).}.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{synchronization-circuit}{Schakeling.}
\importtikzsubfigure{synchronization-problems}{Problemen met synchronisatie.}
\figlab{synchronization}
\caption{Synchronisatie.}
\end{figure}
\paragraph{}
Metastabiliteit is echter een probleem waar men wel iets aan kan doen. Uit \sscref{flipflop} weten we immers dat de kans dat een schakeling zich na een zekere tijd nog steeds in een metastabiele toestand bevindt, exponentieel daalt met de tijd. Als we dus een redelijk termijn wachten, kunnen we vrij zeker stellen dat de de binnenkomende signalen niet metastabiel zijn. Deze tijd noemt men de \termen{metastability resolution time $t_r$}. Logischerwijs wensen we dat $t_r\geq t_{\mbox{\small meta}}$ met $t_{\mbox{\small meta}}$ de tijd om uit een metastabiele toestand te geraken. $t_r$ hangt echter van drie andere parameters af:
\begin{equation}
t_r=t_{\mbox{\small clock}}-t_{\mbox{\small comb}}-t_{\mbox{\small set-up}}
\end{equation}
Met $t_{\mbox{\small clock}}$ de periode van de klok, $t_{\mbox{\small comb}}$ de tijd die het signaal nodig heeft om door de combinatorische schakeling te propageren van het circuit en $t_{\mbox{\small set-up}}$ de set-up tijd om de resultaten op te slaan in de flipflops van het circuit\footnote{Bijvoorbeeld om op basis van de invoer een nieuwe toestand aan te nemen.}.
\importtikzfigure{synchronization-single}{De verschillende componenten van de ``metastability resolution time''.}
\paragraph{}
De klokperiode $t_{\mbox{\small clock}}$ staat in principe niet vast: we kunnen zelf de kloksnelheid bepalen, maar wensen meestal een hoge kloksnelheid. Bovendien wordt de kloksnelheid ook beperkt in de mate dat invoer beschikbaar komt: wanneer we bijvoorbeeld geluid verwerken moet we $40~\mbox{kHz}$ aan metingen kunnen aanbieden. In het geval we echter een niet-programmeerbare processor beschouwen, staat de toepassing meestal vast en dus ook de invoersnelheid van die toepassing. De kloksnelheid verder opdrijven heeft dan geen zin. We kunnen dus de klokperiode altijd proberen te maximaliseren.
\paragraph{}
Men kan ook inzetten op technologie. Snelle flipflops hebben een kortere set-up tijd en bovendien verkleint ook de halfwaardetijd: hierdoor zullen we dus ook sneller de metastabiele toestand verlaten. Bijgevolg wordt $t_{\mbox{\small meta}}$ kleiner. Een nadeel van deze flipflops is dat ze meer vermogen verbruiken.
\paragraph{}
Extra hardware kan ook een bijdrage leveren. Wanneer de processor de data moet verwerken met een bepaalde doorvoersnelheid, maar de vertraging niet zo belangrijk is\footnote{De vertraging is bijvoorbeeld wel van belang bij real-time applicaties zoals live televisie-uitzendingen en \emph{Skype}.} kan men in plaats van \'e\'en flipflop, een opeenvolging aan flipflops plaatsen. Men geeft hierdoor meer tijd aan het signaal om uit de metastabiele toestand te komen maar behoudt tegelijk een sterke (interne) klokfrequentie.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{synchronization-multi}{Zelfde kloksignaal.}
\importtikzsubfigure{synchronization-freq}{Trager kloksignaal.}
\caption{Metastabiliteit oplossen door een opeenvolging van flipflops.}
\end{figure}
\paragraph{}
Indien de ingangssignalen zelf met hoge frequentie worden aangeleverd kunnen we $n$ flipflops plaatsen die de synchronisatie uitvoeren. Een signaal propageert dus eerst door $n$ flipflops en heeft dus meer tijd om uit de metastabiele toestand te geraken. In dat geval is de resolutie-tijd:
\begin{equation}
\begin{array}{cr}
t_r=n\cdot\brak{t_{\mbox{\small clock}}-t_{\mbox{\small set-up}}}-t_{\mbox{\small comb}}&\mbox{(\figref{synchronization-multi})}
\end{array}
\end{equation}
Meestal volstaan $2$ of $3$ flipflops. Een abstracte implementatie staat beschreven in \figref{synchronization-multi}.
\paragraph{}
Soms verandert het signaal niet zo snel. Denk bijvoorbeeld aan een processor die een deling moet uitrekenen. Meestal zal de interne klok significant sneller klokken omdat er veel operaties moeten worden uitgevoerd om het quoti\"ent uit te rekenen, terwijl de invoer trager wordt aangepast, bijvoorbeeld maar om de 10 klokflanken. In dat geval kunnen we werken met twee flipflops die aan een lagere (in dit geval $\dfrac{1}{10}$ van de originele klokfrequentie nieuwe waardes opslaan. De resolutie-tijd wordt dan:
\begin{equation}
\begin{array}{cr}
t_r=n\cdot t_{\mbox{\small clock}}+t_{\mbox{\small clock}}-t_{\mbox{\small comb}}-2\cdot t_{\mbox{\small set-up}}&\mbox{(\figref{synchronization-freq})}
\end{array}
\end{equation}
Een abstracte implementatie staat beschreven in \figref{synchronization-freq}.