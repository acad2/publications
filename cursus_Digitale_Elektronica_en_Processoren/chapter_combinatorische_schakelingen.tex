\chapter{Combinatorische Schakelingen (Schakelingen zonder geheugen)}
\label{ch:combinatoric}
\chplab{combinatoric}
\chapterquote{Zelfs al zou er niets nieuws geschapen worden, dan is er nog altijd een nieuwe combinatie.}{Henry Ford, Amerikaans automobielfabrikant (1863-1947)}
\begin{chapterintro}
Nu we de basis van het bouwen van digitale circuits onder de knie hebben, en de fysische beperkingen hiervan kennen, wordt het tijd om ook schakelingen te ontwikkelen. \termen{Combinatorische Schakelingen} zijn schakelingen waarbij een bitvector aan uitgangen uitsluitend bepaald wordt aan de hand van een bitvector aan ingangen. We kunnen dus stellen dat het circuit een functie $\vec{f}(\vec{x})$ berekent. In sectie \ref{s:synthese} werd reeds een manier voorgesteld om tot een canonieke vorm te komen. In sectie \ref{s:minimalisatie} zullen we technieken zien om deze implementaties verder te minimaliseren. Verder zullen we in secties \ref{s:rekenkundig} en \ref{s:andereBasis} de implementatie van enkele populaire combinatorische schakelingen zien.% Tot slot zullen we ook combinatorische schakelingen in VHDL bouwen in sectie \ref{s:combinatorischVHDL}.
\end{chapterintro}
\minitoc[n]
\section{Minimaliseren van logische functies}
\label{s:minimalisatie}
\subsection{Waarom minimaliseren}
We willen schakelingen ontwerpen voor de worteltrekking en 7 segment display in een minimale implementatie. Streven naar een minimalisatie is een algemeen probleem en is vergelijkbaar met optimalisatie in de informatica. Minimalisatie levert niet enkel snellere doorvoer op. Hieronder sommen we de meest courante voordelen op, samen met hun metriek:
\begin{itemize}
\item Minimaliseren van de \termen{kostprijs}. Afhankelijk van de realisatie hanteren we hiervoor 2 metrieken: Voor CMOS verfijnen we hiervoor de oorspronkelijke formule van de kostprijs uit vergelijking \ref{eqn:kosten}. En bekomen:
\begin{equation}
\mbox{kostprijs}=\displaystyle\sum_{\tiny\begin{array}{c}\mbox{alle}\\\mbox{poorten}\end{array}}{\mbox{kostprijs}\left(\mbox{poort}\right)}
\label{eqn:kostenCmos}
\end{equation}
De kostprijs van een poort wordt dan bepaald met volgende formule:
\begin{equation}
\mbox{kostprijs}\left(\mbox{poort}\right)=\left\{\begin{array}{lcl}
\mbox{fan-in}&\mbox{if}&\mbox{poort}\in\left\{\mbox{INV},\mbox{NAND},\mbox{NOR},\mbox{AOI},\mbox{OAI}\right\}\\
\mbox{fan-in}+1&\mbox{if}&\mbox{poort}\in\left\{\mbox{AND},\mbox{OR}\right\}\\
\end{array}\right.
\label{eqn:kostenCmosPoort}
\end{equation}
We zien dus dat alle \termen{inverterende poorten} relatief 1 goedkoper zijn dat de \termen{niet-inverterende poorten}. Bij een FPGA bepalen we de kostprijs aan de hand van het aantal logische cellen:
\begin{equation}
\mbox{kostprijs}=\#\mbox{LB's}
\end{equation}
Uiteraard dient hierbij de kanttekening gemaakt te worden, dat niet voor elk aantal logische cellen, er een FPGA bestaat. Indien er voldoende logische cellen op de FPGA aanwezig zijn, is de kostprijs dan ook van minder belang. We zullen immers toch dezelfde FPGA gebruiken.
\item Snelheid: We maximaliseren de snelheid door de maximale vertraging te minimaliseren. Deze vertraging is afhankelijk van de poorten in het \termen{Kritische Pad}. Het kritische pad is een pad van de ingang naar de uitgang met de grootste vertraging. Deze vertraging is afhankelijk van twee parameters:
\begin{itemize}
\item Vertraging van de poorten: een poort heeft tijd nodig om bij verandering van de ingang ook de uitgang te veranderen. Deze vertraging is afhankelijk van de technologie en evenredig met de fan-in. We zullen deze benaderen met volgende formule:
\begin{equation}
\mbox{vertraging}\left(\mbox{poort}\right)=\left\{\begin{array}{lcl}
0.6+0.4\cdot\mbox{fan-in}&\mbox{if}&\mbox{poort}\in\left\{\mbox{INV},\mbox{NAND},\mbox{NOR},\mbox{AOI},\mbox{OAI}\right\}\\
1.6+0.4\cdot\mbox{fan-in}&\mbox{if}&\mbox{poort}\in\left\{\mbox{AND},\mbox{OR}\right\}\\
\end{array}\right.
\label{eqn:speedPoort}
\end{equation}
Deze formule toont dus dat opnieuw de fan-in een belangrijke factor is, en dat niet-inverterende poorten opnieuw een nadeel hebben tegenover inverterende poorten.
\item (capacitieve) belasting: dit hangt hoofdzakelijk af van de geometrische implementatie van de printplaat. Deze vertraging is dan ook zeer moeilijk te berekenen en wordt niet beschouwd.
\end{itemize}
Bijgevolg berekenen we de vertraging als volgt:
\begin{equation}
\mbox{vertraging}=\displaystyle\sum_{\tiny\begin{array}{c}\mbox{kritisch}\\\mbox{pad}\end{array}}{\mbox{vertraging}\left(\mbox{poort}\right)}
\label{eqn:speed}
\end{equation}
\end{itemize}
\paragraph{Hoe minimaliseren?}Om te minimaliseren hebben we een methode nodig, deze methode manipuleert de logische uitdrukking van $\vec{f}(\vec{x})$ tot een uitdrukking die equivalent maar voordeliger is, rekening houdend met de metrieken van vergelijkingen \ref{eqn:kostenCmos} en \ref{eqn:speed}. Het probleem is dat er geen methodes bestaan die ons een reeks manipulaties voorstellen, waardoor we altijd tot de meest optimale implementatie komen. We moeten dus bijgevolg methodes bedenken waardoor we in staat zijn tot een redelijk optimale oplossingen te komen. Hiervoor zullen we methodes gebruiken zoals Karnaugh-kaarten. Computers bieden bovendien de mogelijkheid een groot aantal implementaties te simuleren. Bij een groot probleem volstaat deze rekenkracht echter ook niet om tot de beste implementatie te komen\footnote{Wat is \"uberhaupt de beste oplossing, in veel gevallen zal de ene metriek verbeteren ten koste van de tweede.}.
\subsection{Karnaugh-kaarten}
\termen{Karnaugh-kaarten} of \termen{K-kaarten} proberen het aantal nutteloze ingangen tot een minimum te beperken. Het is een visueel hulpmiddel dat gebruik maakt van een vermogen waar mensen goed in zijn: het herkennen en begrijpen van patronen. De basis van een Karnaugh-kaart is dan ook de waarheidstabel. In een waarheidstabel kunnen we vaak door bepaalde rijen te beschouwen verbanden zien.
%Zo zien we in de waarheidtabel op figuur \ref{fig:sevenSegmentDisplay} dat $e=0$ als $w=1$. Uiteraard blijft er onduidelijkheid waarom $e=0$ als $\left(w,x,y,z\right)=\left(0,1,0,0\right)$. Toch kunnen we met dergelijke patronen de expressie al behoorlijk optimaliseren. Zo kunnen we voor $e$ al een expressie maken van de vorm $e=(\mbox{NOT }w)\mbox{ AND }\varphi$ met $\varphi$ een nog onbekende logische expressie. We weten immers dat indien $w=1$ er een 0 aan de ingang van de AND poort verschijnt. Een AND met aan minstens \'e\'en ingang een 0 is per definitie 0. We hebben dus het probleem kunnen reduceren met het zoeken naar een specifiek patroon.
\paragraph{N-kubus}In feite zijn Karnaugh-kaarten niets anders dan waarheidstabellen waarbij we het aantal dimensies verhogen. Een zogenoemde \termen{$N$-kubus}. We stellen immers een bepaalde ingangstoestand voor als een knooppunt op een kubus. Figuur \ref{fig:nCube} toont een N-kubus voor de dimensies 1 tot 4.
\begin{figure}[htb]
\centering
\subfigure[1D]{\importtikz{kubus1d}}
\subfigure[2D]{\importtikz{kubus2d}}
\subfigure[3D]{\importtikz{kubus3d}}
\subfigure[4D]{\importtikz{kubus4d}}
\caption{N-kubus voor dimensies 1 tot 4.}
\figlab{nCube}
\end{figure}
Hierbij is elke knoop van de kubus een bitvector van waarden aan de ingang. We kunnen dan vervolgens op deze knooppunten de waarde die we aan de uitgang verwachten plaatsen. De $N$-kubus toont ook de buren van deze toestanden. Dit zijn toestanden waarbij exact \'e\'en bit aan de ingang veranderd is. Buren zijn cruciaal, indien de uitgang niet verandert tussen twee buren, kunnen we zeggen dat de veranderde ingangsbit irrelevant is voor de uitgang.
\paragraph{Karnaugh-Kaarten}Karnaugh-kaarten zijn in feite niets anders dan 2D projecties van de $N$-kubus. Uiteraard is deze omvorming tot 2 dimensies helemaal niet moeilijk: het is gewoon de $N$-kubus zelf. Vanaf dimensies hoger dan 2 wordt het moeilijker. Figuur \ref{fig:nCubeKarnaugh}
\importtikzfigure{nCubeKarnaugh}{Van $N$-kubus naar Karnaugh-kaart.}
toont de overgang van een 3-kubus naar de respectievelijke Karnaugh-kaart. Bij een $N$-kubus heeft elke toestand $N$ buren. Nochtans zien we op de figuur dat de linkse en rechtse toestanden slechts 2 buren hebben in plaats van 3. We moeten dan ook op een Karnaugh-kaart modulo rekenen. De linkse buur van het meest linkse veld is het rechtse veld. Verder omvat elke cel in de Karnaugh-kaart een bepaalde configuratie aan de ingang. Aan de rand van de Karnaugh-kaart staan de variabelen, en een lijn. De cellen die deze lijn omvatten zijn de cellen waar deze specifieke variabele 1 is. Logischerwijs zijn de cellen die niet omvat worden, de cellen waar deze variabele 0 is. Figuur \ref{fig:karnaughKaarten}
\begin{figure}[hbt]
\centering
\subfigure[1D]{\importtikz{karnaugh1d}}
\subfigure[2D]{\importtikz{karnaugh2d}}
\subfigure[3D]{\importtikz{karnaugh3d}}
\subfigure[4D]{\importtikz{karnaugh4d}}
\subfigure[5D gespiegeld]{\importtikz{karnaughKaarten5DMirror}}
\subfigure[5D gekopieerd]{\importtikz{karnaughKaarten5DCopy}}
\caption{Karnaugh-kaarten voor verschillende dimensies met binaire waarden.}
\figlab{karnaughKaarten}
\end{figure}
toont Karnaugh-kaarten voor een verschillend aantal variabelen. In de cellen staat de decimale waarde van de ingang die deze cel vertegenwoordigt. Hierbij gebruiken we de variabelen in de volgende volgorde: $\left(v,w,x,y,z\right)$. We kunnen in principe blijven uitbreiden. Vanaf 6 dimensies wordt het echter moeilijk om nog patronen te herkennen. Karnaugh-kaarten hebben bijgevolg maar een beperkt vermogen. Vanaf 5 dimensies groepeert men meestal cellen in groepen van $4\times 4$. Men gebruikt hierbij 2 varianten: ofwel spiegelt men \'e\'en van de twee tabellen zoals op figuur \ref{fig:karnaughKaarten5DMirror}, ofwel zijn de tabellen exacte kopies (op enkele variabelen na) zoals op figuur \ref{fig:karnaughKaarten5DCopy}. Het spiegelen van variabelen is intu\"itiever omdat dit consistent is met lagere dimensies.
\subsubsection{Optimaliseren met behulp van Karnaugh-kaarten}
\paragraph{Terminologie} Alvorens we aan het optimalisatiewerk kunnen beginnen, hebben we nood aan enige terminologie. Een \termen{implicant} is een productterm waarvoor de functie 1 is. Deze definitie heeft nauwe banden met de 1-minterm, het verschil is echter dat bij een implicant niet alle variabelen aanwezig moeten zijn. Zo zien we op figuur \ref{fig:karnaughKaartenImplicanten} verschillende implicanten met een verschillend aantal variabelen. Een \termen{priemimplicant} is een implicant die geen onderdeel is van een andere implicant met strikt minder variabelen. De priemimplicanten van figuur \ref{fig:karnaughKaartenImplicanten} worden weergegeven op figuur \ref{fig:karnaughKaartenPriemimplicanten}. Een verdere uitbreiding is de \termen{essenti\"ele priemimplicant}, dit is een priemimplicant die minstens \'e\'en 1-minterm omvat die niet in een andere priemimplicant verweven zit. Tenslotte defini\"eren we de \termen{dekking} of \termen{cover} als een verzameling van implicanten die in alle mogelijkheden voorziet waar de functie 1 is.
\begin{figure}[hbt]
\centering
\subfigure[Implicanten]{\importtikz{karnaughKaartenImplicanten}}
\subfigure[Priemimplicanten]{\importtikz{karnaughKaartenPriemimplicanten}}
\subfigure[Essenti\"ele priemimplicanten]{\importtikz{karnaughKaartenEssentielePriemimplicanten}}
\caption{Terminologie van een Karnaugh-kaart.}
\figlab{karnaughKaartTerminologie}
\end{figure}
\paragraph{Stappenplan}
We minimaliseren een functie met behulp van een Karnaugh-kaart in 4 stappen, deze stappen zullen we in de volgende paragrafen besproken:
\begin{enumerate}
 \item Maak de Karnaugh-kaart.
 \item Bepaal alle priemimplicanten.
 \item Bepaal alle essenti\"ele priemimplicanten.
 \item Zoek de minimale dekking.
\end{enumerate}
Daarna zullen we nog drie speciale gevallen bestuderen.
\paragraph{}
We bestuderen deze methode aan de hand van een voorbeeld. We zullen een schakeling synthetiseren die de functies $f$ en $g$ berekent. Functie $f$ geeft 1 terug bij de getallen 0, 1, 3, 7, 5, 8, 10, 11, 14 en 15, en 0 in de andere gevallen, $g$ is waar  als de afgeronde vierkantswortel van het getal even is.
\paragraph{Stap 1: maak de Karnaugh-kaart}
In de eerste stap bouwen we een Karnaugh-kaart op, op basis van de gegeven functie. We tekenen een Karnaugh-kaart met het juiste aantal ingangsvariabelen (zie figuur \ref{fig:karnaughKaarten}) en vullen vervolgens de uitgangswaarden voor \'e\'en bepaalde uitgang in op de respectievelijke plaatsen. Er dient dus per binaire uitgang zo'n kaart gemaakt te worden. Op figuur \ref{fig:karnaughKaartenVoorbeeldGetekend}
\importtikzfigure{karnaughKaartenVoorbeeldGetekend}{Ingevulde Karnaugh-kaarten voor de uitgangen van het leidend voorbeeld.}
%tonen we de Karnaugh-kaarten voor de eerste 3 uitgangen van het leidend voorbeeld ($a$, $b$ en $c$). De overige uitgangen worden als oefening aan de lezer overgelaten. De oplossing is te vinden op figuur \ref{fig:apxKKaartenFill} op pagina \pageref{fig:apxKKaartenFill}.
staan de Karnaugh-kaarten voor de functies $f$ en $g$. De variabelen $x_1$, $x_2$, $x_3$ en $x_4$ zijn de binaire voorstelling van het invoergetal.
\paragraph{Stap 2: bepaal alle priemimplicanten} In de volgende stap bepalen we alle priemimplicanten van de Karnaugh-kaart. Visueel is een implicant niets anders dan een rechthoek waarbij zowel de lengte en breedte een lengte hebben van machten van twee. Deze rechthoeken vallen uiteraard ook onder de modulo-regel op een Karnaugh-kaart. Deze priemimplicanten kunnen we dan ook vinden door vanuit een cel waar de uitgangswaarde 1 is, telkens ofwel de lengte ofwel de breedte te verdubbelen, uiteraard mogen er wel geen nullen onder de rechthoek vallen. Indien er verschillende uitbreidingen mogelijk zijn, dienen al de uitbreidingen gevolgd te worden. Figuur \ref{fig:karnaughKaartenVoorbeeldPriemimplicanten} toont de priemimplicanten voor de twee uitgangen van het leidend voorbeeld.
\importtikzfigure{karnaughKaartenVoorbeeldPriemimplicanten}{Karnaugh-kaarten met priemimplicanten van het leidend voorbeeld.}
\paragraph{Stap 3: Bepaal alle essenti\"ele priemimplicanten} Nadat we de priemimplicanten bepaald hebben, zullen we uit deze verzameling de essenti\"ele priemimplicanten halen. Deze stap is dan ook heel eenvoudig: als een priemimplicant \'e\'en of meer cellen omvat die geen enkele andere priemimplicant omvat is het een essenti\"ele priemimplicant. Deze implicaten zullen sowieso al tot de resulterende functie behoren. Op figuur \ref{fig:karnaughKaartenVoorbeeldEssentielePriemimplicanten} staan de essenti\"ele priemimplicanten voor $f$ en $g$. We zien duidelijk dat in beide gevallen de priemimplicanten onvoldoende zijn om de volledige functie te beschrijven daar er nog enen niet niet gedekt worden.
\importtikzfigure{karnaughKaartenVoorbeeldEssentielePriemimplicanten}{Karnaugh-kaarten met essenti\"ele priemimplicanten van het leidend voorbeeld.}
\paragraph{Stap 4: Zoek de minimale dekking}
De essenti\"ele priemimplicanten zijn de goedkoopste manier om de cellen die ze dekken te implementeren, we zien echter dat dit in de meeste gevallen onvoldoende is om de volledige functie te beschrijven. We dienen nog extra priemimplicanten toe te voegen om tot volledige dekking te komen. In het ideale geval doen we dit door alle mogelijke toevoegingen van priemimplicanten na te gaan. Dit is echter een erg arbeidsintensief proces. Men lost dit probleem dan ook meestal op met een ``\termen{gulzige strategie}'' ofwel ``\termen{greedy algorithm}''. Hierbij beschouwen we initieel de set van essenti\"ele priemgetallen, per iteratie voegen we de priemimplicant toe die het meeste aantal cellen dekt die tot dan toe ongedekt bleven. We stoppen op het moment dat de set van implicanten de volledige functie dekt. We illustreren dit proces op figuur \ref{fig:karnaughKaartenVoorbeeldGreedySearch} waarbij we elke iteratiestap tonen.
\importtikzfigure{karnaughKaartenVoorbeeldGreedySearch}{Werking van het greedy algoritme bij het leidend voorbeeld.}
\paragraph{Synthese}
Elk van de priemimplicanten die we geselecteerd hebben stelt het product voor van enkele variabelen. We implementeren de functie door de som te nemen van deze priemimplicanten. Voor het voorbeeld wordt dit dus:
\begin{equation}
\begin{array}{ll}
\left\{
\begin{array}{l}
f=x_2'x_3'x_4'+x_1'x_4+x_1x_3\\
g=x_1'x_3'x_4'+x_1'x_2'x_3x_4+x_2x_3x_4'+x_2x_3'x_4+x_1x_2x_3
\end{array}\right.&\mbox{(Leidend voorbeeld)}
\end{array}
\end{equation}
\paragraph{Uitbreiding: Dambordpatroon}
Een patroon die men vaak tegenkomt in Karnaugh-kaarten is het \termen{dambordpatroon}. Dit dambordpatroon hoeft niet noodzakelijk uit vierkanten te bestaan, rechthoek zijn ook mogelijk. Indien we dit patroon met de klassieke Karnaugh-methode implementeren bekomen we een groot aantal priemimplicanten wat leidt tot kostelijke implementaties, we kunnen in dat geval gebruik maken van XOR-operaties die we achter elkaar schakelen. Een aaneenschakeling van XOR-operaties heeft een grotere vertraging maar heeft een grote invloed op de kostprijs. Figuur \ref{fig:dambordpatronen} toont enkele dambordpatronen en hun implementatie met XOR-logica.
\importtikzfigure{dambordpatronen}{Voorbeelden van dambordpatronen in Karnaugh-kaarten.}
\paragraph{Uitbreiding: Don't cares}
\label{par:dontcare}
In sommige gevallen dienen we slechts een beperkte set van invoer-configuraties te beschouwen. Stel bijvoorbeeld dat we een digitale display implementeren die getallen van 0 tot en met 9 voorstelt. In dat geval hebben we 4 ingangen nodig. Maar we zullen bijvoorbeeld nooit de ingang $1011_2=11_{10}$ tegenkomen. Er is echter wel een plaats gereserveerd op de Karnaugh-kaart voor deze configuratie. In dat geval maken we gebruik van de zogenaamde \termen{don't care}. Dit wordt genoteerd met een horizontale streep\footnote{Engels: dash.}, een ``X'' of ``d''. Een don't care is geen speciale vorm van uitvoer. We kunnen enkel nullen of enen teruggeven. Een don't care wordt enkel gebruikt om aan te geven dat we vrij mogen kiezen of de uitvoer een 0 of 1 wordt. Uiteraard proberen we een keuze te maken die de implementatie goedkoper maakt. We kunnen tot betere implementaties komen door een don't care als een 1 te zien indien dit de priemimplicanten kan vergroten. Op die manier bereiken deze priemgetallen immers een groter gebied waardoor ze minder variabelen bevatten. Op figuur \ref{fig:sevenDigitDisplay} geven we de Karnaugh-kaart van led $A$ en $B$ bij een \termen{seven-segment display}, samen met de priemimplicanten die we bekomen na het toewijzen van de don't cares. In appendix ?? staan de Karnaugh-kaarten van de andere leds. Deze kaarten zijn een goede oefening om het volledige proces te leren.
\importtikzfigure{sevenDigitDisplay}{Karnaugh-kaart met don't cares van led $A$ en $B$ van een seven-segment display.}
\paragraph{Uitbreiding: Meerdere uitgangen}
Tot dusver hebben we steeds aangenomen dat we de functie voor \'e\'en signaaluitgang optimaliseren, uit de voorbeelden die we beschouwd hebben blijkt echter dat een component verschillende uitgangen moet uitrekenen (de seven-segment display). Daar we de functies implementeren met AND-OR logica is het mogelijk dat de AND-poorten van \'e\'en uitgang ook nuttig kunnen zijn voor de uitgang van een andere uitgang. Dit leidt misschien niet tot de goedkoopste schakeling per uitgang maar globaal kunnen we eventueel kosten besparen. We zullen hieronder een procedure bespreken die gebruik maakt van de priemimplicanten, er is echter geen garantie dat deze de globale goedkoopste schakeling realiseert. Soms is het zelfs goedkoper om met niet-priemimplicanten te werken. Met trail-and-error kunnen we dus soms tot nog goedkopere implementaties komen. Volgende procedure bekomt echter meestal een goed resultaat:
\begin{enumerate}
 \item We realiseren eerst bij elke uitgang de essenti\"ele priemimplicanten.
 \item Selecteer vervolgens priemimplicanten die essenti\"ele priemimplicanten zijn bij een andere uitgang. Bij deze keuze is het ook belangrijk om de priemimplicant te selecteren die in het kleinste aantal functies voorkomt, dit doen we om de fan-out laag te houden waardoor we minder vertraging induceren. Merk op dat deze operatie ons niets kost: we hebben immers deze implicanten al gerealiseerd.
 \item De overige priemimplicaten realiseren we per uitvoer zoals op de klassieke manier. Indien een priemimplicant in verschillende uitgangen voorkomt, kunnen we deze eventueel bevoordelen.
\end{enumerate}
\paragraph{Duale vorm}
Tot dusver hebben we telkens met behulp van Karnaugh-kaarten een AND-OR implementatie gerealiseerd. Zoals we al vaak zijn tegengekomen hebben quasi alle logische methodes een duale vorm. Ook de Karnaugh-kaarten kunnen we gebruiken om een minimale OR-AND implementatie te realiseren. In tegenstelling tot de AND-OR vorm draait alles hier rond nullen en niet rond enen. De priemimplicaten zijn hierbij gerelateerd aan 0-maxtermen: functies die overal 1 teruggeven behalve op een bepaald patroon. Verder werkt deze methode volledig analoog: we bepalen eerst de essenti\"ele priemimplicanten en voegen vervolgens andere priemimplicanten toe. We synthetiseren vervolgens de schakeling door een AND tussen alle gekozen priemimplicanten te plaatsen. Op figuur \ref{fig:karnaughKaartenVoorbeeldDualeVorm} voeren we deze methode uit op de $f$-functie van het leidend voorbeeld.
\importtikzfigure{karnaughKaartenVoorbeeldDualeVorm}{Duale methode met Karnaugh-kaarten.}
\subsection{Quine-McCluskey}
Een alternatieve methode voor Karnaugh-kaarten is het \termen{Quine-McCluskey algoritme}. Dit algoritme wordt gebruikt in CAD-pakketten voor booleaanse optimalisatie en werkt op basis van tabellen. Het algoritme zoekt ook naar priemimplicanten en essenti\"ele priemimplicanten om een functie te optimaliseren en is dus het tabel-equivalent van de methode met de Karnaugh-kaarten. Het algoritme werkt in exponenti\"ele tijd, namelijk \bigoh{3^n} met $n$ het aantal variabelen. In de meeste gevallen is het aantal variabelen te groot om deze functie te optimaliseren, in dat geval wordt er gewerkt met de Espresso heuristic logic minimizer.
\subsection{Realisatie in meer dan 2 lagen}
Een Karnaugh-kaart laat toe tot een sterke implementatie te komen met twee lagen (een AND- en OR-laag). Zoals we echter in de volgende secties zullen zien, zullen complexe schakelingen bij twee lagen toch een hoge kost met zich meebrengen. Daarom is het soms aangewezen om de logica in meer lagen te implementeren. Dit veroorzaakt tragere schakelingen maar aan een goedkopere kostprijs. Hieronder geven we enkele technieken:
\begin{itemize}
 \item Specificatie: in heel wat gevallen gaat de specificatie van de component reeds gepaard met een expliciete implementatie. Bijvoorbeeld ``1 indien $x$ en ofwel $y$ ofwel $z$ en $t$'' kunnen we dan rechtstreeks implementeren als: $f=x\wedge\left(y\oplus\left(z\wedge t\right)\right)$.
 \item \termen{Factoranalyse}: We kunnen een expressie ook \termen{algebra\"isch manipuleren} met de wetten uit sectie \ref{s:booleaanseAlgebra}. Factoranalyse wordt ook gebruikt wanneer we een schakeling dienen te implementeren met beperkte fan-in: stel dat we enkel NAND-poorten met 2 ingangen ter beschikking hebben. Bij realisaties met beperkte fan-in moet men altijd proberen deze te implementeren in een boomstructuur. Indien we dus $f=x+y+z+t$ moeten implementeren converteren we dit naar $f=\left(x+y\right)+\left(z+t\right)$ en niet naar $f=x+\left(y+\left(z+t\right)\right)$. De boomstructuur laat toe schakelingen te realiseren die een vertraging van \bigoh{\log n} hebben tegenover de lineare implementatie met een vertraging van \bigoh{n}.
 \item \termen{Functionele ontbinding}: Soms zijn we ook in staat om een functie op te delen in verschillende deelfuncties. In subsectie \ref{sss:fulladder} zullen we bijvoorbeeld een volledige opteller beschouwen. In plaats van een optelling van drie bits rechtstreeks te implementeren kunnen we twee optellingen van twee bits realiseren. In het algemeen betekent dit dat we de functie $\vec{f}\left(\vec{x}\right)$ soms kunnen herschrijven als $\vec{h}\left(\vec{g}\left(\vec{x}\right),\vec{x}\right)$ waarbij $\vec{g}$ en $\vec{h}$ meestal eenvoudiger en goedkoper zijn.
\end{itemize}
Geen enkele van deze methodes levert altijd een betere resultaat het probleem moet dan ook opgelost worden in ``\termen{trial-and-error}'' stijl.
\subsection{Welke methode kiezen?}
Samen met de methodes uit subsectie \ref{ss:canoniekestandaardrealisatie} hebben we nu volgende methodes om een schakeling te synthetiseren:
\begin{itemize}
 \item Canonieke Sum-of-Products
 \item Canonieke Product-of-Sums
 \item Minimale Sum-of-Products (Karnaugh-kaarten)
 \item Minimale Product-of-Sums (Karnaugh-kaarten)
 \item Meerlagenlogica
\end{itemize}
\paragraph{}Verder kunnen we ook vrij kiezen tussen AND-OR en NAND-NAND in het geval van Sum-of-Products, en voor OR-AND en NOR-NOR bij Product-of-Sums. Het is altijd voordeliger om voor NAND-NAND en NOR-NOR te kiezen. Deze schakelingen zijn altijd goedkoper en sneller. Het aantal poorten en de structuur blijft immers gelijk en uit vergelijkingen (\ref{eqn:kostenCmosPoort}) en (\ref{eqn:speedPoort}) blijkt duidelijk dat dit een betere keuze is. Een andere mogelijkheid is om de Minimale AND-OR implementatie om te zetten naar een AND-OR-Invert en een OR-AND implementatie naar zijn OR-AND-Invert equivalent.
\paragraph{}Ook kunnen we in het algemeen bewijzen dat de implementatie met Karnaugh-kaarten altijd goedkoper en sneller is. Immers in het slechtste geval komt dit neer op dezelfde implementatie als de canonieke sum-of-products. In de meeste gevallen zal meerlagenlogica verder een grotere vertraging induceren dan de implementatie met Karnaugh-kaarten, dit is echter niet algemeen en bovendien kan meerlagenlogica gepaard gaan met grote kostenbesparingen. Veel rekenkundige schakelingen die we in de volgende sectie zullen tegenkomen maken dan ook gebruik van meerdere functionele lagen.
\paragraph{}Tot slot is het niet altijd belangrijk om tot de meest optimale implementatie te komen. Indien we bijvoorbeeld de logica op een FPGA programmeren hebben we per functie een logic block ter beschikking. Het aantal poorten in dit blok staat al vast. Indien we dus onder dat aantal blijven levert het ons niks op om de functie verder te minimaliseren. We hebben immers toch reeds voor deze poorten betaald. Deze realisatie van de schakeling naar de beschikbare elementen (poorten, logic blocks,...) wordt dan ook de ``\termen{technology mapping}'' genoemd.
\paragraph{}Om de verschillende implementaties te illustreren zullen we tot slot een schakeling implementeren in de verschillende vormen van logica. De Karnaugh-kaart en de implementaties staan op figuur \ref{fig:differentImplementationsSSD}. Een samenvatting van deze implementaties in termen van kosten en vertraging staan in tabel \ref{tbl:differentImplementationsSSD}.
\begin{figure}[hbt]
\centering
\subfigure[Karnaugh-kaart]{\importtikz{karnaughKaartSopPos}}
\subfigure[Canonieke SOP (AND-OR)]{\importtikz{canonicSop}}
\subfigure[Minimale SOP]{\importtikz{minimalSop}}
\subfigure[Canonieke POS (OR-AND)]{\importtikz{canonicPos}}
\subfigure[Minimale POS]{\importtikz{minimalPos}}
\caption{Verschillende implementaties van dezelfde logische functie.}
\figlab{differentImplementationsSSD}
\end{figure}
\begin{table}[hbt]
\centering
\begin{tabular}{l|l|rr|rr}
Modus&Implementatie&Kosten&Relatief&Vertraging&Relatief\\\hline
\multirow{2}{*}{Canonieke SOP}&AND-OR&47&100\%&8.6&100\%\\
&NAND-NAND&39&83\%&6.6&77\%\\\hline
\multirow{2}{*}{Canonieke POS}&OR-AND&59&126\%&9.4&109\%\\
&NOR-NOR&49&104\%&7.4&86\%\\\hline
\multirow{2}{*}{Minimale SOP}&AND-OR&16&34\%&6.6&77\%\\
&NAND-NAND&12&26\%&4.6&53\%\\\hline
\multirow{2}{*}{Minimale POS}&OR-AND&17&36\%&6.2&72\%\\
&NOR-NOR&13&28\%&4.2&49\%
\end{tabular}
\caption{Samenvatting van de verschillende implementaties.}
\tbllab{differentImplementationsSSD}
\end{table}
\section{Rekenkundige basisschakelingen}
\label{s:rekenkundig}
In deze sectie defini\"eren we enkele belangrijke schakelingen voor rekenkundige bewerkingen. We hebben het dan over optellen, aftrekken vermenigvuldigen, delen, modulo rekenen en logische berekeningen. Alvorens we echter met getallen kunnen rekenen, moeten we een manier bedenken om getallen voor te stellen met binaire signalen. Doorheen deze sectie zullen we de voorstelling van getallen regelmatig veranderen om extra functionaliteit toe te voegen.
\subsection{Getallen voorstellen}
In de wereld wordt bij het voorstellen van getallen meestal het Arabisch getalsysteem gehanteerd. Hierbij stellen we een getal voor door een reeks cijfers. Een cijfer op een bepaalde plaats heeft een gewicht dat $r$ keer groter is, dan het volgende cijfer, met $r$ als de \termen{radix} van het getalstelsel. Om tot een eenduidige voorstelling van elk getal te komen wordt de verzameling mogelijke cijfers beperkt tot $r$ elementen. Een getal $D_r$ wordt dus voorgesteld als:
\begin{equation}
D_r=d_{m-1}d_{m-2}\ldots d_0,d_{-1}\ldots d_{-n}=\displaystyle\sum_{i=-n}^{m-1}{r^i\times d_i}
\label{eqn:numberRepresentation}
\end{equation}
Hierbij zijn $d_i$ de cijfers van het getal. Wereldwijd gebruikt men het \termen{decimale stelsel}, andere populaire stelsel zijn het \termen{binair} ($r=2$), \termen{octaal} ($r=8$) en \termen{hexadecimaal} ($r=16$) stelsel. Het binaire stelsel heeft logischerwijs twee mogelijke cijfers. Deze kunnen we voorstellen door $0$ of $1$ op een lijn te zetten. Indien we meer cijfers nodig hebben, zullen we eenvoudigweg meer lijnen voorzien, die elk een cijfer van het getal voorstellen. In de informatica en elektronica maakt men theoretisch vaak gebruik van andere getalstelsel. Dit komt omdat binaire getallen niet bepaald compact zijn\footnote{Een binair getal bestaat uit $3.3$ keer het aantal cijfers van zijn decimale tegenhanger.}. Immers is het omzetten van binaire getallen naar hexadecimale getallen niets anders dan het groeperen van cijfers. Indien men getallen noteert met een andere radix dan de decimale, wordt de radix in decimale notatie als subscript toegevoegd. Zo is $\mbox{2A}_{16}$ het equivalent van $42$.
\subsection{Radix-conversie}
\subsubsection{$r_1\rightarrow r_2$ omzetting met $r_1=r_2^p$}
Een speciaal geval van omzetting treedt op indien de bronradix een macht is van de doel radix. In dat geval kunnen we de omzetting eenvoudig doen door alfabetomzetting. Immers betekent dit dat we elk broncijfer kunnen omzetten naar $p$ doelcijfers. Hierbij dient de sequentie doelcijfers het wiskundig equivalent te zijn van de broncijfers. Een concreet voorbeeld is het omzetten van een hexadecimaal getal in het binair stelsel ($r_1=16=2^4=r_2^4$). Tabel \ref{tbl:radixConversionHexOctBin}
\begin{table}[hbt]
\centering
\subtable[Hex $\leftrightarrow$ Binair]{
\begin{tabular}{r|r||r|r||r|r||r|r}
Hex&Bin&Hex&Bin&Hex&Bin&Hex&Bin\\\hline
0&0000&4&0100&8&1000&C&1100\\
1&0001&5&0101&9&1001&D&1101\\
2&0010&6&0110&A&1010&E&1110\\
3&0011&7&0111&B&1011&F&1111\\
\end{tabular}
}
\subtable[Octaal $\leftrightarrow$ Binair]{
\begin{tabular}{r|r||r|r}
Oct&Bin&Oct&Bin\\\hline
0&000&4&100\\
1&001&5&101\\
2&010&6&110\\
3&011&7&111\\
\end{tabular}
}
\caption{Radix-conversie van hexadecimaal en octaal naar binair.}
\tbllab{radixConversionHexOctBin}
\end{table}
toont de omzetting van hexadecimale en octale cijfers naar binaire cijfers. Bij wijzen van voorbeeld zetten we $\mbox{B4F}_{16}$ om naar het binaire stelsel\footnote{De verticale strepen ($|$) dienen uitsluitend om educatieve doeleinden, en zijn niet verplicht.}:
\begin{equation}
\mbox{B4F}_{16}=1011|0100|1111=101101001111_2
\end{equation}
\subsubsection{$r_1\rightarrow r_2$ omzetting met $r_1^q=r_2$}
In de omgekeerde situatie willen we een getal van een radix $r_1$ omzetten naar een macht van deze radix. De oplossing ligt dan ook voor de hand: we vertalen groepjes van $q$ broncijfers naar 1 doelcijfer. Een belangrijke opmerking is hoe we de voorstelling met de bronradix onderverdelen in groepen: dit doen we vanaf de komma voor het gehele gedeelte naar links, voor het kommagedeelte naar rechts. Aan de uiteinden van de voorstelling kunnen er soms onvoldoende cijfers aanwezig zijn. In dat geval dienen nullen toegevoegd te worden. Bij wijze van voorbeeld zetten we $1011011111.10001_2$ om naar zijn octale equivalent (zie hiervoor tabel \ref{tbl:radixConversionHexOctBin}):
\begin{equation}
1011011111.10001_2=1|011|011|111.100|01_2=\underline0\underline01|011|011|111.100|01\underline0_2=1337.42_8
\end{equation}
\subsubsection{$r_1\rightarrow r_2$ omzetting met $r_1^q=r_2^p$}
Een logisch gevolg van de voorgaande omzettingen, is dat we ook de mogelijkheid hebben om getallen makkelijk tussen 2 radixen om te zetten indien ze een gemeenschappelijke macht hebben. In dat geval laten we de conversie verlopen langs een derde radix: $r'$. $r'$ vormt een basis waarvan de bron- en doelradix machten zijn. Er geldt dan ook: $r_1=r'^p$ en $r'^q=r_2$. Een concreet voorbeeld is het binaire stelsel die als een tolk kan functioneren tussen het hexadecimale en octale stelsel. Dit illustreren we door $157255_8$ om te zetten naar het hexadecimaal stelsel:
\begin{equation}
\begin{array}{ll}
\mbox{Oct$\rightarrow$Bin}&157255_8=001|101|111|010|101|101_2=1101111010101101_2\\
\mbox{Bin$\rightarrow$Hex}&1101111010101101_2=1101|1110|1010|1101_2=\mbox{DEAD}_{16}
\end{array}
\end{equation}
\subsubsection{Algemene omzetting}
De vorige methodes werkten enkel onder een fundamentele aanname: de ene radix moest een macht van een andere zijn. In de praktijk is dit meestal niet zo, zo willen we vaak decimale getallen omzetten naar hun binair equivalent, of omgekeerd. In deze subsubsectie behandelen we kort een methode om in het algemeen een radixomzetting uit te voeren. Deze omzettingen zijn relatief arbeidintensief, en vereisen bovendien een getalstel waarin we simpele rekenkundige operaties kunnen uitvoeren. Voor mensen is dit over het algemeen het decimaal stelsel, computers werken doorgaans met het binair stelsel\footnote{Dit is niet altijd zo, in de Sovjet-Unie waren in de jaren '50 ternaire computers populair.}. In deze methode zetten we eerst de representatie om naar de representatie waarop we kunnen rekenen. Indien we bijvoorbeeld $\mbox{8C989}_{16}$ willen omzetten naar een radix 36, zullen we dit getal eerst omzetten naar het decimale stelsel, dit doen we door de waarde van de cijfers te vermenigvuldigen met het gewicht van hun positie en deze vervolgens op te tellen:
\begin{equation}
\mbox{8C989}_{16}=8\cdot 16^4+12\cdot 16^3+9\cdot 16^2+8\cdot 16^1+9\cdot 16^0=575881
\end{equation}
Vervolgens bepalen we iteratief elk cijfer, hierbij beginnen we bij het laatste cijfer, dit vinden we door het getal modulo de radix te bereken: $575881\mod36=25=\mbox{P}_{36}$. Hiermee weten we al het laatste cijfers. We trekken vervolgens de bekomen waarde af van het getal, en delen het door de radix. Dit resultaat kunnen we zo verder iteratief manipuleren, om de andere cijfers te berekenen. Indien we 0 uitkomen stopt het algoritme en hebben we de equivalente representatie gevonden. Tabel \ref{tbl:radixConversionExample} illustreert dit principe.
\begin{table}[hbt]
\centering
\begin{tabular}{r|r|l|l|r}
Stap&Getal&Modulo&Volgende getal&Cijfer\\\hline
$1$&$575881$&$575881\mod36=25$&$\left(575881-25\right)/36=15996$&$25=\mbox{P}_{36}$\\
$2$&$15996$&$15996\mod36=12$&$\left(15996-12\right)/36=44$&$12=\mbox{C}_{36}$\\
$3$&$444$&$444\mod36=12$&$\left(444-12\right)/36=12$&$12=\mbox{C}_{36}$\\
$4$&$12$&$12\mod36=12$&$\left(12-12\right)/36=0$&$12=\mbox{C}_{36}$\\
$5$&$0$&$-$&$-$&$-$
\end{tabular}
\caption{Voorbeeld van algemene radix-omzetting.}
\tbllab{radixConversionExample}
\end{table}
We kunnen dus concluderen dat: $\mbox{8C989}_{16}=\mbox{CCCP}_{36}$.
\subsection{Optellen}
\label{ss:add}
Hoe tellen we nu twee getallen op? In het decimaal stelsel tellen we twee getallen op door middel van cijferen. Hieronder geven we een illustrerend voorbeeld waarbij we $1425+1917$ uitrekenen:
\begin{equation}
\begin{array}{l|lcccc}
\mbox{overdracht $c$}&&1&0&1&\\
x&&1&4&2&5\\
y&+&1&9&1&7\\\hline
\mbox{som $s$}&&3&3&4&2
\end{array}
\end{equation}
Om getallen in het decimaal stelsel te kunnen optellen gebruiken we een repetitieve structuur, waarbij we 200 basisregels moeten onthouden. Zo'n basisregel $f\left(c_i,x_i,y_i\right)=\left(s_i,c_{i+1}\right)$ is een functie die de eventuele \termen{overdracht} of \termen{carry}, en de cijfers van de twee getallen in een bepaalde kolom omzet naar de overdracht van de volgende kolom en de som van deze kolom. Een voorbeeld van zo'n basisregel is $f\left(0,4,9\right)=\left(3,1\right)$. Deze regel wordt in ons voorbeeld gebruikt in de derde kolom vanaf rechts\footnote{We nummeren de kolommen vanaf rechts, analoog aan de getalvoorstelling van vergelijking (\ref{eqn:numberRepresentation})}. Binair optellen gebeurt volledig analoog, we hebben opnieuw met een repetitieve structuur te maken, alleen dienen we nu slechts 8 verschillende regels te onthouden.
\subsubsection{Half adder}
In deze paragraaf synthetiseren we een \termen{half adder (HA)}, die de laatste bit van de twee getallen optelt. Bij het laatste getal is de overdracht sowieso 0, dus daarmee hoeven we geen rekening te houden. We dienen een functie te ontwikkelen die de overdracht van de volgende kolom berekent, en de som. We stellen een waarheidstabel en de bijbehorende Karnaugh-kaarten op in figuur \ref{fig:halfAdder}.
\begin{figure}[hbt]
\centering
\subfigure[Waarheidstabel]{\importtikz{halfadder-truthtable}}
\subfigure[Karnaugh-kaarten]{\importtikz{halfadder-karnaugh}}
\subfigure[Interface]{\importtikz{halfadder-interface}}
\subfigure[Mogelijke implementatie]{\importtikz{halfadder-implementation}}
\caption{Half adder (HA).}
\figlab{halfAdder}
\end{figure}
Deze combinatorische functies kunnen we verwezenlijken met een AND en XOR poort.
\subsubsection{Full adder}
\label{sss:fulladder}
Met een Half adder kunnen we echter geen optellingen uitrekenen. Hiervoor dienen we een component te ontwikkelen die meer functionaliteit biedt: de \termen{full adder (FA)}. Een full adder bevat slechts \'e\'en ingang extra: de overdracht van de vorige opteller $c_i$. Een full adder telt op door een XOR operatie toe te passen op de drie ingangen: $x_i$, $y_i$ en $c_i$, verder is er sprake van overdracht indien twee of meer ingangen 1 zijn. Dit kunnen we eenvoudig implementeren met tweelagen-logica. De waarheidstabellen en Karnaugh-kaarten staan samen met een mogelijke implementatie op figuur \ref{fig:fullAdder}.
\begin{figure}[hbt]
\centering
\subfigure[Waarheidstabel]{\importtikz{fulladder-truthtable}}
\subfigure[Karnaugh-kaarten]{\importtikz{fulladder-karnaugh}}
\subfigure[Interface]{\importtikz{fulladder-interface}}
\subfigure[Mogelijke implementatie]{\importtikz{fulladder-implementation}}
\subfigure[Functionele ontbinding]{\importtikz{fulladder-functional}}
\caption{Full adder (FA).}
\figlab{fullAdder}
\end{figure}
We kunnen ook een implementatie synthetiseren met behulp van functionele ontbinding. Bij een full adder voeren we immers twee optellingen uit, de volgorde speelt hierbij geen rol. Indien minstens \'e\'en van de twee optellingen overdracht genereert, is er sprake van overdracht bij de full adder. We kunnen een full adder dus ook implementeren zoals op figuur \ref{fig:fulladder-functional}. Indien we de half adders dan implementeren zoals op figuur \ref{fig:halfadder-implementation}, zien we dat we \'e\'en poort uitsparen. Dit betalen we echter met grotere vertragingen, iets wat bij optellingen met grote getallen niet gewenst is.
\subsubsection{Ripple-carry opteller}
Met behulp van een half adder en $n$ full adders kunnen we vervolgens een opteller realiseren die twee $n+1$ bit getallen optelt. Dit doen we met behulp van een \termen{Ripple-carry opteller}. Figuur \ref{fig:rippleCarryAdder}%
\importtikzfigure{rippleCarryAdder}{Schematische voorstelling van een $n$-bit Ripple-carry opteller.}
toont hoe dit in z'n werk gaat: we tellen de laatste twee bits op met een half adder, de overige bits tellen we op met full adders. De carry uitgangen van een adder gaat naar de de ingang van de volgende adder. De allerlaatste carry uitgang $c_n$, kan men gebruiken als een \termen{overflow} uitgang. Indien we immers twee $n$-bit getallen met elkaar optellen, kunnen sommige resultaten $n+1$-bit getallen vereisen om nog voorgesteld te kunnen worden. In een ander geval wordt deze uitgang gebruikt om de waarde van de $n+1$-ste bit te bepalen. In dat geval heeft de uitgang meer bits dan de operanden. Uiteraard kunnen we de half adder vervangen door een full adder met als carry ingang 0.
\paragraph{}
Omdat we meestal getallen met een groot aantal bit optellen\footnote{Op de meeste processoren is dat 32 of 64 bit.} is het interessant om het tijdsgedrag van een ripple-carry adder te bekijken. Het kritisch pad gaat logischerwijs van een ingang van de half adder tot de laatste full adder. Indien we de implementaties van de full adder met functionele ontbinding beschouwen blijkt het kritische pad $x_0\rightarrow c_n$ te zijn. In dit geval moet het signaal doorheen 1 XOR, $n$ AND en $n$ OR poorten. Elk van deze poorten heeft twee ingangen, de vertraging is dus bijgevolg:
\begin{equation}
\mbox{vertraging}=2.4n+2.4n+3.2=4.8n+3.2
\end{equation}
Het is mogelijk dat we deze vertraging verder kunnen reduceren, een probleem is echter dat de vertraging een orde $n$ blijft. Voor berekeningen met grote getallen zijn ripple-carry adders dan ook onaanvaardbaar.
\subsubsection{Carry-lookahead opteller}
Een \termen{Carry-lookahead opteller (CLA)} is een component ter vervanging van een full adder. Het is de bedoeling om met behulp van deze component rechtstreeks $c_i$ te berekenen als een functie $c_i\left(c_0,x_0,x_1,\ldots,x_{i-1},y_0,y_1,\ldots,y_{i-1}\right)$. De Carry-lookahead opteller heeft dezelfde ingangen als een full adder: $(x_i,y_i,c_i)$, maar meer uitgangen $(c_{i+1},g_i,p_i,s_i)$. Deze uitgangssignalen hebben volgende functie:
\begin{itemize}
 \item \termen{carry-generate $g_i$}: 1 indien er bij het optellen van $x_i$ en $y_i$ overdracht gegenereerd wordt. Bijgevolg is $g_i=x_iy_i$.
 \item \termen{carry-propagate $p_i$}: 1 indien bij de optelling de overdracht verder gepropageerd zal worden. Bijgevolg $p_i=x_iy_i'+x_i'y_i$.
 \item som $s_i$: het resultaat van de optelling: $s_i=c_ip_i'+c_i'p_i$.
\end{itemize}
De opsomming van de uitgangen geeft dan ook al meteen een mogelijke implementatie; de waarheidstabellen, interface en een mogelijke implementatie staan op figuur~\ref{fig:carryLookaheadAdder}.
\begin{figure}[hbt]
\centering
\subfigure[Waarheidstabel]{\importtikz{cla-truthtable}}
\subfigure[Karnaugh-kaarten]{\importtikz{cla-karnaugh}}
\subfigure[Interface]{\importtikz{cla-interface}}
\subfigure[Mogelijke implementatie]{\importtikz{cla-implementation}}
\caption{Carry-Lookahead Opteller (CLA).}
\figlab{carryLookaheadAdder}
\end{figure}
Een belangrijke opmerking bij deze component is dat we de overdracht $c_{i+1}$ vervolgens kunnen berekenen als $c_{i+1}=g_i+c_ip_i$. De overdacht hangt dus niet rechtstreeks af van $x_i$ of $y_i$, deze eigenschap is belangrijk voor de synthese van een ander component: de CLA-generator.
\subsubsection{CLA-generator}
Om een opteller te realiseren moeten we, net zoals bij de Ripple-carry opteller, alleen nog de glue voorzien tussen de verschillende carry-lookahead optellers. Bij deze optellers is het verhaal echter gecompliceerder: we hebben een extra component nodig om de CLA elementen met elkaar te verbinden: de \termen{CLA-generator}. Een $n$-bit CLA-generator is een component met ingangen $\left(c_0,g_0,\ldots g_{n-1},p_0,\ldots,p_{n-1}\right)$. De component heeft tot doel om de overdracht (carry) te berekenen met een zo klein mogelijk kritisch pad, logischerwijs heeft de component dan ook de uitgangen: $\left(c_1,\ldots c_n,g_{0,n-1},p_{0,n-1}\right)$. De laatste twee uitgangen zullen we later bespreken. Op figuur \ref{fig:clag-structure} zien we hoe we een CLA-generator aansluiten op de Carry-lookahead optellers.
\begin{figure}[hbt]
\centering
\subfigure[Structuur van de CLA-generator.]{\importtikz{clag-structure}}
\subfigure[Cascade van CLA-generators met $n=9$, $k=3$.]{\importtikz{clag-cascade}}
\caption{CLA-generator.}
\figlab{CLAGenerator}
\end{figure}
Eerst zullen we een methode ontwikkelen om een overdracht $c_i$ te berekenen. Een overdracht kan maar op twee manieren tot stand komen: ofwel wordt deze gegenereerd, ofwel wordt deze gepropageerd. Dit formaliseren we als:
\begin{equation}
c_i=g_{0,i-1}+p_{0,i-1}\cdot c_0
\end{equation}
Een oplettende lezer zal gemerkt hebben dat we hierbij $g$ en $p$ twee indices geven. De reden hiervoor is, dat de overdracht overal kan gegenereerd of gepropageerd worden. We moeten de twee indices dus als de definitie van een bereik zien. De overdacht kan uitsluitend tot de $i$-de bit gepropageerd worden, indien alle bits voor de $i$-de bit propageren, bijgevolg kunnen we stellen:
\begin{equation}
p_{i,j}=\displaystyle\prod_{k=i}^j{p_k}
\end{equation}
Tenslotte wordt er overdacht gegenereerd indien de vorige bit een overdacht genereerde, of een willekeurige bit ervoor, die deze dan tot de $i$-de bit weet te propageren. Dit formaliseren we als:
\begin{equation}
g_{i,j}=g_j+\displaystyle\sum_{k=i}^{j-1}{g_kp_{k+1,j}}=g_j+\displaystyle\sum_{k=i}^{j-1}{\left(g_k\cdot\displaystyle\prod_{l=k+1}^j{p_l}\right)}
\end{equation}
De volledige berekening voor het bepalen van overdacht $c_i$ wordt dan:
\begin{equation}
c_i=g_{i-1}+\displaystyle\sum_{k=0}^{i-2}{\left(g_k\cdot\displaystyle\prod_{l=k+1}^{i-1}{p_l}\right)}+c_0\cdot\displaystyle\prod_{k=0}^{i-1}{p_k}
\end{equation}
De berekening voor $c_i$ kost dan ook een $i+1$-input OR poort, en $i+1$ AND poorten, elk van deze poorten heeft een ander aantal ingangen vari\"erend van 2 tot $i+1$. We kunnen nu opnieuw het kritische pad analyseren. Dit pad is $x_0\rightarrow c_n$. Hierbij gaat het signaal doorheen 1 XOR poort, 1 $n+1$-input AND poort en 1 $n+1$ input OR poort. De totale vertraging is dus:
\begin{equation}
\mbox{vertraging}=3.2+2\left(2+0.4n\right)=0.8n+7.2
\label{eqn:delayCLAGenerator}
\end{equation}
Toegegeven dat de orde van de vertraging nog steeds linear is, maar de factor voor $n$ is met de CLA-generator sterk gereduceerd. We kunnen echter ook een cascade van CLA-generators maken. Indien we twee $n$-bit getallen willen optellen, en we groeperen elke $k$ componenten tot een niveau hoger, hebben we $\left\lceil\log_kn\right\rceil$ niveaus nodig. We kunnen in dat geval vergelijking (\ref{eqn:delayCLAGenerator}) gebruiken om de vertraging te berekenen:
\begin{equation}
\mbox{vertraging}=3.2+\left(2\left\lceil\log_kn\right\rceil-1\right)\times\left(4+0.8k\right)
\end{equation}
Hiermee kunnen we de vertraging reduceren tot een logaritmische orde. Figuur \ref{fig:clag-cascade} toont hoe we een dergelijke cascade kunnen bouwen. Met deze cascade wordt ook meteen de reden van de twee extra ingangen duidelijk.
\subsection{Negatieve getallen}
Om getallen te kunnen aftrekken, zullen we het getalbegrip uitbreiden, zodat deze ook negatieve getallen kunnen voorstellen. Negatieve getallen voorstellen kan op verschillende manieren. In onderstaande subsubsecties zullen we de meest populaire bespreken. Hierbij moeten we in gedachten houden dat we eventueel de bovenstaande opteller zullen moeten uitbreiden om ook negatieve getallen te kunnen optellen.
\subsubsection{`Sign-Magnitude'-voorstelling}
Het arabische getalstelsel lost dit probleem op door middel van een teken. Een getal bestaat dan uit twee delen: een teken (+ of -) en een grootte. Bij positieve getallen wordt dit teken zelfs meestal niet geplaatst. Deze voorstelling is gekend als de `\termen{sign-magnitude}' voorstelling. Aangezien een getal ofwel positief of negatief is, kunnen we bij een binaire voorstelling een extra bit bij het getal plaatsen. Deze bit is $0$ bij een positief getal, en $1$ bij een negatief getal. In dat geval wordt dus $\underline{0}1100_2=\underline{+}12_{10}$ en $\underline{1}1100_2=\underline{-}12_{10}$. Een getal met $n$ bits kan dus alle gehele waarden aannemen tussen $-2^{n-1}+1$ en $2^{n-1}-1$. Er zijn echter enkele problemen met deze voorstelling. Allereerst is er nu sprake van twee voorstellingen van $0$: $-0$ en $+0$. Dit leidt tot extra complexiteit bij bijvoorbeeld het vergelijken van twee getallen. Verder wordt optellen en aftrekken van twee getallen gecompliceerd. Er zijn veel testen nodig alvorens we de waardes van de getallen kunnen optellen of aftrekken, wat tot grote vertragingen leidt.
\subsubsection{Complement-voorstellingen}
De meeste voorstellingen van negatieve getallen zijn gebaseerd op complement voorstellingen. Er bestaan twee soorten complement voorstellingen voor een getal $D$ met $m$ cijfers en radix $r$:
\begin{itemize}
 \item \termen{cijfer-complement} of \termen{diminished-radix complement} $D'$: hierbij wordt elk cijfer $i$ vervangen door zijn complement $r-i-1$. Bijvoorbeeld:
 \begin{itemize}
    \item Het $9$-complement van $1337_{10}$ is $8662_{10}$.
    \item Het $1$-complement van $01001011\ 01010011_2$ is $10110100\ 10101100_2$.
 \end{itemize}
 Het \termen{1-complement} wordt soms gebruikt voor het voorstellen van negatieve getallen in het binaire stelsel.
 \item \termen{radix-complement} $D^*=r^m-D$. Bijvoorbeeld:
 \begin{itemize}
    \item Het radix-complement van $1337_{10}$ is $8663_{10}$.
    \item Het radix-complement van $01001011\ 01010011_2$ is $10110100\ 10101101_2$.
 \end{itemize}
 Voor binaire getallen is dit het \termen{2-complement}. Dit is veruit de meest populaire voorstellingswijze.
\end{itemize}
Een belangrijke eigenschap die ook al blijkt uit de voorbeelden is dat $D^*=D'+1$. Deze eigenschap is interessant, omdat het ons helpt snel het 2-complement te berekenen. Immers is het 1-complement niets anders dan het toepassen van een NOT operatie op alle bits.
\subsubsection{Twee-complement voorstelling}
Omdat de 2-complement voorstelling vrij populair is, zullen we deze verder bespreken. Stel we beschikken over $n$ cijfers in een getalstelsel met radix $r$. In dat geval kunnen we $r^n$ in principe niet voorstellen. Logisch gezien stellen we dit voor door $r^n\equiv 0$. Immers kunnen we stellen dat in dat geval het $n+1$-de cijfer een 1 is, en de andere cijfers 0. Aangezien $D^*=r^n-D$ geldt: $D^*=-D$. Het gevolg is dat we de traditionele optelling kunnen gebruiken, indien we 2-complement getallen met elkaar optellen. Of deze getallen nu een teken bevatten of niet, is een kwestie van interpretatie, de opteller is hiervan niet afhankelijk. Bovendien kunnen we relatief eenvoudig de negatie van een getal berekenen: we passen op elke bit een NOT operatie toe, en tellen daar vervolgens 1 bij op.
\paragraph{}
Een ander voordeel van de 2-complement voorstelling, is dat er slechts \'e\'en voorstelling van het getal 0 is. Indien we immers het negatief van 0 berekenen bekomen we:
\begin{equation}
D=0000_2\Rightarrow -D\equiv D^*=1111_2+0001_2=\underline{1}0000_2=0000_2
\end{equation}
Tot slot heeft een getal met $n$ bits een bereik van $-2^{n-1}$ tot $2^{n-1}-1$, wat exact \'e\'en element groter is dan de 1-complement tegenhanger\footnote{Dit is uiteraard de plaats die vrijkomt omdat de 2-complement voorstelling slechts \'e\'en voorstelling van 0 heeft.}.
\subsubsection{Betekenis van binaire getallen}
Bij wijze van voorbeeld om het verschil tussen de verschillende voorstellingen duidelijk te maken, zetten we de betekenis van elke $4$-bit getal naast elkaar in tabel \ref{tbl:binaryMeaningSigned}.
\begin{table}[hbt]
\centering
\begin{tabular}{r|rrrr}
Binair&Unsigned&Sign-Magnitude&1-Complement&2-Complement\\\hline
$0000$&$+0$&$+0$&$+0$&$+0$\\
$0001$&$+1$&$+1$&$+1$&$+1$\\
$0010$&$+2$&$+2$&$+2$&$+2$\\
$0011$&$+3$&$+3$&$+3$&$+3$\\
$0100$&$+4$&$+4$&$+4$&$+4$\\
$0101$&$+5$&$+5$&$+5$&$+5$\\
$0110$&$+6$&$+6$&$+6$&$+6$\\
$0111$&$+7$&$+7$&$+7$&$+7$\\
$1000$&$+8$&$-0$&$-7$&$-8$\\
$1001$&$+9$&$-1$&$-6$&$-7$\\
$1010$&$+10$&$-2$&$-5$&$-6$\\
$1011$&$+11$&$-3$&$-4$&$-5$\\
$1100$&$+12$&$-4$&$-3$&$-4$\\
$1101$&$+13$&$-5$&$-2$&$-3$\\
$1110$&$+14$&$-6$&$-1$&$-2$\\
$1111$&$+15$&$-7$&$-0$&$-1$
\end{tabular}
\caption{Betekenis van de binaire getallen.}
\tbllab{binaryMeaningSigned}
\end{table}
\subsection{Optellen en aftrekken}
Nu we de belangrijkste voorstellingen van negatieve getallen besproken hebben, zullen we voor ieder van deze voorstellingen een schema uitwerken hoe we getallen kunnen optellen en aftrekken. Deze schema's worden weergegeven in figuur \ref{fig:addSubNegSchematic}.
\begin{figure}[hbt]
\centering
\subfigure[Sign-magnitude]{\importtikz{signedmagnitude}}
\subfigure[1-complement]{\importtikz{onecomplement}}
\subfigure[2-complement]{\importtikz{twocomplement}}
\caption{Optelling en aftrekking van gehele getallen.}
\figlab{addSubNegSchematic}
\end{figure}
\subsubsection{Signed-magnitude voorstelling}
Bij een signed-magnitude voorstelling moeten eerst heel wat testen uitgevoerd worden alvorens we getallen kunnen optellen of aftrekken. In eerste instantie moeten we bij het aftrekken van twee getallen het teken van de tweede operand veranderen, om daarna de bewerking als een optelling verder te verwerken. Bij deze optelling moeten we eerst testen of beide getallen hetzelfde teken hebben. Indien dit niet het geval is, bepaalt het getal met de grootste magnitude $m$ het teken van het getal, en moeten de magnitudes van elkaar afgetrokken worden, in het andere geval is er sprake van een gewone optelling. Al deze testen zorgen voor complexe hardware die bovendien ook nog traag werkt, dit maakt signed-magnitude tot een weinig populaire voorstelling. Figuur \ref{fig:signedmagnitude} geeft de werkwijze schematisch weer.
\subsubsection{1-complement voorstelling}
Optellen en aftrekken met de 1-complement voorstelling is heel wat eenvoudiger. Bij een aftrekking berekenen we ook eerst de negatie van de tweede operand, wat een NOT operatie is. Vervolgens kunnen we de twee getallen eenvoudig optellen met onze eerder ge\"implementeerde opteller. Deze optelling volstaat soms echter niet, met het volgende voorbeelden kunnen we illustreren wat er kan fout lopen:
\begin{equation}
\begin{array}{rl|rl|rl}
\begin{array}{rr}
&0101\\
+&1010\\\hline
\textcolor{gray}{0}&1111
\end{array}
&
\begin{array}{rr}
&+5\\
+&-5\\\hline
&-0
\end{array}
&
\begin{array}{rr}
&0110\\
+&1101\\\hline
\textcolor{gray}{1}&0011
\end{array}
&
\begin{array}{rr}
&+6\\
+&-2\\\hline
&3
\end{array}
&
\begin{array}{rr}
&1011\\
+&0011\\\hline
\textcolor{gray}{0}&1110
\end{array}
&
\begin{array}{rr}
&-4\\
+&+3\\\hline
&-1
\end{array}
\end{array}
\label{eqn:oneComplementFaultExample}
\end{equation}
Indien we twee getallen optellen met een tegengesteld teken, zodat de uitkomst positief is, zien we dat het resultaat altijd 1 lager uitkomt dan het juiste resultaat. Dit komt omdat de 1-complement voorstelling twee representaties heeft voor 0. Zoals we zien in het eerste voorbeeld, komen we altijd -0 uit bij het optellen van twee tegengestelde getallen. Bijgevolg zal een resultaat van 1 uitkomen op de voorstelling die 1 hoger is dan $-0$: $+0$. Indien de carry $c_n$ dus 1 is, moeten we nog 1 optellen bij het resultaat. Dit kunnen we toepassen op de voorbeelden in vergelijking (\ref{eqn:oneComplementFaultExample}):
\begin{equation}
\begin{array}{rl|rl|rl}
\begin{array}{rr}
&0101\\
+&1010\\\hline
\underline{0}&1111\\
+&000\underline{0}\\\hline
&1111
\end{array}
&
\begin{array}{rr}
&+5\\
+&-5\\\hline
&-0\\
+&+0\\\hline
&-0
\end{array}
&
\begin{array}{rr}
&0110\\
+&1101\\\hline
\underline{1}&0011\\
+&000\underline{1}\\\hline
&00100
\end{array}
&
\begin{array}{rr}
&+6\\
+&-2\\\hline
&+3\\
+&+1\\\hline
&+4
\end{array}
&
\begin{array}{rr}
&1011\\
+&0011\\\hline
\underline{0}&1110\\
+&000\underline{0}\\\hline
&1110
\end{array}
&
\begin{array}{rr}
&-4\\
+&+3\\\hline
&-1\\
+&+0\\\hline
&-1
\end{array}
\end{array}
\label{eqn:oneComplementCorrectExample}
\end{equation}
Het grote nadeel bij deze implementatie is dat we de optelling-aftrekking dus in twee tijden moeten uitvoeren: eerst tellen we ze op en bepalen we de hoogste carry $c_n$, vervolgens tellen we deze carry nog eens bij het resultaat op. Dit veroorzaakt dus een verdubbeling van de vertraging. Figuur \ref{fig:onecomplement} geeft het hele proces schematisch weer.
\subsubsection{2-complement voorstelling}
De 2-complement voorstelling is de beste voor de implementatie van een opteller-aftrekker. Immers kunnen we een optelling eenvoudigweg uitvoeren zoals we die reeds hebben beschreven in subsectie \ref{ss:add}. Bij een optelling dienen we dus eenvoudigweg de twee operatoren optellen: $B_r=B_1+B_2$. Bij een aftrekking moeten we dan eenvoudigweg de negatie van de tweede operand berekenen. De berekening wordt in dat geval $B_r=B_1+B_2'+1$. Deze optelling lijkt misschien tot hetzelfde probleem te leiden als bij de 1-complement voorstelling. Maar we kunnen eenvoudigweg de carry van de laagste bit $c_0$ op 1 zetten. We kunnen vervolgens $B_2'$ berekenen met behulp van XOR poorten. Een XOR poort is dan ook een geprogrammeerde NOT poort. Indien \'e\'en van de ingangen van de XOR poorten 1 is, zal de andere de negatie zijn van de andere ingang. Indien de ingang 0 is, laat de XOR poort de andere ingang door. We kunnen dus een opteller-aftrekker realiseren zoals op figuur \ref{fig:addsub-twocomplement-implementation}.
\begin{figure}[hbt]
\centering
\subfigure[Interface]{\importtikz{addsub-twocomplement-interface}}
\subfigure[Mogelijke implementatie]{\importtikz{addsub-twocomplement-implementation}}
\caption{Opteller-aftrekker voor 2-complement getallen.}
\figlab{adderSubTwoComplement}
\end{figure}
Indien $s=0$ tellen we de twee getallen met elkaar op, anders trekken we de twee getallen van elkaar af. Door een XOR poort op de laatste twee carry-uitgangen $c_{n-1}$ en $c_n$ te plaatsen, kunnen we een controle op overflow inbouwen. Deze component wordt meestal samengevat tot een interface zoals op figuur \ref{fig:addsub-twocomplement-interface}\footnote{Bemerk op de figuur dat variabelen met hoofdletters een rij van in- of uitgangen voorstellen.}. Een schematische werkwijze van optellen en aftrekken met 2-complement voorstelling staat op figuur \ref{fig:twocomplement}. De 2-complement voorstelling is dan ook populair omdat deze weinig bewerkingen en testen vraagt om sommen en verschillen te berekenen. Bovendien is er weinig extra hardware nodig om een opteller om te bouwen.
\subsection{Arithmetic-Logic Unit (ALU)}
\ssclab{alu}
\importtikzfigure{alu-structure}{Schematisch implementatie van een arithmetic-logic unit (ALU).}
Hoewel veel processoren in staat zijn om sommen en verschillen te berekenen zal men meestal geen directe opteller of opteller-aftrekker vinden. Meestal gebruikt men hiervoor een \termen{Arithmetic-Logic Unit (ALU)}. Een ALU is een component die, gebaseerd op een opteller, allerlei instructies\footnote{Welke instructies is niet echt gespecificeerd. Er bestaan dan ook boeken over het ontwerpen van een goede ALU.} kan uitvoeren. In ons geval beschouwen we 4 rekenkundige (optellen, aftrekken, \termen{increment} en \termen{decrement}) en 4 logische bewerkingen (AND, OR, NOT en identiteit). We bouwen een ALU op ongeveer dezelfde manier zoals we een opteller-aftrekker bouwden uit een opteller. In plaats van XOR poorten gebruiken we een nieuw component: een \termen{Arithmetic-Logic Extender (ALE)}. Een ander component -- de CIG -- berekent welke ingang aan de carry $c_0$ moet worden gegeven. In het algemeen heeft een ALU dus een structuur zoals op figuur \ref{fig:alu-structure} waarbij de ALE en CIG vrij ge\"implementeerd kunnen worden.
\subsubsection{Instructieset}
\label{sss:aLUInstructionSet}
Alvorens we in staat zijn een ALU te maken moeten we een instructieset defini\"eren. Onze instructieset heeft drie\footnote{Omdat we 8 opdrachten gedefinieerd hebben, hebben we een $\log_28=3$ bit instructiewoord nodig.} ingangssignalen die bepalen welke opdracht er moet worden uitgevoerd. Bovendien zijn de 8 opdrachten in te delen in 2 groepen van 4: aritmetisch en logisch. Daarom noemen we de eerste bit van het instructiewoord $m$ voor mode\footnote{0=logisch, 1=aritmetisch.}. Verder wijzen we dan elke opdracht toe aan een bepaald instructiewoord zoals in tabel \ref{tbl:aLUInstructionSet}.
\begin{table}[hbt]
\centering
\begin{tabular}{ccc|c|ccc|l}
$m$&$i_1$&$i_0$&$F$&$X$&$Y$&$c_0$&\\\hline
0&0&0&$A'$&$A'$&0&0&NOT\\
0&0&1&$A\mbox{ AND }B$&$A\mbox{ AND }B$&0&0&AND\\
0&1&0&$A$&$A$&0&0&Identiteit\\
0&1&1&$A\mbox{ OR }B$&$A\mbox{ OR }B$&0&0&OR\\
1&0&0&$A-1$&$A$&-1&0&Decrement\\
1&0&1&$A+B$&$A$&$B$&0&Optelling\\
1&1&0&$A-B$&$A$&$B'$&1&Aftrekking\\
1&1&1&$A+1$&$A$&$0$&1&Increment\\
\end{tabular}
\caption{Instructieset van een typische arithmetic-logic unit (ALU).}
\tbllab{aLUInstructionSet}
\end{table}
Gebaseerd op deze instructieset moeten we een ALE en CIG implementeren. De ALE implementeert een functie die $\left(A,B\right)$-waardes afbeeldt op $\left(X,Y\right)$-waardes. Deze laatste waardes dienen als invoer  voor de optellers. De CIG ten slotte geeft gebaseerd op het instructiewoord een waarde voor $c_0$. Deze functies staan ook in de instructietabel.
\subsubsection{Synthese van de ALE en CIG}
\begin{figure}[hbt]
\centering
\subfigure[Karnaugh-kaarten]{\importtikz{ale-cig-karnaugh}}
\subfigure[Implementatie ALE]{\importtikz{ale-implementation}}
\subfigure[Implementatie CIG]{\importtikz{cig-implementation}}
\caption{Synthese van de ALE en CIG}
\end{figure}
Eenmaal we de instructieset hebben, dienen we enkel nog de ALE en CIG te implementeren. Een ALE is een component met als ingangen het instructiewoord en van elke operand een bit. In ons geval wordt dit dus $\left(m,i_1,i_0,a_j,b_j\right)$. Als uitgangen hebben we de ingangen van \'e\'en van de optellers $\left(x_j,y_j\right)$. We zijn dus in staat om een waarheidstabel en Karnaugh-kaart op te stellen van de ALE. Zoals op figuur \ref{fig:ale-cig-karnaugh}. Vervolgens is het enkel een kwestie van implementatie. Op basis van de Karnaugh-kaaren hebben we op figuur \ref{fig:ale-implementation} een AND-OR implementatie gesynthetiseerd.
\paragraph{}
De CIG is enkel afhankelijk van het instructiewoord. Met de instructieset op tabel \ref{tbl:aLUInstructionSet} is dit $\left(m,i_1,i_0\right)$. Een CIG heeft slechts \'e\'en uitgang: carry $c_0$. Op basis van deze instructieset staat op figuur \ref{fig:ale-cig-karnaugh} de bijbehorende Karnaugh-kaart. Deze blijkt een eenvoudige AND-operatie te zijn zoals op figuur \ref{fig:cig-implementation}.
\subsection{Vermenigvuldigen}
\begin{figure}[htb]
\centering
\subfigure[$1\times 1$-bit]{\importtikz{mul1x1}}
\subfigure[$3\times 2$-bit]{\importtikz{mul3x2}}
\subfigure[$n\times m$-bit]{\importtikz{mulmxn}}
\caption{Parallelle vermenigvuldigers.}
\figlab{parallelMultipliers}
\end{figure}
In deze subsectie bouwen we een vermenigvuldiger gebaseerd op de manier hoe men met behulp van cijferen twee getallen vermenigvuldigt. We zullen hierbij enkel natuurlijke getallen beschouwen, later breiden we dit uit naar gehele getallen. Vergelijking (\ref{eqn:multiplyNormal}) toont de vermenigvuldiging van twee decimale getallen:
\begin{equation}
\begin{array}{lcccccc}
&&&1&4&2&5\\
\times&&&&3&6&5\\\hline
&&&7&1&2&5\\
&&8&5&5&0&\\
+&4&2&7&5&&\\\hline
&5&2&0&1&2&5
\end{array}
\label{eqn:multiplyNormal}
\end{equation}
We kunnen dus twee getallen vermenigvuldigen door het eerste getal telkens te vermenigvuldigen met \'e\'en van de cijfers van het onderste getal en na deze op de juiste manier te hebben uitgelijnd op te tellen. Deze methode werkt ook op binaire getallen zoals blijkt uit vergelijking (\ref{eqn:multiplyBinary}):
\begin{equation}
\begin{array}{lcccccc}
&&&1&0&1&1\\
\times&&&&1&0&1\\\hline
&&&1&0&1&1\\
&&0&0&0&0&\\
+&1&0&1&1&&\\\hline
&1&1&0&1&1&1
\end{array}
\label{eqn:multiplyBinary}
\end{equation}
Een groot voordeel van vermenigvuldigingen met binaire getallen is dat een cijfer slechts 1 of 0 kan zijn. Indien het 0 is tellen we niets op bij het resultaat, anders tellen we het eerste getal op, die voldoende naar links is opgeschoven. Deze realisatie noemt men een \termen{parallelle vermenigvuldiger}. Figuur \ref{fig:parallelMultipliers} toont enkele voorbeelden van parallelle vermenigvuldigers. Zo zien we het speciale geval van een $1\times 1$-bit, wat neerkomt op een AND-poort. De $3\times 2$-bit vermenigvuldiger toont een speciale realisatie van het cascaderende effect. Tot slot implementeren we ook het algemeen geval van een $m\times n$-vermenigvuldiger. Naast parallelle vermenigvuldigers bestaan er ook andere implementaties die sneller werken en goedkoper te realiseren zijn. De kostprijs om een getal met $m$ bits te vermenigvuldigen met een getal van $n$ bits is immers $\bigoh{nm}$. Met een sequenti\"ele schakeling kunnen we de kosten sterk reduceren en zelfs de vermenigvuldiging versnellen. Vermenigvuldigen met een macht van 2 kunnen we bovendien berekenen met schuifoperators die in subsectie \ref{ss:shiftoperators} aan bod komen.
\subsubsection{2-complement vermenigvuldiger}
Het uitbreiden van deze vermenigvuldiger naar gehele getallen met 2-complement voorstelling is geen sinecure. In de praktijk zal men dan ook eerst de getallen omzetten naar sign-magnitude voorstelling alvorens we de twee getallen vermenigvuldigen. In dat geval kunnen we eenvoudigweg de waardes van de twee getallen vermenigvuldigen en passen we een XOR operatie toe op de tekenbit van de getallen. Het resultaat zetten we vervolgens weer om naar 2-complement voorstelling. Er bestaat uiteraard wel een vermenigvuldiger voor een 2-complement voorstelling. Deze zullen we enkel op hoog niveau beschrijven door middel van een voorbeeld. We rekenen hierbij $-2\times -3$ uit op 4-bit voorstelling en het resultaat stellen we voor op een 8-bit voorstellingen zoals in onderstaande vergelijking:
\begin{equation}
\begin{array}{l|r}
 \begin{array}{lr}
&-2\\
\times&-3\\\hline
&+6
\end{array}&\begin{array}{lr}
&1110\\
\times&1101\\\hline
&00000110
\end{array}
\end{array}
\end{equation}
De oplossing bestaat eruit om $-2$ te zien in zijn binaire vorm als $-8+4+2=-2$. Elk van de bits dient afzonderlijk vermenigvuldigd te worden, en vervolgens opgeteld te worden zoals in onderstaande vermenigvuldiging:
\begin{equation}
\begin{array}{lcr}
\begin{array}{lrcr}
&2&\times&-3\\
+&4&\times&-3\\
+&-8&\times&-3\\\hline
&-2&\times&-3
\end{array}&\begin{array}{c}
\Rightarrow\\
\Rightarrow\\
\Rightarrow\\
\Rightarrow
\end{array}&\begin{array}{lr}
&1111\ 1010\\
+&1111\ 0100\\
+&0001\ 1000\\\hline
&0000\ 0110
\end{array}
\end{array}
\end{equation}
\subsection{Andere courante bewerkingen}
\subsubsection{Delen}
Analoog aan vermenigvuldigen kunnen we ook een \termen{deling} in een binaire voorstelling gebaseerd op cijferen. We geven een voorbeeld van een binaire deling maar vermelden geen details over het realiseren van een schakeling:
\begin{equation}
\begin{array}{r|l}
1011\ 1010&1110\\\hline
\underline{111\ 0}\textcolor{white}{000}&1101\\
100\ 1010&\\
\underline{11\ 10}\textcolor{white}{00}&\\
1\ 0010&\\
\underline{0\ 000}\textcolor{white}{0}&\\
1\ 0010&\\
\underline{11\ 10}&\\
100&
\end{array}
\end{equation}
Door dus herhaaldelijk het resterende deeltal te vergelijken met een verschuifde deler en indien deze groter is, deze af te trekken, kunnen we de rest en de het quoti\"ent berekenen. Het aantal cycli is dus ook tevens het aantal bits van het quoti\"ent. Deze manier van implementatie is dan ook de meest populaire, en wordt vaak gebruikt. Indien we delen door een macht van 2, kunnen we het getal berekenen met een schuifoperatie (zie subsectie \ref{ss:shiftoperators}).
\subsubsection{Modulo rekenen}
Een andere populaire berekening is \termen{modulo} (ook wel bekend als \termen{$\mod$}). Modulo-rekening is sterk gerelateerd aan, maar niet equivalent aan \termen{remainder}-rekenen (ofwel \termen{$\rem$}). We defini\"eren de remainder als:
\begin{equation}
a\rem b\equiv a-\left\lfloor a/b\right\rfloor\times b
\end{equation}
De modulo-operatie daarentegen houdt rekening met het teken van zowel $a$ als $b$:
\begin{equation}
a\mod b\equiv \left\{\begin{array}{lcl}
a\rem b&\ifun&a\cdot b>0\\
\left(a\rem b\right)+b&\ifun&a\cdot b<0
\end{array}\right.
\end{equation}
Net als bij andere operaties, heeft ook de modulo-operatie een speciaal geval bij een macht van 2: in dat geval kunnen we een AND operatie uitvoeren op het getal en de macht gedecrementeerd. Bijvoorbeeld:
\begin{equation}
1653\mod 16=1653\mbox{ AND }15=5
\end{equation}
\subsection{Vaste komma getallen}
We zullen het getal verder uitbreiden naar getallen met vaste komma in deze subsectie en getallen met vlottende komma in subsectie \ref{ss:floatingPoints}. Ten slotte zullen we nog enkele andere voorstellingen van gegevens bekijken in subsectie \ref{ss:otherRepresentations}.
\paragraph{}
\termen{Vaste komma voorstelling} (ofwel \termen{fixed point}) lost het probleem van het zetten van een komma op door gewoon een bit af te spreken waarna men een komma plaatst, deze positie staat vast. Bijgevolg is er geen voorstelling van de komma zelf nodig. Indien we dus bijvoorbeeld een 8-bit getal beschouwen, kunnen we de eerste vier bit voorstellen als het \termen{geheel deel}, de overige vier bit behoren dan tot het \termen{fractionele gedeelte}. Dit formaliseren we met de notatie \termen{$\fix\left<i,f\right>$} waarbij $i$ het aantal bits voorstellen behorend tot het gehele deel, en $f$ het aantal bits tot het fractionele gedeelte. Zo stelt $1110010$ in $\fix\left<4,3\right>$, $14.25$ voor. De eerste vier bits stellen immers $14$ voor, de laatste drie stellen $2$ voor, deze delen we vervolgens door $2^f$.
\subsubsection{Aantal bits voor fouteloze voorstelling}
In de vorige secties hebben we al aandacht besteed aan het aantal bits die we moeten reserveren om de resultaten van bewerkingen zonder verlies te kunnen blijven voorstellen. Bij een optelling van 2 vaste komma getallen moet het resultaat voorgesteld worden op een vaste komma voorstelling waarbij we het geheel en fractioneelgedeelte voorstellen met het maximum aantal bits van de operanden. Bovendien dienen we \'e\'en bit toe te voegen aan het geheel gedeelte, ofwel formeler:
\begin{equation}
\fix\left<i_1,f_1\right>+\fix\left<i_2,f_2\right>=\fix\left<\max\left(i_1,i_2\right)+1,\max\left(f_1,f_2\right)\right>
\end{equation}
Wat we verder kunnen veralgemenen tot:
\begin{equation}
\displaystyle\sum_{k=1}^{n}{\fix\left<i_k,f_k\right>}=\fix\left<\left\lceil\log_2n\right\rceil+\max_{k=1}^{n}{i_k},\max_{k=1}^{n}{f_k}\right>
\end{equation}
Bij vermenigvuldigingen moeten we het aantal bits optellen van zowel het gehele als fractionele gedeelte:
\begin{equation}
\fix\left<i_1,f_1\right>\times\fix\left<i_2,f_2\right>=\fix\left<i_1+i_2,f_1+f_2\right>
\end{equation}
Of algemener:
\begin{equation}
\displaystyle\prod_{k=1}^{n}{\fix\left<i_k,f_k\right>}=\fix\left<\displaystyle\sum_{k=1}^{n}{i_k},\displaystyle\sum_{k=1}^{n}{f_k}\right>
\end{equation}
\subsection{Vlottende komma getallen}
\label{ss:floatingPoints}
Het kan voorkomen dat we echter niet weten tot welke grootorde het getal in kwestie zal behoren. In dat geval zouden we vaste getallen met een groot aantal bits moeten gebruiken, waarbij bovendien in de meeste gevallen slechts een kleine hoeveelheid bits nuttig blijkt. In deze gevallen gebruiken we \termen{vlottende komma voorstelling} (ook wel \termen{zwevendekommagetal}, \termen{drijvendekommagetal} of \termen{floating-point number} genoemd). Vlottende komma getallen worden voorgesteld door een sequentie van bits die in drie groepen worden onderverdeeld:
\begin{itemize}
 \item \termen{sign-bit $s$}: 1-bit die het teken van het getal bepaalt. De vlottende kommavoorstelling is dus vergelijkbaar met de signed-magnitude voorstelling.
 \item \termen{exponent $E$}: een getal die bepaalt met hoeveel plaatsen het getal moet worden opgeschoven. Dit deel wordt voorgesteld in `\termen{excess}'-formaat.
 \item \termen{mantisse $M$}: het getal onafhankelijk van het schuiven van plaatsen. De voorstelling van de mantisse zelf is $\fix\left<1,m-1\right>$.
\end{itemize}
Het getal dat we hierbij willen voorstellen is gelijk aan:
\begin{equation}
N=\left(-1\right)^s\times\mbox{mantisse}\times r^{\mbox{\tiny{exponent}}}
\end{equation}
met radix $r$. Net als bij een vaste komma getal noteren we een familie van vlottende komma getallen als \termen{$\float\left<m,e\right>$} met $m$ het aantal bits van de mantisse en $e$ het aantal bits van de exponent. Verder onderscheiden we nog twee families van vlottende komma voorstellingen:
\begin{itemize}
 \item \termen{Genormaliseerde vlottende komma voorstelling}: hierbij leggen we een extra constraint betreffende de mantisse: $1\leq\mbox{mantisse}<r$. Omdat in dat geval de eerste bit dus altijd gelijk is aan 1, behoren enkel de bits na de komma tot de voorstelling. In dat geval denken we er de 1 dus bij.
 \item \termen{Niet-genormaliseerde vlottende komma voorstelling}: hierbij is deze bovengenoemde constraint dus niet van toepassing. Niet-genormaliseerde vlottende komma getallen kunnen meer getallen voorstellen dan hun tegenhanger, maar hebben een groot nadeel: men kan een getal op verschillende manieren voorstellen: eenzelfde getal kan op verschillende manieren voorgesteld worden.
\end{itemize}
\subsubsection{Underflow en overflow}
Naast overflow introduceert de vlottende kommavoorstelling nog een bijkomend fenomeen: ``\termen{underflow}''. Underflow treedt op op het moment dat een getal niet meer voorgesteld kan worden omdat de absolute waarde te klein geworden is. Figuur \ref{fig:floatingpoint-underflow} geeft dit fenomeen schematisch weer van een \texttt{Single} (zie volgende paragraaf).
\importtikzfigure{floatingpoint-underflow}{Underflow van een vlottende komma voorstelling.}
\subsubsection{IEEE-formaat voor vlottende komma getallen}
Nu we de vlottende komma voorstelling theoretisch beschreven hebben, zullen we het formaat gedefinieerd door IEEE bespreken. De floating point wordt beschreven in IEEE 754-1985\footnote{De opvolger van deze standaard is IEEE 754-2008\cite{5976968}. Hierbij worden ook halve en viervoudige precisie gedefinieerd.}\cite{30711}. Hierbij maakt met een onderscheid tussen vlottende komma getallen met \termen{enkele precisie} (32-bit en beter bekend onder de term \termen{\texttt{float}} of \termen{\texttt{Single}}) en \termen{dubbele precisie} (64-bit en beter bekend als \termen{\texttt{double}}). Tabel \ref{tbl:iEEEFloatingPointFormat} toont de verdeling van de beschikbare bits onder de mantisse en exponent.
\begin{table}[hbt]
\centering
\subtable[Bit-indeling]{\begin{tabular}{l|crrr}
Precisie&grootte&$e$&$m$&$B$\\\hline
\texttt{float}&32-bit&8&23&127\\
\texttt{double}&64-bit&11&52&1023\\
\end{tabular}
\tbllab{iEEEFloatingPointFormat}}
\subtable[Getalvoorstelling]{\begin{tabular}{l|ccc}
&$E=0$&$0<E<2^e-1$&$E=2^e-1$\\\hline
$M=0$&$0$&$\left(-1\right)^s\times\underline{1}.M\times2^{E-B}$&$\left(-1\right)^s\times\infty$\\
$M\neq 0$&$\left(-1\right)^s\times\underline{0}.M\times2^{1-B}$&$\left(-1\right)^s\times\underline{1}.M\times2^{E-B}$&NaN\\
\end{tabular}
\tbllab{iEEEFloatingNumberRepresentation}}
\caption{IEEE 754-1985 Floating Point.}
\tbllab{iEEEFloatingPoint}
\end{table}
Elk van deze formaten heeft uiteraard radix $r=2$. IEEE 754-1985 vermeldt ook hoe een vlottende komma moet worden uitgelezen. Tabel \ref{tbl:iEEEFloatingNumberRepresentation} geeft hierbij weer hoe we het getal moeten interpreteren afhankelijk van de waarde van de exponent $E$ en mantisse $M$. Bovendien wordt bij de IEEE 754 een extra variabele ingevoerd: \termen{excess-bias $B$}. Tot op heden is $B=2^{e-1}-1$, en is de range van de exponent dus van $-2^{e-1}+2$ tot $2^{e-1}-1$. Eventueel zou men later kunnen afwijken en bijvoorbeeld meer positieve exponenten dan negatieve kunnen toelaten. Verder definieert het formaat nog enkele speciale variabelen:
\begin{itemize}
 \item Nul (0): dit getal kan eigenlijk niet weergegeven worden met ons eerdere definitie van een genormaliseerde vlottende komma. De getalexperts bij Intel bedachten dan ook de regel dat indien $E=0$, we het getal in niet genormaliseerde getalvoorstelling zien.
 \item \termen{Negatief oneindig $-\infty$}/\termen{Positief oneindig $+\infty$}: Indien een operatie tot een overflow leidt, zal het resultaat worden voorgesteld als oneindig. Oneindig gedraagt zich ongeveer hetzelfde als zijn wiskundig equivalent.
 \item \termen{Not a Number (NaN)}: In tegenstelling tot gehele getallen die bij bijvoorbeeld een deling door 0 een fout\footnote{En een interrupt bij de meeste processoren.} veroorzaken, zullen ongeldige bewerkingen zoals delen door 0, en het verschil van oneindig en oneindig resulteren in Not a Number.
\end{itemize}
In tabel \ref{tbl:iEEEFloatingNumberRepresentation} zien we ten slotte ook dat enkele bits onderlijnd worden. Dit zijn de zogenaamde \termen{verborgen bits}. Deze bits zijn geen onderdeel van de mantisse, maar dienen we er wel denkbeeldig aan toe te voegen om het getal te kunnen interpreteren.
\subsubsection{Rekenen met vlottende komma}
In deze subsubsectie bespreken we kort hoe we kunnen rekenen met getallen met vlottende komma. De details kan men vinden in \cite[\S4]{hyde2004write} maar enkel een korte introductie behoort tot dit vak.
\paragraph{Optelling}
Het optellen van twee vlottende komma getallen verloopt in drie stappen:
\begin{enumerate}
 \item Eerst denormaliseren we de twee getallen door de exponenten gelijk te maken. Deze stap is geen sinecure omdat we bij dit proces zoveel mogelijk informatie willen blijven behouden (Indien we dus enkel bij \'e\'en van de twee getallen de exponent aanpassen, lopen we kans dat zijn mantisse alle informatie verliest).
 \item Vervolgens tellen we de twee mantisses met elkaar op.
 \item Het resultaat dienen we vervolgens weer te normaliseren.
\end{enumerate}
IEEE 754 definieert het formaat van een vlottende komma, de wiskundige operaties zelf behoren hier echter niet bij. Intel heeft bijvoorbeeld gepatenteerde technologie waarbij het getal eerst wordt omgezet naar een equivalent met grotere mantisse om meer precisie te garanderen. In de praktijk komt het er dus op neer dat IEEE 754 niet specificeert wat het resultaat moet zijn na een wiskundige bewerking.
\paragraph{Vermenigvuldiging}
Vermenigvuldigen is bij vlottende komma simpeler dan optellen:
\begin{enumerate}
 \item We vermenigvuldigen de mantisse zoals we dit hebben gedaan bij vermenigvuldigen van natuurlijke getallen. We passen een XOR-operatie toe op de tekenbit van de twee getallen, en we tellen de exponenten met elkaar op\footnote{Optellen bij het excess-formaat verloopt anders, we dienen immers \'e\'enmaal de excess-bias van de som af te trekken.}.
 \item We normaliseren het resultaat. Dit betekent dat ofwel de exponent hetzelfde blijft, ofwel met \'e\'en moet worden opgehoogd.
\end{enumerate}
\subsection{Andere voorstellingen van gegevens}
\label{ss:otherRepresentations}
Naast de hierboven beschreven voorstellingen voor natuurlijke-, gehele- en kommagetallen bestaan er nog andere voorstellingen. We stellen er in deze subsectie twee voor: \termen{Binary Coded Decimal (BCD)} is een alternatief formaat om natuurlijke getallen voor te stellen. Dit kan eventueel uitgebreid worden tot gehele- en kommagetallen. De \termen{American Standard Code for Information Interchange (ASCII)} is een formaat dat hoofdzakelijk bedoeld is om tekst op te slaan.
\subsubsection{Binary Coded Decimal (BCD)}
\label{ss:bcd}
In de vorige subsecties hebben we geen aandacht besteed aan het omzetten van een getal naar tekst. Deze omzetting is vrij arbeidsintensief en kost dus ook veel hardware. Bovendien stuiten we op nog een probleem: heel wat decimale kommagetallen kunnen niet voorgesteld worden in het binair getalstelsel. Zo bestaat er geen enkel binaire vorm die $0.3$ voorstelt. In dat geval moeten we het getal zo goed mogelijk benaderen\footnote{Het is echter niet omdat het binair stelsel er niet in slaagt om alle decimale getallen voor te stellen dat het minder accuraat is, integendeel: het binair stelsel is accurater.}. Een oplossing voor deze twee problemen is het Binary Coded Decimal (BCD) systeem. We kunnen elk decimaal cijfer voorstellen met 4-bit. We kunnen dus een decimaal getal voorstellen, door voor ieder cijfer zijn binair equivalent te gebruiken. Dit betekent dus dat we een decimaal getal met $n$ cijfers voorstellen met $4n$ bit. Elk van deze groepen bits kan dus alleen waardes van $0$ tot $9$ aannemen. Bijvoorbeeld: $1425_{10}=0101\_1001\_0001_2=0001\_0100\_0010\_0101_{\mbox{\tiny{BCD}}}$. Een groot nadeel van BCD voorstelling is dat bewerkingen heel wat complexer worden. Tabel \ref{tbl:bCDConversion} toont de omzetting van een decimaal cijfer naar het BCD equivalent.
\begin{table}[hbt]
\centering
\begin{tabular}{c|c}
Decimaal&BCD\\\hline
0&0000\\
1&0001\\
2&0010\\
3&0011\\
4&0100\\
5&0101\\
6&0110\\
7&0111\\
8&1000\\
9&1001
\end{tabular}
\caption{Decimale cijfers en hun BCD equivalent.}
\tbllab{bCDConversion}
\end{table}
\paragraph{Bewerkingen met BCD}
\begin{figure}[hbt]
\centering
\subfigure[Schematische voorstelling]{\importtikz{bcd-schematic}}
\subfigure[Karnaugh-kaart]{
\begin{tikzpicture}
\kkaarte{0}{0}{$c_o$}{$c$/$z_3$/$z_2$/$z_1$/$z_0$}{0/0/0/0/0/0/0/0/0/0/1/1/1/1/1/1/1/1/1/-/-/-/-/-/-/-/-/-/-/-/-/-}
\end{tikzpicture}
\figlab{bCDAdderKarnaugh}}
\subfigure[Implementatie vergelijker]{
\begin{tikzpicture}[circuit logic US]
\draw (-1,-1) rectangle (1,1);
\node[or gate,rotate=-90,inputs={normal,normal,normal},scale=0.75] (o0) at (-0.33,-0.5) {};
\node[and gate,rotate=180,scale=0.75] (a0) at (0.33,0) {};
\node[and gate,rotate=180,scale=0.75] (a1) at (0.33,0.5) {};
\draw (o0.input 1) |- (a0.output);
\draw (o0.input 2) |- (a1.output);
\draw (o0.input 3) -- (o0.input 3 |- 0,1.25) node[scale=0.75,anchor=south]{$c$};
\draw (1,-0.5) -- (1.25,-0.5) node[scale=0.75,anchor=west]{$z_0$};
\draw (a0.input 1) -- (a0.input 1 -| 1.25,0) node[scale=0.75,anchor=west]{$z_1$};
\draw (a1.input 1) -- (a1.input 1 -| 1.25,0) node[scale=0.75,anchor=west]{$z_2$};
\draw (a1.input 2) -- (a1.input 2 -| 1.25,0) node[scale=0.75,anchor=west]{$z_3$};
\draw (a0.input 2) -| (a1.input 2 -| 0.875,0);
\pdot{a1.input 2 -| 0.875,0}
\draw[->] (o0.output) -- (o0.output |- 0,-1.25) node[scale=0.75,anchor=north]{$c_o$};
\end{tikzpicture}
\figlab{bCDAdderComparator}}
\caption{Mogelijke implementatie van een BCD opteller.}
\figlab{bCDAdder}
\end{figure}
Ter illustratie zullen we tonen hoe we een opteller kunnen realiseren voor het BCD formaat. Hierbij streven we niet zozeer naar een minimale implementatie, maar tonen we dat een optelling in ieder geval complexer is dan bij zijn binair equivalent. Bij een optelling dienen we immers elke decimaal afzonderlijk op te tellen. Net zoals een half- en full adder bit per bit optelden, dienen we nu per decimaal een 4-bit opteller te realiseren. Indien het resultaat van deze optelling echter groter is dan 9, dienen we dit resultaat verder aan te passen, zodat het resultaat 10 minder is, en we de overdacht (carry) doorgeven. Voor dit eerste hebben we nogmaals een 4-bit opteller nodig. Verder hebben we een component nodig die controleert of het eerste resultaat groter is dan 9. Deze component heeft niet alleen een carry als uitgang, maar moet ook invoer genereren voor de tweede opteller. Indien het eerste resultaat immers groter is dan 9, tellen we er nog eens 6 bij op. Dit betekent dat bij een tussenresultaat van 10, de tweede opteller tot 16 komt wat dus gebaseerd op de laatste 4 bits in 0 resulteert. Figuur \ref{fig:bCDAdderSchematic} toont schematisch hoe we twee decimale cijfers kunnen optellen. Indien we deze structuur voor ieder cijfer herhalen, realiseren we een BCD opteller. De vergelijker synthetiseren we met behulp van Karnaugh-kaarten zoals op figuur \ref{fig:bCDAdderKarnaugh}. Merk op dat het resultaat van de eerste opteller hoogstens 18 is, en we dus voor de andere waarden don't cares kunnen gebruiken. Een mogelijke synthese van deze vergelijker staat op figuur \ref{fig:bCDAdderComparator}. Tot slot merken we op dat we bij het bepalen van het negatieve getal van een BCD niet het 2-complement moeten berekenen, maar het 10-complement. Ook deze stap vereist extra hardware.
\subsubsection{American Standard Code for Information Interchange (ASCII)}
\begin{table}[hbt]
\centering
\begin{tabular}{c|cccccccc}
&000&001&010&011&100&101&110&111\\\hline
0000	&\verb+NUL+	&\verb+DLE+	&\verb+SP+	&\verb+0+	&\verb+@+	&\verb+P+	&\verb+`+	&\verb+p+\\
0001	&\verb+SOH+	&\verb+DC1+	&\verb+!+	&\verb+1+	&\verb+A+	&\verb+Q+	&\verb+a+	&\verb+q+\\
0010	&\verb+STX+	&\verb+DC2+	&\verb+"+	&\verb+2+	&\verb+B+	&\verb+R+	&\verb+b+	&\verb+r+\\
0011	&\verb+ETX+	&\verb+DC3+	&\verb+#+	&\verb+3+	&\verb+C+	&\verb+S+	&\verb+c+	&\verb+s+\\

0100	&\verb+EOT+	&\verb+DC4+	&\verb+$+	&\verb+4+	&\verb+D+	&\verb+T+	&\verb+d+	&\verb+t+\\
0101	&\verb+ENQ+	&\verb+NAK+	&\verb+%+	&\verb+5+	&\verb+E+	&\verb+U+	&\verb+e+	&\verb+u+\\
0110	&\verb+ACK+	&\verb+SYN+	&\verb+&+	&\verb+6+	&\verb+F+	&\verb+V+	&\verb+f+	&\verb+v+\\
0111	&\verb+BEL+	&\verb+ETB+	&\verb+'+	&\verb+7+	&\verb+G+	&\verb+W+	&\verb+g+	&\verb+w+\\

1000	&\verb+BS+	&\verb+CAN+	&\verb+(+	&\verb+8+	&\verb+H+	&\verb+X+	&\verb+h+	&\verb+x+\\
1001	&\verb+HT+	&\verb+EM+	&\verb+)+	&\verb+9+	&\verb+I+	&\verb+Y+	&\verb+i+	&\verb+y+\\
1010	&\verb+LF+	&\verb+SUB+	&\verb+*+	&\verb+:+	&\verb+J+	&\verb+Z+	&\verb+j+	&\verb+z+\\
1011	&\verb+VT+	&\verb+ESC+	&\verb/+/	&\verb+;+	&\verb+K+	&\verb+[+	&\verb+k+	&\verb+{+\\

1100	&\verb+FF+	&\verb+FS+	&\verb+,+	&\verb+<+	&\verb+L+	&\verb+\+	&\verb+l+	&\verb+|+\\
1101	&\verb+CR+	&\verb+GS+	&\verb+-+	&\verb+=+	&\verb+M+	&\verb+]+	&\verb+m+	&\verb+}+\\
1110	&\verb+SO+	&\verb+RS+	&\verb+.+	&\verb+>+	&\verb+N+	&\verb+^+	&\verb+n+	&\verb+~+\\
1111	&\verb+SI+	&\verb+US+	&\verb+/+	&\verb+?+	&\verb+O+	&\verb+_+	&\verb+o+	&\verb+DEL+
\end{tabular}
\caption{ASCII standaard.}
\tbllab{aSCIIStandard}
\end{table}
Een standaard om tekst voor te stellen is de American Standard Code for Information Interchange (ASCII). ASCII reserveert 7 bit per karakter. Deze 7 bit zorgen voor 128 mogelijke karakters. De karakterset bestaat uit de Romaanse letters, Arabische cijfers, diverse leestekens en enkele functiesymbolen. De toewijzing van deze symbolen vertoont enige logica om bijvoorbeeld kleine letters naar hoofdletters om te zetten, en binaire getallen in hun ASCII equivalent. Tabel \ref{tbl:aSCIIStandard} toont de ASCII-karakters met hun bijbehorende binaire code. ASCII bevat geen ondersteuning voor cyrillisch, Arabisch,... Unicode is een standaard die 8, 16 of 32 bit per karakter reserveert om dit probleem op te lossen. Anno 2011 is $11\%$ van de binaire waarden toegewezen.
\section{Andere basisschakelingen}
\label{s:andereBasis}
Naast de rekenkundige schakelingen in sectie \ref{s:rekenkundig} zullen we in schema's ook geregeld enkele andere bouwstenen terugvinden. In deze sectie zullen we de meest voornaamste bespreken: In subsectie \ref{ss:multiplexer} bespreken we de multiplexer. Daarna bespreken we in \ref{ss:decoder} en \ref{ss:demultiplexer} twee verwante bouwstenen: de decoder en demultiplexer. Het omgekeerde van de decoder, de encoder behandelen we in \ref{ss:encoder}. We eindigen met de vergelijker in \ref{ss:comparator} en de reeds aangehaalde schuifoperatie in subsectie \ref{ss:shiftoperators}.
\subsection{Multiplexer}
\label{ss:multiplexer}
Een \termen{multiplexer}, \termen{selector} of \termen{MUX} is een component die bij $n$ \termen{selectie-ingangen $s_i$} en $2^n$ \termen{data-ingangen $d_i$}, de data-ingang met index $S$ op de uitgang zet. Hierbij is $S$ de waarde die voorgesteld wordt door de selectie-ingangen. In een blokschema wordt deze component voorgesteld door een trapezium, waarbij de data-ingangen aan de lange zijde staan, de uitgangen aan de korte zijde, en de selectie-ingangen aan \'e\'en van de schuine zijden zoals op figuur \ref{fig:multiplexerInterface}. Deze figuur toont een 4-naar-1 MUX. Eventueel worden aan de andere kant ook uitgangen toegevoegd, deze zijn identiek aan de selectie-ingangen aan de ene kant en dienen enkel om het blokschema overzichtelijker te maken. Figuren \ref{fig:multiplexerTruthTable} en \ref{fig:multiplexerSchema} tonen respectievelijk de eerder informeel besproken waarheidstabel en een mogelijke implementatie van deze component.
\begin{figure}[hbt]
\centering
\subfigure[Interface]{
  \begin{tikzpicture}
  \node[mux4to1] (I) at (0,0) {};
  \draw[<-] (I.selin0) -- (I.selin0 -| -1,0) node[scale=0.75,anchor=east]{$s_0$};
  \draw[<-] (I.selin1) -- (I.selin1 -| -1,0) node[scale=0.75,anchor=east]{$s_1$};
  \draw[->] (I.selout0) -- (I.selout0 -| 1,0) node[scale=0.75,anchor=west]{$s_0$};
  \draw[->] (I.selout1) -- (I.selout1 -| 1,0) node[scale=0.75,anchor=west]{$s_1$};
  \draw[->] (I.output) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$f$};
  \draw[<-] (I.data0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_0$};
  \draw[<-] (I.data1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_1$};
  \draw[<-] (I.data2) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_2$};
  \draw[<-] (I.data3) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_3$};
  \end{tikzpicture}
  \figlab{multiplexerInterface}
}
\subfigure[Waarheidstabel] {
\begin{tikzpicture}
\draw (0,0) node[scale=0.95]{\begin{tabular}{cc|c}
$s_0$&$s_1$&$f$\\\hline
0&0&$d_0$\\
0&1&$d_1$\\
1&0&$d_2$\\
1&1&$d_3$
\end{tabular}};
\end{tikzpicture}
\figlab{multiplexerTruthTable}}
\subfigure[Mogelijke Implementatie]{
%\begin{tikzpicture}[circuit logic US,scale=1,xscale=0.8]
%\draw[dashed] (-3.5,2.25) -- (3.5,2.25) -- (2.25,-0.25) -- (-2.25,-0.25) -- cycle;
%\node[or gate, inputs={normal,normal,normal,normal},scale=0.7,rotate=-90] (O) at (0,0.25) {};
%\foreach\d/\dga/\dgb in {0/inverted/inverted,1/inverted/normal,2/normal/inverted,3/normal/normal} {
%  \node[and gate, inputs={\dga,\dgb,normal},scale=0.7,rotate=-90] (A\d) at (2.25-1.5*\d,1.25) {};
%  \draw (A\d.input 3) -- (A\d.input 3 |- 0,2.25);
%  \draw (A\d.input 1) -- (A\d.input 1 |- 0,1.75);
%  \draw (A\d.input 2) -- (A\d.input 2 |- 0,2);
%  \draw[dashed] (A\d.input 3 |- 0,2.25) -- ++(0,0.25) node[anchor=south]{$d_\d$};
%}
%\foreach\s/\g in {0/1,1/2} {
%  \draw[dashed] (-3-1/6-\s/6,1.75+0.25*\s) -- (-3.75,1.75+0.25*\s) node[anchor=east]{$s_\s$};
%  \draw (-3-1/6-\s/6,1.75+0.25*\s) -- (A0.input \g |- 0,1.75+0.25*\s);
%}
%\foreach\d/\g/\y in {0/1/0,1/2/1,2/3/1,3/4/0} {
%  \draw (A\d.output) -- ++(0,-0.25+\y*0.1) -| (O.input \g);
%}
%\draw (O.output) -- (O.output |- 0,-0.25);
%\draw[dashed] (O.output |- 0,-0.25) -- (O.output |- 0,-0.5) node[anchor=north]{$f$};
%\end{tikzpicture}
\begin{tikzpicture}[circuit logic US,scale=4]
\draw[dashed] (-0.5,-0.3) -- (-0.8,0.3) -- (0.8,0.3) -- (0.5,-0.3) -- cycle;
\node[or gate,scale=0.2*0.85,rotate=-90,inputs={normal,normal,normal,normal}] (O) at (0,-0.15) {};
\node[and gate,scale=0.2,rotate=-90,inputs={inverted,normal,inverted}] (A0) at (0.45,0.09) {};
\node[and gate,scale=0.2,rotate=-90,inputs={normal,normal,inverted}] (A1) at (0.16,0.09) {};
\node[and gate,scale=0.2,rotate=-90,inputs={inverted,normal,normal}] (A2) at (-0.16,0.09) {};
\node[and gate,scale=0.2,rotate=-90,inputs={normal,normal,normal}] (A3) at (-0.48,0.09) {};
\coordinate (Fdl) at (0,-0.3);
\coordinate (Sia) at (-0.6,-0.1);
\coordinate (Sib) at (-0.7,0.1);
\coordinate (Soa) at (0.6,-0.1);
\coordinate (Sob) at (0.7,0.1);
\coordinate (Dia) at (A0.output |- 0,0.3);
\coordinate (Dib) at (A1.output |- 0,0.3);
\coordinate (Dic) at (A2.output |- 0,0.3);
\coordinate (Did) at (A3.output |- 0,0.3);
\draw (Sib) |- (Sob |- 0,0.265) -- (Sob);
\draw (Sia) |- (Soa |- 0,0.225) -- (Soa);
\draw (Dia) -- (A0.input 2);
\draw (Dib) -- (A1.input 2);
\draw (Dic) -- (A2.input 2);
\draw (Did) -- (A3.input 2);
\draw[dashed] (Fdl) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$f$};
\draw[dashed] (Dia) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_0$};
\draw[dashed] (Dib) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_1$};
\draw[dashed] (Dic) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_2$};
\draw[dashed] (Did) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_3$};
\draw (A0.input 1) -- (A0.input 1 |- 0,0.225);
\draw (A1.input 1) -- (A1.input 1 |- 0,0.225);
\draw (A2.input 1) -- (A2.input 1 |- 0,0.225);
\draw (A3.input 1) -- (A3.input 1 |- 0,0.225);
\draw (A0.input 3) -- (A0.input 3 |- 0,0.265);
\draw (A1.input 3) -- (A1.input 3 |- 0,0.265);
\draw (A2.input 3) -- (A2.input 3 |- 0,0.265);
\draw (A3.input 3) -- (A3.input 3 |- 0,0.265);
\draw[dashed] (Sib) -- (-0.9,0 |- Sib) node[scale=0.75,anchor=east]{$s_1$};
\draw[dashed] (Sia) -- (-0.9,0 |- Sia) node[scale=0.75,anchor=east]{$s_0$};
\draw[dashed] (Sob) -- (0.9,0 |- Sib) node[scale=0.75,anchor=west]{$s_1$};
\draw[dashed] (Soa) -- (0.9,0 |- Sia) node[scale=0.75,anchor=west]{$s_0$};
\draw (A3.output) -- (A3.output |- 0,-0.03) -| (O.input 4);
\draw (A2.output) -- (A2.output |- 0,-0.01) -| (O.input 3);
\draw (A1.output) -- (A1.output |- 0,-0.01) -| (O.input 2);
\draw (A0.output) -- (A0.output |- 0,-0.03) -| (O.input 1);
\draw (Fdl) -- (O.output);
\begin{scope}[scale=0.25]
\pdot{A0.input 1 |- 0,0.9}
\pdot{A1.input 1 |- 0,0.9}
\pdot{A2.input 1 |- 0,0.9}
\pdot{A3.input 1 |- 0,0.9}
\pdot{A0.input 3 |- 0,1.06}
\pdot{A1.input 3 |- 0,1.06}
\pdot{A2.input 3 |- 0,1.06}
\pdot{A3.input 3 |- 0,1.06}
\end{scope}
\end{tikzpicture}
\figlab{multiplexerSchema}}
\subfigure[Cascade]{
\begin{tikzpicture}[circuit logic US]
\node[mux4to1] (A) at (6,0) {};
\draw (A.selin1) -- (A.selin1 -| 1.5,0) node[scale=0.65,anchor=east]{$s_3$};
\draw (A.selin0) -- (A.selin0 -| 1.5,0) node[scale=0.65,anchor=east]{$s_2$};
\draw (A.output) -- ++(0,-0.25) node[scale=0.65,anchor=north]{$f$};
\foreach \x/\s in {0/0,1/1,2/1,3/0} {
  \node[mux4to1] (B\x) at (9-2*\x,1) {};
  \draw (B\x.output) -- ++(0,-0.25+0.125*\s) -| (A.data\x);
}
\foreach \x/\g/\i in {0/0/0,0/1/1,0/2/2,0/3/3,1/0/4,1/1/5,1/2/6,1/3/7,2/0/8,2/1/9,2/2/10,2/3/11,3/0/12,3/1/13,3/2/14,3/3/15} {
  \draw (B\x.data\g) -- ++(0,0.25) node[scale=0.65,anchor=south]{$d_{\i}$};
}
\foreach \x/\xa in {3/2,2/1,1/0} {
  \draw (B\x.selout0) -- (B\xa.selin0);
  \draw (B\x.selout1) -- (B\xa.selin1);
}
\draw (B3.selin1) -- (B3.selin1 -| 1.5,0) node[scale=0.65,anchor=east]{$s_1$};
\draw (B3.selin0) -- (B3.selin0 -| 1.5,0) node[scale=0.65,anchor=east]{$s_0$};
\end{tikzpicture}
\figlab{multiplexerCascade}}
\caption{Multiplexer.}
\figlab{multiplexer}
\end{figure}
\subsubsection{Cascade}
We kunnen uiteraard multiplexers met een verschillende parameter $n$ bouwen. Het probleem is echter dat deze waarden erg kunnen vari\"eren, wat weinig interessant is voor massaproductie. Daarom zal men veelal met een \termen{cascade} werken. Figuur \ref{fig:multiplexerCascade} toont een 16-naar-1 MUX gebouwd met behulp van 5 4-naar-1 multiplexers. We kunnen dit uiteraard veralgemenen: Indien we een $2^{n\times m}$-naar-1 multiplexer willen bouwen, kunnen we dit met $n$ niveaus van $2^m$-naar-1 multiplexers. Het aantal multiplexers die we in dat geval nodig hebben is:
\begin{equation}
\mbox{aantal multiplexers}=\displaystyle\frac{2^{n\times m}-1}{2^m-1}
\end{equation}
\subsection{Decoder}
\label{ss:decoder}
Een andere schakeling die sterk gerelateerd is aan een multiplexer is een \termen{decoder}. Een decoder beschikt over een \termen{enable-ingang $e$}, en $n$ \termen{adres-ingangen $a_i$}. De uitvoer bestaat uit $2^n$ \termen{selectie-uitgangen $s_i$}. Een decoder zal indien er een 1 aangelegd wordt op de enable-ingang $e$, een 1 op de uitgang zetten met index $A$. Hierbij staat $A$ voor de binaire waarde die voorgesteld wordt door de adres-ingangen $a_i$. In een blokschema wordt een decoder voorgesteld zoals op figuur \ref{fig:decoderInterface} door een rechthoek. In dit geval een 2-naar-4 decoder. Bovenaan staan de adres-ingangen $a_i$, aan de zijkant de enable-ingang $e$, en onderaan de uitgangen $s_i$.
\begin{figure}[hbt]
\centering
\subfigure[Interface]{
\begin{tikzpicture}
  \node[decoder2to4] (I) at (0,0) {Decoder};
  \draw[<-] (I.enable) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$e$};
  \draw[->] (I.s0) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_0$};
  \draw[->] (I.s1) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_1$};
  \draw[->] (I.s2) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_2$};
  \draw[->] (I.s3) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_3$};
  \draw[<-] (I.a0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$a_0$};
  \draw[<-] (I.a1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$a_1$};
\end{tikzpicture}
\figlab{decoderInterface}
}
\subfigure[Waarheidstabel] {
\begin{tikzpicture}
\draw (0,0) node[scale=0.75]{\begin{tabular}{ccc|cccc}
$e$&$a_0$&$a_1$&$s_0$&$s_1$&$s_2$&$s_3$\\\hline
0&-&-&0&0&0&0\\
1&0&0&1&0&0&0\\
1&0&1&0&1&0&0\\
1&1&0&0&0&1&0\\
1&1&1&0&0&0&1\\
\end{tabular}};
\end{tikzpicture}
\figlab{decoderTruthTable}}
\subfigure[Mogelijke implementatie]{
\begin{tikzpicture}[circuit logic US,scale=3]
\draw[dashed] (-0.8,-0.3) rectangle (0.8,0.3);
\draw[black!30] (0,0) node[scale=3]{Decoder};
\coordinate (Ei) at (-0.8,0);
\coordinate (Aia) at (0.26666,0.3);
\coordinate (Aib) at (-0.26666,0.3);
\coordinate (Soa) at (0.48,-0.3);
\coordinate (Sob) at (0.16,-0.3);
\coordinate (Soc) at (-0.16,-0.3);
\coordinate (Sod) at (-0.48,-0.3);
\node[and gate,scale=0.27,rotate=-90,inputs={normal,inverted,inverted},anchor=output] (A0) at (Soa |- 0,-0.25) {};
\node[and gate,scale=0.27,rotate=-90,inputs={normal,normal,inverted},anchor=output] (A1) at (Sob |- 0,-0.25) {};
\node[and gate,scale=0.27,rotate=-90,inputs={normal,inverted,normal},anchor=output] (A2) at (Soc |- 0,-0.25) {};
\node[and gate,scale=0.27,rotate=-90,inputs={normal,normal,normal},anchor=output] (A3) at (Sod |- 0,-0.25) {};
\draw (Ei) -| (-0.7,0.25) -| (A0.input 1);
\draw (A1.input 1 |- 0,0.25) -- (A1.input 1);
\draw (A2.input 1 |- 0,0.25) -- (A2.input 1);
\draw (A3.input 1 |- 0,0.25) -- (A3.input 1);
\draw (A1.input 2 |- 0,0.2) -- (A1.input 2);
\draw (A2.input 2 |- 0,0.2) -- (A2.input 2);
\draw (A1.input 3 |- 0,0.15) -- (A1.input 3);
\draw (A2.input 3 |- 0,0.15) -- (A2.input 3);
\draw (Aia) -- (Aia |- 0,0.2);
\draw (Aib) -- (Aib |- 0,0.15);
\draw (A3.input 2) -- (A3.input 2 |- 0,0.2) -| (A0.input 2);
\draw (A3.input 3) -- (A3.input 3 |- 0,0.15) -| (A0.input 3);
\draw (A0.output) -- (Soa);
\draw (A1.output) -- (Sob);
\draw (A2.output) -- (Soc);
\draw (A3.output) -- (Sod);
\draw[dashed] (Soa) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$s_0$};
\draw[dashed] (Sob) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$s_1$};
\draw[dashed] (Soc) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$s_2$};
\draw[dashed] (Sod) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$s_3$};
\draw[dashed] (Aia) -- ++(0,0.1) node[scale=0.75,anchor=south]{$a_0$};
\draw[dashed] (Aib) -- ++(0,0.1) node[scale=0.75,anchor=south]{$a_1$};
\draw[dashed] (Ei) -- ++(-0.1,0) node[scale=0.75,anchor=east]{$e$};
\begin{scope}[scale=0.333]
\pdot{A1.input 1 |- 0,0.75}
\pdot{A2.input 1 |- 0,0.75}
\pdot{A3.input 1 |- 0,0.75}
\pdot{A1.input 2 |- 0,0.6}
\pdot{A2.input 2 |- 0,0.6}
\pdot{A1.input 3 |- 0,0.45}
\pdot{A2.input 3 |- 0,0.45}
\pdot{Aia |- 0,0.6}
\pdot{Aib |- 0,0.45}
\end{scope}
\end{tikzpicture}
\figlab{decoderSchema}}
\subfigure[Cascade]{
\begin{tikzpicture}[circuit logic US]
\node[decoder2to4] (A) at (0,0) {Decoder};
\draw (A.a0) -- ++(0,0.25) node[anchor=south,scale=0.75]{$a_2$};
\draw (A.a1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$a_3$};
\draw (A.enable) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$e$};
\foreach\x/\y in {0/1,1/0,2/0,3/1} {
  \node[decoder2to4] (B\x) at (3-2*\x,-1.5) {Decoder};
  \draw (B\x.a0) -- ++(0,0.125) node[anchor=south,scale=0.75]{$a_0$};
  \draw (B\x.a1) -- ++(0,0.125) node[anchor=south,scale=0.75]{$a_1$};
  \draw (B\x.enable) -- ++(-0.2,0) |- (A.s\x |- 0,-0.7+0.2*\y) -- (A.s\x);
}
\foreach \x/\y/\z in {0/0/0,0/1/1,0/2/2,0/3/3,1/0/4,1/1/5,1/2/6,1/3/7,2/0/8,2/1/9,2/2/10,2/3/11,3/0/12,3/1/13,3/2/14,3/3/15} {
  \draw (B\x.s\y) -- ++(0,-0.25) node[anchor=north,scale=0.75]{$s_{\z}$};
}
\end{tikzpicture}
\figlab{decoderCascade}}
\caption{Decoder.}
\figlab{decoder}
\end{figure}
Op figuur \ref{fig:decoderTruthTable} staat de waarheidstabel voor deze component. Figuur \ref{fig:decoderSchema} toont een mogelijke implementatie. Decoders worden hoofdzakelijk gebruikt voor het decoderen van adressen.
\subsubsection{Cascade}
Net als bij multiplexer kunnen we in plaats van een heel arsenaal aan decoders aan te bieden door middel van een cascade een nieuwe decoder bouwen, zoals op figuur \ref{fig:decoderCascade}. Hier bouwen we een 4-naar-16 decoder met 5 2-naar-4 decoders. In het algemeen kunnen we een $nm$-naar-$2^{nm}$ decoder bouwen met $n$ niveaus van $m$-naar-$2^m$ decoders. In totaal hebben we dus volgend aantal decoders nodig:
\begin{equation}
\mbox{aantal decoders}=\displaystyle\frac{2^{n\times m}-1}{2^m-1}
\end{equation}
\subsubsection{Alternatieve implementatie voor Multiplexers}
Decoders worden ook gebruikt voor de synthese van bijvoorbeeld multiplexers. Figuur \ref{fig:decoderMultiplexerAnd} toont een manier om op basis van AND-poorten en een decoder een multiplexer te bouwen. We kunnen echter de OR-poort weglaten en de AND-poorten vervangen door 3-state buffers zoals op figuur \ref{fig:decoderMultiplexerTriState}. In dat geval hebben we een schakeling gerealiseerd die we een \termen{bus} noemen. Bussen zijn multiplexers waarbij we toelaten dat de ingangen gedistribueerd zijn over de verschillende delen van de schakeling. Elk van deze ingangen dienen we eenvoudigweg een uitgang van de decoder toe toe te wijzen, en de uitgang met een 3-state buffer verbinden met de bus. Bussen hebben verschillende voordelen:
\begin{itemize}
 \item We kunnen makkelijk het aantal ingangen uitbreiden. We dienen enkel over een decoder met voldoende grote $n$ te beschikken en een tri-state buffer per ingang.
 \item Indien we de traditionele Multiplexer gebruiken zal bij een groot aantal ingangen de fan-in van de OR-poort toenemen. Bovendien moeten alle ingangen van de multiplexer dicht bij elkaar staan.
 \item 3-state buffers zijn meestal gratis op een FPGA. Elk logisch blok (LB) heeft immers minstens \'e\'en uitgang langs een 3-state buffer die verbonden is met een lange lijn.
\end{itemize}
\begin{figure}[hbt]
\centering
\subfigure[Muliplexer]{
\begin{tikzpicture}[circuit logic US,scale=4]
\coordinate (Fdl) at (0,-0.3);
\coordinate (Sia) at (-0.6,-0.1);
\coordinate (Sib) at (-0.7,0.1);
\draw[dashed] (-0.5,-0.3) -- (-0.8,0.3) -- (0.8,0.3) -- (0.5,-0.3) -- cycle;
\node[decoder2to4,scale=0.75,rotate=90] (D) at (-0.50,0) {Decoder};
\draw (D.enable) -- ++(0,-0.05) node[anchor=north,scale=0.75]{$1$};
\draw (D.a0) -| (Sia);
\draw (D.a1) -- ++(-0.025,0) |- (Sib);
\node[or gate,scale=0.2*0.85,rotate=-90,inputs={normal,normal,normal,normal}] (O) at (0,-0.15) {};
\node[and gate,scale=0.2,rotate=-90,inputs={normal,normal}] (A0) at (0.24,0.09) {};
\node[and gate,scale=0.2,rotate=-90,inputs={normal,normal}] (A1) at (0.08,0.09) {};
\node[and gate,scale=0.2,rotate=-90,inputs={normal,normal}] (A2) at (-0.08,0.09) {};
\node[and gate,scale=0.2,rotate=-90,inputs={normal,normal}] (A3) at (-0.24,0.09) {};
\coordinate (Dia) at (A0.input 1 |- 0,0.3);
\coordinate (Dib) at (A1.input 1 |- 0,0.3);
\coordinate (Dic) at (A2.input 1 |- 0,0.3);
\coordinate (Did) at (A3.input 1 |- 0,0.3);
\draw (Dia) -- (A0.input 1);
\draw (Dib) -- (A1.input 1);
\draw (Dic) -- (A2.input 1);
\draw (Did) -- (A3.input 1);
\draw (A0.input 2) |- (-0.41,0.27) |- (D.s0);
\draw (A1.input 2) |- (-0.38,0.24) |- (D.s1);
\draw (A2.input 2) |- (-0.35,0.21) |- (D.s2);
\draw (A3.input 2) |- (-0.32,0.18) |- (D.s3);
\draw[dashed] (Fdl) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$f$};
\draw[dashed] (Dia) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_0$};
\draw[dashed] (Dib) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_1$};
\draw[dashed] (Dic) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_2$};
\draw[dashed] (Did) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_3$};
\draw[dashed] (Sib) -- (-0.9,0 |- Sib) node[scale=0.75,anchor=east]{$s_1$};
\draw[dashed] (Sia) -- (-0.9,0 |- Sia) node[scale=0.75,anchor=east]{$s_0$};
\draw (A3.output) -- (A3.output |- 0,-0.03) -| (O.input 4);
\draw (A2.output) -- (A2.output |- 0,-0.01) -| (O.input 3);
\draw (A1.output) -- (A1.output |- 0,-0.01) -| (O.input 2);
\draw (A0.output) -- (A0.output |- 0,-0.03) -| (O.input 1);
\draw (Fdl) -- (O.output);
\end{tikzpicture}
\figlab{decoderMultiplexerAnd}}
\subfigure[Bus]{
\begin{tikzpicture}[circuit logic US,scale=4]
\coordinate (Fdl) at (0,-0.3);
\coordinate (Sia) at (-0.6,-0.1);
\coordinate (Sib) at (-0.7,0.1);
\foreach \x in {0,1,2,3} {
  \fill[black!30] (0.18-0.16*\x,0.1) rectangle (0.30-0.16*\x,-0.27);
}
\draw[dashed] (-0.5,-0.3) -- (-0.8,0.3) -- (0.8,0.3) -- (0.5,-0.3) -- cycle;
\node[decoder2to4,scale=0.75,rotate=90] (D) at (-0.50,0) {Decoder};
\draw (D.enable) -- ++(0,-0.05) node[anchor=north,scale=0.75]{$1$};
\draw (D.a0) -| (Sia);
\draw (D.a1) -- ++(-0.025,0) |- (Sib);
\node[tris,scale=0.75,rotate=-90] (T0) at (0.24,0) {};
\node[tris,scale=0.75,rotate=-90] (T1) at (0.08,0) {};
\node[tris,scale=0.75,rotate=-90] (T2) at (-0.08,0) {};
\node[tris,scale=0.75,rotate=-90] (T3) at (-0.24,0) {};
\draw (T0.z) -- (T0.z |- 0,-0.25);
\draw (T1.z) -- (T1.z |- 0,-0.25);
\draw (T2.z) -- (T2.z |- 0,-0.25);
\draw (T3.z) -- (T3.z |- 0,-0.25);
\draw (Fdl |- 0,-0.25) -- (Fdl);
\draw[thick] (T0.z |- 0,-0.25) node[anchor=west,scale=0.75]{bus} -- (T3.z |- 0,-0.25);
\coordinate (Dia) at (T0.z |- 0,0.3);
\coordinate (Dib) at (T1.z |- 0,0.3);
\coordinate (Dic) at (T2.z |- 0,0.3);
\coordinate (Did) at (T3.z |- 0,0.3);
\draw (Dia) -- (T0.x);
\draw (Dib) -- (T1.x);
\draw (Dic) -- (T2.x);
\draw (Did) -- (T3.x);
\draw (T3.c) -- (T3.c -| -0.32,0) |- (D.s3);
\foreach \x in {0,1,2} {
  \draw (T\x.c) -| (0.16-0.16*\x,0.25-0.03*\x) -| (D.s\x -| -0.41+0.03*\x,0) -- (D.s\x);
}
\draw[dashed] (Fdl) -- ++(0,-0.1) node[scale=0.75,anchor=north]{$f$};
\draw[dashed] (Dia) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_0$};
\draw[dashed] (Dib) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_1$};
\draw[dashed] (Dic) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_2$};
\draw[dashed] (Did) -- ++(0,0.1) node[scale=0.75,anchor=south]{$d_3$};
\draw[dashed] (Sib) -- (-0.9,0 |- Sib) node[scale=0.75,anchor=east]{$s_1$};
\draw[dashed] (Sia) -- (-0.9,0 |- Sia) node[scale=0.75,anchor=east]{$s_0$};
\end{tikzpicture}
\figlab{decoderMultiplexerTriState}}
\caption{Multiplexer en bus gesynthetiseerd met decoders.}
\figlab{decoderMultiplexer}
\end{figure}
\subsection{Demultiplexer}
\label{ss:demultiplexer}
Het inverse van een $2^n$-naar-1 multiplexer is een 1-naar-$2^n$ \termen{demultiplexer} (ook wel \termen{demux} genoemd). Deze component bestaat dan ook logischerwijs uit 1 \termen{data-ingang $d$} en $n$ \termen{selectie-ingangen $a_i$}. De component beschikt verder over $2^n$ uitgangen $s_i$. Logischerwijs zetten we de waarde van de data-ingang $d$ op de uitgang met de index die wordt voorgesteld door de selectie-ingangen. Een aandachtige lezer zal misschien al opgemerkt hebben dat dit probleem in wezen niet veel verschilt van de constructie van een decoder. Sterker nog, we hoeven niets aan te passen, het is alleen een kwestie van een andere interface. Figuur \ref{fig:demultiplexer} toont de interface van een demultiplexer en de equivalentie met een decoder. In tegenstelling tot de decoder zetten we de selectie-ingangen aan de zijkant en de data-ingang aan de bovenkant.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\node[demux1to4] (DM) at (0,0) {Demux};
\draw (DM.a0) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$a_0$};
\draw (DM.a1) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$a_1$};
\draw (DM.s0) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_0$};
\draw (DM.s1) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_1$};
\draw (DM.s2) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_2$};
\draw (DM.s3) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_3$};
\draw (DM.data) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d$};
\node (E) at (2,0) {$\equiv$};
\node[decoder2to4] (DC) at (4,0) {Decoder};
\draw (DC.a0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$a_0$};
\draw (DC.a1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$a_1$};
\draw (DC.s0) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_0$};
\draw (DC.s1) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_1$};
\draw (DC.s2) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_2$};
\draw (DC.s3) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$s_3$};
\draw (DC.enable) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$d$};
\end{tikzpicture}
\caption{Demultiplexer}
\figlab{demultiplexer}
\end{figure}
\paragraph{}
Demultiplexers worden maar zeer zelden gebruikt, kun doel is immers om data op een bepaalde lijn te plaatsen, terwijl men op de andere lijnen een 0 aanlegt. In de praktijk is het aanleggen van de data op alle lijnen meestal geen probleem. In dat geval kunnen we dus de demultiplexer eenvoudigweg vervangen door een draad die de data-ingang met alle uitgangen verbindt.
\subsection{Encoder}
\label{ss:encoder}
Ook de decoder heeft een inverse: een $2^n$-naar-$n$ \termen{encoder}. Een encoder bevat $2^n$ \termen{data-ingangen $d_i$}. Het is de bedoeling dat de encoder afhankelijk van de lijn waarop een 1 staat de index weergeeft op de \termen{selectie-uitgangen $s_i$}. Verder bevat de encoder ook nog een extra uitgang: de \termen{any-uitgang $a$}, op deze uitgang wordt 1 aangelegd indien \'e\'en van de data-ingangen een 1 vertoont, anders wordt er een 0 op de any-uitgang aangelegd. We kunnen dit gedrag samenvatten in een waarheidstabel zoals in tabel \ref{tbl:truthTableEncoderNormal} voor een 4-naar-2 encoder.
\begin{table}[hbt]
\centering
\subtable[Encoder]{
\begin{tabular}{cccc|ccc}
$d_3$&$d_2$&$d_1$&$d_0$&$a$&$f_1$&$f_0$\\\hline
0&0&0&0&0&-&-\\
0&0&0&1&1&0&0\\
0&0&1&0&1&0&1\\
0&1&0&0&1&1&0\\
1&0&0&0&1&1&1\\
\end{tabular}
\tbllab{truthTableEncoderNormal}
}
\subtable[Prioriteitsencoder]{
\begin{tabular}{cccc|ccc}
$d_3$&$d_2$&$d_1$&$d_0$&$a$&$f_1$&$f_0$\\\hline
0&0&0&0&0&-&-\\
0&0&0&1&1&0&0\\
0&0&1&-&1&0&1\\
0&1&-&-&1&1&0\\
1&-&-&-&1&1&1\\
\end{tabular}
\tbllab{truthTablePriorityEncoder}
}
\caption{Waarheidtabellen van een encoder en prioriteitsencoder.}
\end{table}
Merk op dat de tabel niet alle strikt mogelijke ingangen toont. We nemen aan dat aan de ingang enkel geldige toestanden verschijnen. Indien dit niet zo is, staat het in principe vrij om elke uitgang aan te leggen. De ontbrekende rijen bevatten dus don't cares op alle uitgangen. Op basis van deze tabel kunnen we eventueel Karnaugh-kaarten maken en een implementatie voorstellen:
\begin{equation}
\left\{
\begin{array}{l}
a=d_3+d_2+d_1+d_0\\
f_1=d_3+d_1\\
f_0=d_3+d_2
\end{array}
\right.
\end{equation}
We kunnen deze schakeling dus eenvoudig realiseren met \'e\'en OR-poort per uitgang.
\paragraph{Prioriteitsencoder}
Een variant van de encoder is de \termen{prioriteitsencoder}. Een prioriteitsencoder biedt een antwoord op de ongeldige ingangen van de encoder. Hierbij telt niet d\'e index van de data-ingang waarop een 1 wordt aangelegd, maar de hoogste index van alle datalijnen met 1. Tabel \ref{tbl:truthTablePriorityEncoder} formaliseert dit. Deze schakeling kunnen we als volgt implementeren:
\begin{equation}
\left\{
\begin{array}{l}
a=d_3+d_2+d_1+d_0\\
f_1=d_3+d_2'd_1\\
f_0=d_3+d_2
\end{array}
\right.
\end{equation}
Dit komt overeen met \'e\'en extra AND- en NOT-poort. De interface voor beide schakelingen staat beschreven op figuur \ref{fig:encoderInterface}.
\begin{figure}[hbt]
\centering
\subfigure[Interfaces]{
\begin{tikzpicture}
\node[encoder4to2] (E) at (0,0) {Encoder};
\draw[<-] (E.d0) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_0$};
\draw[<-] (E.d1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_1$};
\draw[<-] (E.d2) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_2$};
\draw[<-] (E.d3) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_3$};
\draw[->] (E.f0) -- ++(0,-0.25) node[anchor=north,scale=0.75]{$f_0$};
\draw[->] (E.f1) -- ++(0,-0.25) node[anchor=north,scale=0.75]{$f_1$};
\draw[->] (E.any) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$a$};
\node[encoder4to2,text width=1.6 cm] (PE) at (3,0) {Prioriteits-encoder};
\draw[<-] (PE.d0) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_0$};
\draw[<-] (PE.d1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_1$};
\draw[<-] (PE.d2) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_2$};
\draw[<-] (PE.d3) -- ++(0,0.25) node[anchor=south,scale=0.75]{$d_3$};
\draw[->] (PE.f0) -- ++(0,-0.25) node[anchor=north,scale=0.75]{$f_0$};
\draw[->] (PE.f1) -- ++(0,-0.25) node[anchor=north,scale=0.75]{$f_1$};
\draw[->] (PE.any) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$a$};
\end{tikzpicture}
\figlab{encoderInterface}
}
\subfigure[Cascade]{
\begin{tikzpicture}
\foreach \x in {0,1,2,3} {
  \node[encoder4to2,text width=1.6 cm] (Ea\x) at (-3*\x,0) {Prioriteits-encoder};
}
\node[encoder4to2,text width=1.6 cm] (Eb3) at (-9,-3) {Prioriteits-encoder};
\node[mux4to1] (Mb2) at (-6,-3) {};
\node[mux4to1] (Mb1) at (-3,-3) {};
\foreach \x/\y/\z in {0/0/0,1/1/1,2/2/1,3/1/0} {
  \draw (Ea\x.any) -| (-3*\x-1.4,-2.4+0.1*\y) -| (Eb3.d\x);
  \draw (Ea\x.f1) -- (Ea\x.f1 |- 0,-1.6+0.1*\z) -| (Mb2.data\x);
  \draw (Ea\x.f0) -- (Ea\x.f0 |- 0,-1+0.1*\z) -| (Mb1.data\x);
}
\draw[<-] (Ea0.d0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_0$};
\draw[<-] (Ea0.d1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_1$};
\draw[<-] (Ea0.d2) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_2$};
\draw[<-] (Ea0.d3) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_3$};
\draw[<-] (Ea1.d0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_4$};
\draw[<-] (Ea1.d1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_5$};
\draw[<-] (Ea1.d2) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_6$};
\draw[<-] (Ea1.d3) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_7$};
\draw[<-] (Ea2.d0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_8$};
\draw[<-] (Ea2.d1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_9$};
\draw[<-] (Ea2.d2) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_{10}$};
\draw[<-] (Ea2.d3) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_{11}$};
\draw[<-] (Ea3.d0) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_{12}$};
\draw[<-] (Ea3.d1) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_{13}$};
\draw[<-] (Ea3.d2) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_{14}$};
\draw[<-] (Ea3.d3) -- ++(0,0.25) node[scale=0.75,anchor=south]{$d_{15}$};
\draw[->] (Eb3.any) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$a$};
\draw[->] (Eb3.f1) -- (Eb3.f1 |- 0,-4.5) node[scale=0.75,anchor=north]{$f_3$};
\draw[->] (Eb3.f0) -- (Eb3.f0 |- 0,-4.5) node[scale=0.75,anchor=north]{$f_2$};
\draw[->] (Mb2.output) -- (Mb2.output |- 0,-4.5) node[scale=0.75,anchor=north]{$f_1$};
\draw[->] (Mb1.output) -- (Mb1.output |- 0,-4.5) node[scale=0.75,anchor=north]{$f_0$};
\draw (Eb3.f1 |- 0,-3.8) -- (-4.5,-3.8) |- (Mb1.selin1);
\draw (-7.5,-3.8) |- (Mb2.selin1);
\draw (-7.3,-4) |- (Mb2.selin0);
\draw (Eb3.f0 |- 0,-4) -- (-4.3,-4) |- (Mb1.selin0);
\pdot{Eb3.f1 |- 0,-3.8};
\pdot{-7.5,-3.8};
\pdot{-7.3,-4};
\pdot{Eb3.f0 |- 0,-4};
\end{tikzpicture}
\figlab{encoderCascade}
}
\caption{Encoder en Prioriteitsencoder.}
\end{figure}
De interface is opnieuw een rechthoek. De data-ingangen staan bovenaan, de selectie-uitgangen onderaan, en de any-uitgang aan de linkerkant.
\subsubsection{Prioriteitsencoders cascaderen}
Ook bij prioriteitsencoders gaan we even in het op het cascaderend karakter. Ook encoders laten zich eenvoudig cascaderen, mits we ook extra multiplexers gebruiken. In figuur \ref{fig:encoderCascade} bouwen we een 16-naar-4 prioriteitsencoder met 4 4-naar-2 prioriteitsencoders en 2 4-naar-1 multiplexers.
\subsection{Vergelijker}
\label{ss:comparator}
Een \termen{vergelijker} of \termen{comparator} is een component die in staat is om uitspraken te doen over hoe twee getallen zich tot elkaar verhouden. Meestal is een vergelijker in staat om een uitspraak te doen over 4 mogelijke verhoudingen van de getallen $X$ en $Y$:
\begin{equation}
\left\{\begin{array}{c}
X<Y\\
X>Y\\
X=Y\\
X\neq Y
\end{array}\right.
\end{equation}
Op basis van de eerste twee relaties, kunnen we uitspraken doen over de laatste twee. Op basis van deze vaststelling synthetiseren we een comparator. Een comparator bevat 4 ingangen ($x_0$ ofwel $g_{\mbox{\tiny{in}}}$, $y_0$ ofwel $l_{\mbox{\tiny{in}}}$, $x_1$ en $y_1$). De twee uitgangen ($g$ en $l$) geven respectievelijk weer of het getal $X>Y$ en $X<Y$. Figuur \ref{fig:comparatorInterface} toont de interface van een vergelijker.
\begin{figure}[hbt]
\centering
\subfigure[Interface]{
\begin{tikzpicture}
\node[comp] (C) at (0,0) {Comp};
\draw[<-] (C.x0) -- ++(0.25,0) node[anchor=west,scale=0.75]{$x_0/g_{\mbox{\tiny{in}}}$};
\draw[<-] (C.y0) -- ++(0.25,0) node[anchor=west,scale=0.75]{$y_0/l_{\mbox{\tiny{in}}}$};
\draw[<-] (C.x1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$x_1$};
\draw[<-] (C.y1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$y_1$};
\draw[->] (C.g) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$g$};
\draw[->] (C.l) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$l$};
\end{tikzpicture}
\figlab{comparatorInterface}
}
\subfigure[Karnaugh-kaarten]{
\begin{tikzpicture}
\kkaartd{0}{0}{$g$}{$x_1$/$y_1$/$x_0$/$y_0$}{0/0/1/0/0/0/0/0/1/1/1/1/0/0/1/0};
\kkaartd{3}{0}{$l$}{$x_1$/$y_1$/$x_0$/$y_0$}{0/1/0/0/1/1/1/1/0/0/0/0/0/1/0/0};
\end{tikzpicture}
\figlab{comparatorKarnaugh}
}
\subfigure[Lineare cascade]{
\begin{tikzpicture}[scale=0.75]
\node[comp,scale=0.75,draw=white] (C0) at (0,0) {};
\foreach \x in {1,...,7} {
  \node[comp,scale=0.75] (C\x) at (-1.5*\x,0) {Comp};
  \draw[<-] (C\x.x1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$x_{\x}$};
  \draw[<-] (C\x.y1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$y_{\x}$};
}
\foreach \x/\y in {1/2,2/3,3/4,4/5,5/6,6/7} {
  \draw (C\x.g) -- (C\y.x0);
  \draw (C\x.l) -- (C\y.y0);
}
\draw[<-] (C1.x0) -| (C0.x1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$x_0$};
\draw[<-] (C1.y0) -| (C0.y1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$y_0$};
\draw[->] (C7.g) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$g$};
\draw[->] (C7.l) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$l$};
\end{tikzpicture}
\figlab{comparatorCascadeLinear}
}
\subfigure[Hi\"erarchische cascade]{
\begin{tikzpicture}[scale=0.75]
\foreach \x in {1,3,5,7} {
  \node[comp,scale=0.75] (C\x) at (-1.5*\x,0) {Comp};
  \draw[<-] (C\x.x1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$x_{\x}$};
  \draw[<-] (C\x.y1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$y_{\x}$};
}
\foreach \x/\y in {0/1,2/3,4/5,6/7} {
  \node[comp,scale=0.75,draw=white] (C\x) at (-1.5*\x,0) {};
  \draw[<-] (C\y.x0) -| (C\x.x1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$x_{\x}$};
  \draw[<-] (C\y.y0) -| (C\x.y1) -- ++(0,0.25) node[anchor=south,scale=0.75]{$y_{\x}$};
}
\foreach \x/\y in {3/1,7/5} {
  \node[comp,scale=0.75] (Cb\x) at (-1.5*\x,-2) {Comp};
  \draw (C\x.g) -| ++(-0.4,-1.2) -| (Cb\x.x1);
  \draw (C\x.l) -| ++(-0.2,-0.6) -| (Cb\x.y1);
  \draw (C\y.g) -- ++(-0.4,0) |- (Cb\x.x0);
  \draw (C\y.l) -- ++(-0.2,0) |- (Cb\x.y0);
}
\foreach \x/\y in {7/3} {
  \node[comp,scale=0.75] (Cc\x) at (-1.5*\x,-4) {Comp};
  \draw (Cb\x.g) -| ++(-0.4,-1.2) -| (Cc\x.x1);
  \draw (Cb\x.l) -| ++(-0.2,-0.6) -| (Cc\x.y1);
  \draw (Cb\y.g) -- ++(-0.4,0) |- (Cc\x.x0);
  \draw (Cb\y.l) -- ++(-0.2,0) |- (Cc\x.y0);
}
\draw[->] (Cc7.g) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$g$};
\draw[->] (Cc7.l) -- ++(-0.25,0) node[anchor=east,scale=0.75]{$l$};
\end{tikzpicture}
\figlab{comparatorCascadeHierarchical}
}
\caption{Vergelijker}
\end{figure}
Op basis van de gedragsbeschrijving kunnen we een waarheidstabel en Karnaugh-kaarten opstellen zoals op figuur \ref{fig:comparatorKarnaugh}. Op basis van deze kaarten synthetiseren we volgende formules\footnote{Merk de dualiteit op: beide formules hebben dezelfde variabelen, alleen zijn alle atomen ge\"inverteerd.}:
\begin{equation}
\left\{\begin{array}{l}
g=x_1y_1'+x_0x_1y_0'+x_0y_0'y_1'\\
l=x_1'y_1+x_0'x_1'y_0+x_0'y_0y_1
\end{array}\right.
\end{equation}
\subsubsection{Vergelijkers cascaderen}
Hoe vergelijken we nu twee getallen die uit meer dan 2-bit bestaan? Net als bij een ripple-carry opteller, kunnen we door verschillende vergelijkers aan elkaar te schakelen, een vergelijker met een groter aantal bits bouwen. In dat geval bekomen we een structuur zoals op figuur \ref{fig:comparatorCascadeLinear}. Hiermee komen we echter tot hetzelfde probleem als bij een ripple-carry opteller: de vertraging schaalt linear met het aantal bits. We kunnen echter de vergelijkers ook in een hi\"erarchische structuur kunnen we de vertraging beperken tot een logaritmische orde zoals op figuur \ref{fig:comparatorCascadeHierarchical}.
\subsubsection{Speciale gevallen}
\paragraph{Testen op gelijkheid}
We kunnen twee getallen altijd vergelijken met een vergelijker zoals eerder beschreven. Soms willen we echter twee getallen testen op specifieke eigenschappen. Bijvoorbeeld of twee getallen gelijk zijn. Dit kunnen we natuurlijk realiseren met een vergelijker, maar dit introduceert extra hardware en vertraging. In dat geval kunnen we gebruik maken van een rij van XNOR-poorten waarbij elke poort \'e\'en bit van het ene en het andere getal als invoer krijgt. De uitgangen van al deze XNOR-poorten laten we vervolgens door een OR-poort gaan. De uitvoer van deze OR poort toont ons dan of $X$ gelijk is aan $Y$. Figuur \ref{fig:comparatorEquality} toont een realisatie van dit concept voor 2 $n$-bit getallen.
\begin{figure}[hbt]
\centering
\subfigure[Gelijkheid]{
\begin{tikzpicture}[circuit logic US]
\node[and gate,inputs={normal,normal,normal,normal,normal,normal,normal},scale=0.5,rotate=-90] (O) at (-3,-1.5) {};
\node[scale=0.75] (P) at (-5,0) {$\ldots$};
\draw (O.output) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$X=Y$};
\foreach \x in {0,1,2,3,4,6} {
  \coordinate (y\x) at (0.25-\x,0.75);
  \coordinate (x\x) at (-0.25-\x,0.75);
}
\foreach \x/\y/\z/\t in {0/1/3/0,1/2/2/1,2/3/1/2,3/4/0/3,4/5/1/4,6/7/3/n-1} {
  \node[xnor gate,rotate=-90] (XN\x) at (-\x,0) {};
  \draw (XN\x.input 1) -- ++(0,0.2) -| (y\x) node[scale=0.75,anchor=south]{$y_{\t}$};
  \draw (XN\x.input 2) -- ++(0,0.2) -| (x\x) node[scale=0.75,anchor=south]{$x_{\t}$};
  \draw (XN\x.output) -- ++(0,-0.1*\z) -| (O.input \y);
}
\end{tikzpicture}
\figlab{comparatorEquality}}
\subfigure[Testen met constanten]{
\begin{tikzpicture}[circuit logic US]
\node[nor gate,inputs={normal,normal,normal,normal,normal}] (O1) at (0,0) {};
\draw (O1.output) -- ++(0.25,0) node[scale=0.75,anchor=west]{$X=0$};
\node[and gate,inputs={normal,normal,normal,normal,normal}] (O2) at (0,-1.5) {};
\draw (O2.output) -- ++(0.25,0) node[scale=0.75,anchor=west]{$X=2^n-1$};
\node[not gate] (O3) at (0,-3) {};
\draw (O3.input) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$x_0$};
\draw (O3.output) -- ++(0.25,0) node[scale=0.75,anchor=west]{$\mbox{even}\left(X\right)$};
\foreach \x/\t in {5/$x_0$,4/$x_1$,3/$x_2$,2/$\ldots$,1/$x_{n-1}$} {
  \draw (O1.input \x) -- ++(-0.25,0) node[scale=0.75,anchor=east]{\t};
  \draw (O2.input \x) -- ++(-0.25,0) node[scale=0.75,anchor=east]{\t};
}
\node[or gate,inputs={normal,normal,normal,normal,normal}] (O4) at (4,0) {};
\draw (O4.output) -- ++(0.25,0) node[scale=0.75,anchor=west]{$X\geq 2^k$};
\node[nand gate,inputs={normal,normal,normal,normal,normal}] (O5) at (4,-1.5) {};
\draw (O5.output) -- ++(0.25,0) node[scale=0.75,anchor=west]{$X<2^n-2^k$};
\draw (O5.output |- 0,-3) -- (O5.input 1 |- 0,-3);
\draw (O5.input 1 |- 0,-3) -- ++(-0.25,0) node[scale=0.75,anchor=east]{$x_0$};
\draw (O5.output |- 0,-3) -- ++(0.25,0) node[scale=0.75,anchor=west]{$\mbox{oneven}\left(X\right)$};
\foreach \x/\t in {5/$x_k$,4/$x_{k+1}$,3/$x_{k+2}$,2/$\ldots$,1/$x_{n-1}$} {
  \draw (O4.input \x) -- ++(-0.25,0) node[scale=0.75,anchor=east]{\t};
  \draw (O5.input \x) -- ++(-0.25,0) node[scale=0.75,anchor=east]{\t};
}
\end{tikzpicture}
\figlab{comparatorConstants}}
\caption{Speciale gevallen van vergelijkers}
\end{figure}
\paragraph{Vergelijken met constanten}
We willen een getal niet altijd vergelijken met andere getal, maar soms met een constante. In dat geval zouden we natuurlijk ook van de vergelijker kunnen gebruikmaken, en de $Y$ zelf samenstellen. Aangezien $Y$ echter op voorhand gekend is spreekt het voor zichzelf dat we de implementatie echter grondig kunnen verbeteren. Bovendien kunnen we ook testen ontwerpen die we niet kunnen uitvoeren met een vergelijker\footnote{Bijvoorbeeld deelbaarheid door 2.}. Dergelijke componenten bouwen getuigt verder ook van enig inzicht. Alle speciale gevallen beschouwen is moeilijk. Op figuur \ref{fig:comparatorConstants} geven we enkele voorbeelden.
\subsection{Schuifoperator}
\ssclab{shiftoperators}
\label{ss:shiftoperators}
Een laatste set van operaties die vaak gebruikt wordt zijn \termen{schuifoperaties}. Vele processoren implementeren schuifoperaties en bijvoorbeeld de ARM processor laat toe om tijdens elke operatie de operand over enkele plaatsen te schuiven. Een eerste probleem met schuifoperaties is dat er verschillende vormen van schuifoperaties bestaan. In het algemeen houdt een schuifoperatie in dat de waarde van de bit die eerst op plaats $i$ stond, nu op een plaats $i+m$ staat. Of formeler: $Y$ is het resultaat van een schuifoperatie van $X$ over $m$ plaatsen naar links als
\begin{equation}
\forall i\in\NN:i\in\left[0,n\right]\wedge i+m\in\left[0,n\right]\Rightarrow y_{i+m}=x_i
\end{equation}
Het probleem is wat we doen met de bits die buiten de grenzen vallen, en met wat we de nieuwe plaatsen opvullen. Voor dit probleem bestaan drie populaire oplossingen:
\begin{itemize}
 \item Bij het \termen{schuiven} negeren we de bits die buiten de grenzen vallen. Er bestaan twee vormen van schuiven die vari\"eren in wat we op de vrijgekomen plaatsen zetten:
 \begin{itemize}
   \item \termen{Logisch schuiven}: indien we logisch schuiven hebben we een extra parameter nodig, namelijk welke waarde we op de nieuwe plaatsen zetten. Soms is dit zelfs een rij van bits. We maken dus de invoer groot genoeg om geen vrije plaatsen meer over te houden.
   \item \termen{Aritmetisch schuiven}: hierbij willen we eigenlijk een wiskundige functie realiseren namelijk vermenigvuldigen of delen met een macht van 2. Hoe we dus aritmetisch schuiven hangt vooral af van de getalvoorstelling. Indien we naar links schuiven betekent dit meestal dat we de nieuwe plaatsen vullen met nullen. Indien we naar rechts schuiven zal bij een 2-complement voorstelling de hoogste bit (MSB) van het originele getal ingevoegd worden. Bij een ``unsigned'' voorstelling vullen we de vrije plaatsen ook met nullen op. Aritmetisch schuiven is vrij populair in programmeertalen. Talen die behoren tot de \verb|C/C++/C#/Java| familie introduceren daarom 2 functies: voor links (\verb+<<+) en rechts (\verb+>>+) aritmetisch schuiven deze worden gedefinieerd als:
\begin{equation}
\left\{\begin{array}{l}
X\verb+<<+M\equiv X\times 2^M\\
X\verb+>>+M\equiv X\div 2^M
\end{array}\right.
\end{equation}
 \end{itemize}
 \item Bij het \termen{roteren} vangen we de bits op die er langs \'e\'en kant afvallen en plaatsen we deze op de vrijgekomen plaatsen aan de andere kant.
\end{itemize}
\subsubsection{Implementatie van schuifoperaties}
In deze subsubsectie zullen we twee schakelingen realiseren. De eerste is een component die alle schuifoperaties kan realiseren op 4-bit getallen, maar slechts over 1 plaats naar links of rechts. Het tweede component is 8-bit \termen{barrel left rotator}. Dit component roteert 8-bit getallen naar links over een variabel aantal plaatsen. Merk op dat het bij een rotatie het eigenlijk niet uitmaakt in welke richting we roteren: een $n$-bit getal $m$ plaatsen naar links roteren is net hetzelfde als het getal $n-m$ plaatsen naar rechts roteren. Deze tweede component illustreert verder hoe we schuifoperaties effici\"ent over meerdere posities kunnen uitvoeren.
\paragraph{Schuifoperaties over 1 bit}
Indien we een component maken die meerdere operaties kan uitvoeren moeten we altijd eerst een instructieset defini\"eren, zoals in subsubsectie \ref{sss:aLUInstructionSet}. De instructieset dient zowel een onderscheid te maken tussen schuiven of roteren, aritmetisch of logisch\footnote{Enkel in geval van schuiven is dit relevant.} en links of rechts. Verder willen we ook een bit voorzien die aangeeft of er \"uberhaupt een schuifoperatie moet worden uitgevoerd. We zullen dus een 4-bit instructieset gebruiken. Tabel \ref{tbl:shiftInstructionSet} toont de betekenis van elke bit.
\begin{table}[hbt]
\centering
\begin{tabular}{c|cc}
Signaal&0&1\\\hline
$s_3$&geen schuifoperatie&schuifoperatie\\
$s_2$&links&rechts\\
$s_1$&schuiven&roteren\\
$s_0$&aritmetisch&logisch
\end{tabular}
\caption{Instructieset voor de schuifoperaties over 1 bit.}
\tbllab{shiftInstructionSet}
\end{table}
Op basis van deze instructieset kunnen we nu een component bouwen. Voor de berekening van de uitgangsbits gebruiken we multiplexers. Immers kan elke uitgang $y_i$ maar drie mogelijke uitgangen hebben: $x_{i-1}$, $x_i$ en $x_{i+1}$. Bij de uitgangen aan de rand dienen we alleen een andere interpretatie voor sommige $x_j$ te vinden. Welke van deze drie ingangen we kiezen hangt verder alleen af van twee bits uit het instructiewoord: $s_3$ en $s_2$. In het geval dat $s_3=0$ geldt $y_i=x_i$. Bijgevolg zetten we $x_i$ zowel op de $d_0$ en $d_1$ ingang van de multiplexer voor $y_i$. Indien $s_3=1$ en $s_2=0$ schuiven we naar links. We zetten dus $x_{i+1}$ en $x_{i-1}$ respectievelijk op de $d_2$ en $d_3$ ingangen. Vervolgens dienen we nog de randgevallen op te lossen. Deze randgevallen beslaan enkel $x_{i+1}$ voor $y_3$ en  $x_{i-1}$ voor $y_0$. Deze waarden zullen we respectievelijk noteren als $x_4$ en $x_{-1}$ en vallen dus buiten de grenzen van de ingangen. In geval van rotatie geldt:
\begin{equation}
\begin{array}{ll}
\left\{\begin{array}{l}
x_{-1}=x_3\\
x_4=x_0
\end{array}\right.&\mbox{(rotatie)}
\end{array}
\end{equation}
Dit dwingen we af met twee 2-naar-1 multiplexers. Deze multiplexers hebben als schakelelement instructiebit $s_1$. We dienen nu enkel nog het geval te behandelen waarin we schuiven. Indien we logisch schuiven, schuiven we de bits $L_{\mbox{\tiny{in}}}$ en $R_{\mbox{\tiny{in}}}$ in. Bij arithmetisch zullen we aan de rechterzijde een 0 inschuiven. Aan de linkerkant is dit ook het geval tenzij we schuiven met een 2-complement voorstelling. In dat laatste geval bepaalt de hoogste bit immers ook het teken van het getal. In dat geval moeten we de waarde van de hoogste bit dus nogmaals inschuiven. We kunnen bovenstaande beschrijvingen formaliseren tot volgende formules:
\begin{equation}
\begin{array}{ll}
\left\{\begin{array}{l}
x_{-1}=R_{\mbox{\tiny{in}}}\\
x_4=L_{\mbox{\tiny{in}}}
\end{array}\right.&\mbox{(schuiven, aritmetisch)}\\\\\left\{\begin{array}{l}
x_{-1}=0\\
x_4=0
\end{array}\right.&\mbox{(schuiven, logisch, unsigned)}\\\\\left\{\begin{array}{l}
x_{-1}=0\\
x_4=x_3
\end{array}\right.&\mbox{(schuiven, logisch, 2-complement)}
\end{array}
\end{equation}
Deze logica kunnen we vervolgens implementeren met OR-AND-poorten. Het resultaat van deze volledige implementatie staat op figuur \ref{fig:shiftImplementation}.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[circuit logic US]
\def\xxi{4};
\foreach \x in {0,...,3} {
  \node[mux4to1] (M\x) at (-2*\x,0) {};
  \draw (M\x.output) -- ++(0,-0.25) node[scale=0.75,anchor=north]{$y_{\x}$};
  \draw (M\x.data1) |- (M\x.data0 |- 0,0.5);
  \pdot{M\x.data0 |- 0,0.5};
  \draw (M\x.data0) -- (M\x.data0 |- 0,\xxi) node[scale=0.75,anchor=south]{$x_{\x}$};
}
\node[mux2to1] (MR) at (1.5,1.5) {};
\node[mux2to1] (ML) at (-7,1.5) {};
\draw (ML.selout0) -- (MR.selin0);
\draw (ML.selin0) -- (-8.5,0 |- ML.selin0) node[scale=0.75,anchor=east]{$s_1$};
\draw (M3.selin0) -- (-8.5,0 |- M3.selin0) node[scale=0.75,anchor=east]{$s_2$};
\draw (M3.selin1) -- (-8.5,0 |- M3.selin1) node[scale=0.75,anchor=east]{$s_3$};
\foreach \x/\y/\z in {0/1/1,1/2/0,2/3/1} {
  \draw (M\x.selin0) -- (M\y.selout0);
  \draw (M\x.selin1) -- (M\y.selout1);
  \draw (M\y.data0 |- 0,0.75) -| (M\x.data2);
  \pdot{M\y.data0 |- 0,0.75};
  \draw (M\x.data0 |- 0,1+0.25*\z) -| (M\y.data3);
  \pdot{M\x.data0 |- 0,1+0.25*\z};
}
\draw (ML.output) -- (ML.output |- 0,1) -| (M3.data2);
\draw (MR.output) -- (MR.output |- 0,1) -| (M0.data3);
\draw (ML.data1) |- (M0.data0 |- 0,1.75);
\pdot{M0.data0 |- 0,1.75};
\draw (MR.data1) |- (M3.data0 |- 0,2);
\pdot{M3.data0 |- 0,2};
\node[and gate,rotate=-90,anchor=output,scale=0.75] (AR) at (MR.data0 |- 0,2) {};
\draw (AR.output) -- (MR.data0);
\draw (AR.input 1) -- (AR.input 1 |- 0,\xxi) node[anchor=south,scale=0.75]{$R_{\mbox{\tiny{in}}}$};
\node[or gate,rotate=-90,anchor=output,scale=0.75] (OL) at (ML.data0 |- 0,1.875) {};
\draw (OL.output) -- (ML.data0);
\node[and gate,rotate=-90,anchor=north,scale=0.75] (ALa) at (OL.input 2 |- 0,3.1) {};
\node[and gate,rotate=-90,inputs={normal,normal,inverted},anchor=south,scale=0.75] (ALb) at (OL.input 1 |- 0,3.1) {};
\draw (ALa.output) -- ++(0,-0.125) -| (OL.input 2);
\draw (ALb.output) -- ++(0,-0.125) -| (OL.input 1);
\draw (ALa.input 2) |- (AR.input 2 |- 0,3.75) -- (AR.input 2);
\draw (ALa.input 2 |- 0,3.75) -- (-8.5,3.75) node[scale=0.75,anchor=east]{$s_0$};
\pdot{ALa.input 2 |- 0,3.75};
\draw (ALb.input 3 |- 0,3.75) -- (ALb.input 3);
\pdot{ALb.input 3 |- 0,3.75};
\draw (ALb.input 1) |- (M3.data0 |- 0,3.5);
\pdot{M3.data0 |- 0,3.5};
\draw (ALa.input 1) -- (ALa.input 1 |- 0,\xxi) node[anchor=south,scale=0.75]{$L_{\mbox{\tiny{in}}}$};
\draw (ALb.input 2) -- (ALb.input 2 |- 0,\xxi) node[anchor=west,scale=0.75,rotate=90]{2-comp};
\end{tikzpicture}
\caption{Implementatie van een schuifoperator over 1 bit.}
\figlab{shiftImplementation}
\end{figure}
\paragraph{8-bit barrel left rotator}
In de vorige paragraaf hebben we een schuifoperator gebouwd die 1-bit kan schuiven. Door verschillende van deze schuifoperatoren na elkaar te plaatsen kunnen we schuiven over meerdere plaatsen. Toch is dit niet erg praktisch: om $m$ plaatsen te schuiven zouden we $m$ van deze schuifoperatoren na elkaar moeten plaatsen, wat grote vertragingen zou impliceren. In deze paragraaf zullen we een rotator bouwen die de vertraging beperkt tot $\log_2 m$, met $m$ het maximaal aantal plaatsen dat kan opgeschoven worden. Het concept is echter ook toepasbaar op algemene schuifoperaties. Alleen is de implementatie te complex voor pedagogische doeleinden. Figuur \ref{fig:hBitBarrelLeftRotatorImplementation} geeft het concept mooi weer.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\foreach \y in {0,1,2} {
  \foreach \x in {0,...,7} {
    \node[mux2to1] (M\y\x) at (-1.5*\x,1.5*\y) {};
  }
  \foreach \a/\b in {0/1,1/2,2/3,3/4,4/5,5/6,6/7} {
   \draw (M\y\b.selout0) -- (M\y\a.selin0);
  }
  \draw (M\y7.selin0) -- (M\y7.selin0 -| -11.5,0) node[scale=0.75,anchor=east]{$s_{\y}$};
}
\foreach \y/\yi in {0/1,1/2} {
  \foreach \x in {0,...,7} {
    \draw (M\yi\x.output) -- (M\y\x.data0);
    \pdot{$(M\yi\x.output)!0.25!(M\y\x.data0)$};
  }
}
\foreach \x/\xa/\xb/\xc in {0/4/2/1,1/5/3/2,2/6/4/3,3/7/5/4,4/0/6/5,5/1/7/6,6/2/0/7,7/3/1/0} {
  \draw (M2\x.data0) -- (M2\x.data0 |- 0,4.5) node[scale=0.75,anchor=south]{$x_{\x}$};
  \pdot{M2\x.data0 |- 0,4.25};
  \draw (M0\x.output) -- (M0\x.output |- 0,-0.5) node[scale=0.75,anchor=north]{$y_{\x}$};
  \draw (M2\x.data0 |- 0,4.25) -- (M2\xa.data1);
  \draw ($(M2\x.output)!0.25!(M1\x.data0)$) -- (M1\xb.data1);
  \draw ($(M1\x.output)!0.25!(M0\x.data0)$) -- (M0\xc.data1);
}
\end{tikzpicture}
\caption{Implementatie van een 8-bit barrel left rotator.}
\figlab{hBitBarrelLeftRotatorImplementation}
\end{figure}
Deze barrel left rotator is gebaseerd op het additief principe. Het additief principe stelt dat indien we een getal willen schuiven of roteren over $m$ bits, we dit ook kunnen verwezenlijken door eerst te schuiven/roteren over $m_1$ bits en vervolgens over $m_2$ bits met $m=m_1+m_2$. Indien we onze rotator bouwen volgens een structuur waarbij elke niveau $i$ een rotatie uitvoert over $2^i$ plaatsen kunnen we elke rotatie-operatie uitvoeren. Op figuur \ref{fig:hBitBarrelLeftRotatorImplementation} zien we dat het niveau $s_2$, vier plaatsen naar links roteert. Het volgende niveau twee en het laatste \'e\'en. Elk van deze niveaus heeft dezelfde vertraging. Indien we dus een $n$-bit barrel left rotator willen bouwen die maximaal $m$ plaatsen kan opschuiven moeten we dus $\left\lceil\log_2m\right\rceil$ niveaus synthetiseren. Een niveau $i$ roteert $2^i$ plaatsen voor $\forall i=0,1,\ldots,\left\lceil\log_2m\right\rceil-1$. Dit concept is eenvoudig te veralgemenen naar een volledige schuifoperator. Merk op dat het aantal niveaus dus theoretisch niet afhangt van het aantal bit in het getal. Op de meeste processoren neemt men echter $m=n$. Een andere mooie eigenschap is dat de volgorde van de niveaus niet relevant is.