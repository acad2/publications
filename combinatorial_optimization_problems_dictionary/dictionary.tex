\documentclass{../SharedData/dictionaryclass}
\usepackage{xcolor,../SharedData/brackets}
\title{Combinatorial Optimization Problems Dictionary}
\author{Willem Van Onsem\\\href{mailto:Willem.VanOnsem@cs.kuleuven.be}{Willem.VanOnsem@cs.kuleuven.be}}
\date{KU Leuven\\Department of Computer Science\\Celestijnenlaan 200A, 3001 Heverlee, Belgium\\2013-201.}
\hypersetup{pdftitle={Combinatorial Optimization Problems Dictionary},pdfauthor={Willem Van Onsem (Willem.VanOnsem@cs.kuleuven.be)}, pdfsubject={Combinatorial Optimization Problem}, pdfkeywords={Combinatorial, Optimization, Problem, Heuristics}, linktoc=none}

\definecolor{frml-bg}{RGB}{255,247,220}
\definecolor{frml-fg}{RGB}{224,220,191}

\newcommand{\nmn}[1]{\index{#1}\emph{#1}}
\newcommand{\nmns}[1]{\index{#1}\emph{#1s}}
\newcommand{\frml}[1]{\begin{quote}\fcolorbox{frml-fg}{frml-bg}{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textit{formal}\\#1}}\end{quote}}
\newcommand{\fcop}[3][maximize]{\begin{eqnarray}\mbox{#1}&&#2,\\\mbox{subject to}&&#3\end{eqnarray}}
\newcommand{\ccnpcomplete}{\textsc{NP-Complete}}
\newcommand{\ccnphard}{\textsc{NP-Hard}}
\newcommand{\ccp}{\textsc{P}}

\dey[maximum satisfiability]{Maximum satisfiability}{In the maximum satisfiability problem, one is given a set of boolean functions $\phi_1,\phi_2,\ldots,\phi_n$ defined on the set of boolean variables
 $x_1,x_2,\ldots,x_n$. One aims to find the boolean configuration $\vec{x}$ such that the maximum number of boolean functions is satisfied.}

 \dey[knapsack]{Knapsack}{The knapsack problem is a group of different problems. In each problem, one is given a sequence of items $x_i$. Each item has one or more weights $w_i$ and some kind of utility value\footnote{Sometimes this value depends on other objects in the bag.} $v_i$. The objective is to generate a bag of objects such that the total utility is maximized under one or more weight bounds $W$. The number of weight constraints is called the \nmn{dimension} of the problem. The most standard \todef{} problem is the so called \rey{0-1 knapsack} problem. The \todef{} problem can be solved using dynamic programming in pseudo-polynomial time, it is therefore sometimes used as a subroutine for a more complex optimization problem. All \todef{} problems are \ccnphard{}. The \todef{} problem is however considered to be an easy problem in the family of \ccnphard{} problems because there exists a \nmn{dynamic programming} approach to solve most problems in \nmn{pseudo-polynomial} time.}[0-1 knapsack,bounded knapsack,unbounded knapsack,multiple-choice knapsack]
\
dey[0-1 knapsack]{0-1 knapsack}{A special form of the \rey{knapsack} problem. In this variant, a bag contains zero or one instances of every item, in other words no copies of the specified items are allowed.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\accl{0,1}}}}[subset-sum]

\dey[bounded knapsack]{Bounded knapsack}{A special case of the \rey{knapsack} problem. In this variant, each item $x_i$ can has a bounded number of instances (specified by $c_i$).\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\accl{0,1,\ldots,c_i}}}}

\dey[unbounded knapsack]{Unbounded knapsack}{A special case of the \rey{knapsack} problem. In this variant each item $x_i$ can have an unlimited number of instances in the bag.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\NNN}}}

\dey[multiple-choice knapsack]{Multiple-choice knapsack}{A special case of the \rey{knapsack} problem where items are chosen from disjoint classes. From each class only one item can be selected.\frml{\fcop{\sumieqb[i]{1}{n}{\sumdomain[j]{N_i}{v_{i\;j}\cdot x_{i\;j}}}}{\sumieqb[i]{1}{n}{\sumdomain[j]{N_i}{w_{i\;j}\cdot x_{i\;j}}}\leq W\\&&\sumdomain[j]{N_i}{x_{i\;j}}=1\\&&x_{i\;j}\in\accl{0,1}}}}

\dey[multiple knapsack]{Multiple knapsack}{A special case of the \rey{knapsack} problem where several knapsacks are filled simultaneously based on the same set of items. An item can thus assigned to maximum one knapsack. It is possible that the knapsacks have different weight limits. The objective is to maximize the total utility value in all the knapsacks together.\frml{\fcop{\sumieqb[i]{1}{m}{\sumieqb[j]{1}{n}{p_{j}\cdot x_{i\;j}}}}{\sumieqb[j]{1}{n}{w_{j}\cdot x_{i\;j}}\leq W_i\\&&\sumieqb[i]{1}{m}{x_{i\;j}}\leq1\\&&x_{i\;j}\in\accl{0,1}}}}

\dey[multi-constrained knapsack]{Multi-constrained knapsack}{A special case of the \rey{knapsack} problem where each item has weights $w_{i\;j}$ of several flavors $j$ and for each of these flavors $j$ there is a weight bound $W_j$. The \todef{} problem has the same representation power of a \rey{integer linear} problem with positive coefficients. This problem is the most general \rey{knapsack} problem.\frml{\fcop{\sumieqb[i]{1}{n}{p_i\cdot x_i}}{\sumieqb[j]{1}{n}{w_{i\;j}\cdot x_{j}}\leq W_i\\&&x_{i}\in\NNN}}}

\dey[bin-packing]{Bin-packing}{In the \todef{} problem, one is given a set of items $i$ each with a specific size $l_i$. The objects must be organized in a number of equally sized bins with size $L$. Items belong atomically to one bin: they can't be split over the several bins.\frml{\fcop[minimize]{\sumieqb[i]{1}{n}{y_i}}{\sumieqb[j]{1}{n}{l_i\cdot x_{i\,j}}\leq L\cdot y_i\\&&\sumieqb[i]{1}{n}{x_{i\,j}}=1\\&&y_i\in\accl{0,1}\\&&x_{i\,j}\in\accl{0,1}}}}

\dey[job shop scheduling]{Job shop scheduling}{In the \todef{} problem, one is given a list of tasks that must be performed...}

\dey[subset-sum]{Subset-sum}{One is given a number of integers $w_i$, the aim is to determine a subset of the given integers such that the sum is maximum but less than or equal to a given bound $W$.\frml{\fcop{\sumieqb[i]{1}{n}{w_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\accl{0,1}}}The problem is strongly connected to the \rey{0-1 knapsack} problem where the utility value $v_i$ and the weights $w_i$ of each item are equal.}[0-1 knapsack]

\dey[change-making]{Change-making}{One is given a number of \mnm{coin value} $c_i$ and one must calculate a bag of such coins such that the sum is equal to a given amount of money $C$ such that the total number of \mnms{coin} is minimized.\frml{\fcop[minimize]{\sumieqb[i]{1}{n}{\cdot x_i}}{\sumieqb[i]{1}{n}{c_i\cdot x_i}=C\\&&x_i\in\NNN}}The problem can be seen as a minimization variant of the \rey{unbounded knapsack} problem with an equality for the capacity bound.}[unbounded knapsack]

\dey[integer linear programming]{Integer linear programming}{In the \todef{} problem, one is given a matrix $A$ and two vectors $\vec{b}$ and $\vec{c}$. The aim is to find an optimal integer values for a vector of variables $\vec{x}$ such that the dot-product of $\vec{x}$ and $\vec{c}$ is maximized and the product of $A$ and $\vec{x}$ is element-wise less than or equal to $\vec{b}$.\frml{\fcop{\vec{c}\cdot\vec{x}}{A\cdot\vec{x}\leq\vec{b}\\&&\vec{x}\in\NNN^n}}The \todef{} problem is proven to be \nphard{} although there exist solvers that solve most instances efficiently. Several combinatorial optimization problems are subsets of the \todef{} problem like the \rey{knapsack} problem.}

\begin{document}
\clearpage\lettergroup{1}\dictchar{Introduction}
In this dictionary, we document several combinatorial optimization problems.
\section*{Approaches}
Several approaches have been developed to solve a combinatorial optimization problem exactly, regardless of the ``shape of the problem''. Some other techniques can only be applied to cases where the problem itself meets certain criteria. We enumerate the most popular approaches to solve combinatorial optimization problems exactly:
\begin{description}
 \item [Brute force] a brute force algorithm enumerates the entire configuration space by assigning every value of the domain to the respective variable. Such approach always results in computation time exponential in the number of variables. The approach is not efficient at all since in most cases -- based on a partial assignment -- one can decide if potential good solutions can be derived from such assignment.
 \item [Branch-and-bound] In case of a branch-and-bound algorithm, one enumerate the configuration space as well, but one uses a \nmn{bound}: a value for the fitness of the thus far best solution found.
 \item [Dynamic programming]
 \item [State space relaxation]
 \item [Preprocessing]
\end{description}
\section*{Computational complexity}
\glsaddall
\printglossaries
\clearpage\lettergroup{@}\dictchar{Appendix}
\section*{Mathematics}
In this section we will describe mathematical structures used in the corpus of this dictionary.
\begin{description}
 \item [Bag] A collection of items such that each item can occur zero, one or more times. A bag has no inherent order: there is no $i$-th item in a bag. A bag is sometimes called a \nmn{multiset}.
 \item [Set] A collection of items. Each item can belong or not belong to a set. Multiple occurrences are not allowed. A set has no inherent order.
 \item [List] A collection of items such that each item can occur zero, one or more times. A list has an inherent order: given that a list $L$ contains $n$ items, an item $l_i$ is called the $i$-th item of the list. A list is sometimes called a \nmn{vector} or \nmn{tuple}.
\end{description}

\end{document}