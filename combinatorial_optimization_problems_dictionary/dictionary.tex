\documentclass{../SharedData/dictionaryclass}
\usepackage{xcolor,../SharedData/brackets}
\title{Combinatorial Optimization Problems Dictionary}
\author{Willem Van Onsem\\\href{mailto:Willem.VanOnsem@cs.kuleuven.be}{Willem.VanOnsem@cs.kuleuven.be}\and Bart Demoen\and Patrick De Causmaecker}
\date{KU Leuven\\Department of Computer Science\\Celestijnenlaan 200A, 3001 Heverlee, Belgium\\2013-201.}
\hypersetup{pdftitle={Combinatorial Optimization Problems Dictionary},pdfauthor={Willem Van Onsem (Willem.VanOnsem@cs.kuleuven.be), Bart Demoen, Patrick De Causmaecker}, pdfsubject={Combinatorial Optimization Problems}, pdfkeywords={Combinatorial, Optimization, Problem, Heuristics}, linktoc=none}

\definecolor{frml-bg}{RGB}{255,247,220}
\definecolor{frml-fg}{RGB}{224,220,191}
\definecolor{frml-tx}{RGB}{119,119,119}

\setlength{\abovedisplayshortskip}{-.5\baselineskip plus 3pt}% Original value: 0pt plus 3pt

\newcommand{\nmn}[1]{\index{#1}\emph{#1}}
\newcommand{\nmns}[1]{\index{#1}\emph{#1s}}
\newcommand{\frml}[1]{\begin{quote}\fcolorbox{frml-fg}{frml-bg}{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textcolor{frml-tx}{\textit{formal}}\\#1}}\end{quote}}
\newcommand{\fcopm}{}
\newcommand{\fcop}[3][+]{\ifthenelse{\equal{#1}{+}}{\renewcommand{\fcopm}{maximize}}{\renewcommand{\fcopm}{minimize}}\[\begin{array}{lll}\mbox{\fcopm{}}&#2,\\\mbox{subject to}&#3\end{array}\]}
\newcommand{\ccnpcomplete}{\textsc{NP-Complete}}
\newcommand{\ccnphard}{\textsc{NP-Hard}}
\newcommand{\ccp}{\textsc{P}}

\dey[maximum satisfiability]{Maximum satisfiability}{In the maximum satisfiability problem, one is given a set of boolean functions $\phi_1,\phi_2,\ldots,\phi_n$ defined on the set of boolean variables
 $x_1,x_2,\ldots,x_n$. One aims to find the boolean configuration $\vec{x}$ such that the maximum number of boolean functions is satisfied.}

 \dey[knapsack]{Knapsack}{The knapsack problem is a group of different problems. In each problem, one is given a sequence of items $x_i$. Each item has one or more weights $w_i$ and some kind of utility value\footnote{Sometimes this value depends on other objects in the bag.} $v_i$. The objective is to generate a bag of objects such that the total utility is maximized under one or more weight bounds $W$. The number of weight constraints is called the \nmn{dimension} of the problem. The most standard \todef{} problem is the so called \rey{0-1 knapsack} problem. The \todef{} problem can be solved using dynamic programming in pseudo-polynomial time, it is therefore sometimes used as a subroutine for a more complex optimization problem. All \todef{} problems are \ccnphard{}. The \todef{} problem is however considered to be an easy problem in the family of \ccnphard{} problems because there exists a \nmn{dynamic programming} approach to solve problems in \nmn{pseudo-polynomial} time. In nearly all subproblems an important factor to measure the hardness of a problem instance is the correlation of the \nmn{utility-to-weight} ratio. If there is a strong correlation between the items, the problem is hard. This is because it is harder to distinguish useful items from less useful ones and .}[0-1 knapsack,bounded knapsack,unbounded knapsack,multiple-choice knapsack]

\dey[0-1 knapsack]{0-1 knapsack}{A special form of the \rey{knapsack} problem. In this variant, a bag contains zero or one instances of every item, in other words no copies of the specified items are allowed.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\accl{0,1}}}The \todef{} has many practical applications in the financial sector, for instance investing in a number of projects where each project has a return-of-investment and a cost and only a limited budget is available.}[subset-sum]

\dey[bounded knapsack]{Bounded knapsack}{A special case of the \rey{knapsack} problem. In this variant, each item $x_i$ can has a bounded number of instances (specified by $c_i$).\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\accl{0,1,\ldots,c_i}}}}

\dey[unbounded knapsack]{Unbounded knapsack}{A special case of the \rey{knapsack} problem. In this variant each item $x_i$ can have an unlimited number of instances in the bag.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\NNN}}}

\dey[multiple-choice knapsack]{Multiple-choice knapsack}{A special case of the \rey{knapsack} problem where items are chosen from disjoint classes. From each class only one item can be selected.\frml{\fcop{\sumieqb[i]{1}{n}{\sumdomain[j]{N_i}{v_{i\;j}\cdot x_{i\;j}}}}{\sumieqb[i]{1}{n}{\sumdomain[j]{N_i}{w_{i\;j}\cdot x_{i\;j}}}\leq W\\&\sumdomain[j]{N_i}{x_{i\;j}}=1\\&x_{i\;j}\in\accl{0,1}}}}

\dey[multiple knapsack]{Multiple knapsack}{A special case of the \rey{knapsack} problem where several knapsacks are filled simultaneously based on the same set of items. An item can thus assigned to maximum one knapsack. It is possible that the knapsacks have different weight limits. The objective is to maximize the total utility value in all the knapsacks together.\frml{\fcop{\sumieqb[i]{1}{m}{\sumieqb[j]{1}{n}{p_{j}\cdot x_{i\;j}}}}{\sumieqb[j]{1}{n}{w_{j}\cdot x_{i\;j}}\leq W_i\\&\sumieqb[i]{1}{m}{x_{i\;j}}\leq1\\&x_{i\;j}\in\accl{0,1}}}}

\dey[multi-constrained knapsack]{Multi-constrained knapsack}{A special case of the \rey{knapsack} problem where each item has weights $w_{i\;j}$ of several flavors $j$ and for each of these flavors $j$ there is a weight bound $W_j$. The \todef{} problem has the same representation power of a \rey{integer linear programming} problem with positive coefficients. This problem is the most general \rey{knapsack} problem.\frml{\fcop{\sumieqb[i]{1}{n}{p_i\cdot x_i}}{\sumieqb[j]{1}{n}{w_{i\;j}\cdot x_{j}}\leq W_i\\&x_{i}\in\NNN}}}

\dey[bin-packing]{Bin-packing}{In the \todef{} problem, one is given a set of items $i$ each with a specific size $l_i$. The objects must be organized in a number of equally sized bins with size $L$. Items belong atomically to one bin: they can't be split over the several bins.\frml{\fcop[-]{\sumieqb[i]{1}{n}{y_i}}{\sumieqb[j]{1}{n}{l_i\cdot x_{i\,j}}\leq L\cdot y_i\\&\sumieqb[i]{1}{n}{x_{i\,j}}=1\\&y_i\in\accl{0,1}\\&x_{i\,j}\in\accl{0,1}}}}

\dey[job shop scheduling]{Job shop scheduling}{In the \todef{} problem, one is given a list of tasks that must be performed...}

\dey[subset-sum]{Subset-sum}{One is given a number of integers $w_i$, the aim is to determine a subset of the given integers such that the sum is maximum but less than or equal to a given bound $W$.\frml{\fcop{\sumieqb[i]{1}{n}{w_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\accl{0,1}}}The problem is strongly connected to the \rey{0-1 knapsack} problem where the utility value $v_i$ and the weights $w_i$ of each item are equal.}[0-1 knapsack]

\dey[change-making]{Change-making}{One is given a number of \nmn{coin value} $c_i$ and one must calculate a bag of such coins such that the sum is equal to a given amount of money $C$ such that the total number of \nmns{coin} is minimized.\frml{\fcop[-]{\sumieqb[i]{1}{n}{\cdot x_i}}{\sumieqb[i]{1}{n}{c_i\cdot x_i}=C\\&x_i\in\NNN}}The problem can be seen as a minimization variant of the \rey{unbounded knapsack} problem with an equality for the capacity bound.}[unbounded knapsack]

\dey[integer linear programming]{Integer linear programming}{In the \todef{} problem, one is given a matrix $A$ and two vectors $\vec{b}$ and $\vec{c}$. The aim is to find an optimal integer values for a vector of variables $\vec{x}$ such that the dot-product of $\vec{x}$ and $\vec{c}$ is maximized and the product of $A$ and $\vec{x}$ is element-wise less than or equal to $\vec{b}$.\frml{\fcop{\vec{c}\cdot\vec{x}}{A\cdot\vec{x}\leq\vec{b}\\&\vec{x}\in\NNN^n}}The \todef{} problem is proven to be \ccnphard{} although there exist solvers that solve most instances efficiently. Several combinatorial optimization problems are subsets of the \todef{} problem like the \rey{knapsack} problem.}

\dey[set covering]{Set covering}{Given a set $S$ of $m$ items and $n$ subsets $S_i\in\calS$ of $S$ with for each subset $S_i$ an associated cost $c_i$. The objective is to choose a bag of subsets $S_i$ such that the union of the subsets contains all items in $S$ with minimized total cost.\frml{\fcop[-]{\sumieqb[i]{1}{n}{c_i\cdot x_i}}{\sumdomain[S_i]{\calS,j\in S_i}{x_i}\geq 1\\&x_i\in\accl{0,1}}}}

\dey[continuous 0-1 knapsack]{Continuous 0-1 knapsack}{The \todef{} problem is a special case of the \rey{0-1 knapsack} problem where it is allowed to add fractions of an item into the knapsack, as a result the variables have real values and the problem is a special case of a \rey{linear programming} problem, as a result it can be solved in \nmn{polynomial} time.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\fbrk{0,1}}}}

\dey[vertex-cover]{Vertex-cover}{The \todef{} problem is an optimization problem where given a \nmn{undirected graph}, one aims to find the \nmn{optimal vertex cover}: the \nmn{vertex cover} of minimum size.}

\dey[traveling salesman]{Traveling salesman}{One is given a \nmn{undirected graph} where the \nmns{edge} have a nonnegative integer cost, one aims to find a \nmn{Hamiltonian cycle} or \nmn{tour} of $G$ where the sum of the costs of the relevant edges in minimized. \frml{\fcop[-]{\sumieqb{1}{n}{\sumieqb[j]{1}{n}{c_{i\;j}\cdot x_{i\;j}}}}{\sumieqb{1}{n}{x_{i\;j}}=1&j\in\accl{1,2,\ldots,n}\\&\sumieqb[j]{1}{n}{x_{i\;j}}=1&i\in\accl{1,2,\ldots,n}\\&\sumdomain[i]{S}{\sumdomain[j]{S}{x_{i\;j}}}\leq\abs{S}-1&S\subseteq V:\abs{S}\geq 2\\&x_{i\;j}\in\accl{0,1}&i,j\in\accl{1,2,\ldots,n}}}}

\dey[p-center]{$p$-center}{The \todef{} is a discrete optimization location problem which consists of location $p$ centers out of $n$ sites and assigning the remaining $n-p$ sites to the centers such that the maximum distance between a site and the corresponding center is minimized.}

\dey[capacitated p-center]{Capacitated $p$-center}{The \todef{} is a special form of the \rey{p-center} problem where each site has a demand and a capacity and where the total demand of the sites assigned to to a center cannot exceed its capacity.}

\dey[traveling tournament]{Traveling tournament}{The \todef{} problem is a group of different problems. In each problem a tournament is organized between several teams. Teams have location and time constraints and the cost of the tournament should be minimized. A special subproblem is the \rey{traveling umpire} problem.}

\dey[traveling umpire]{Traveling umpire}{A specific \rey{traveling tournament} problem that is considered the academic version of the \rey{major league baseball umpire scheduling} problem. The objective is to find a double \nmn{round robin} schedule consisting out of $4\cdot n-2$ rounds in which each of the $2\cdot n$ teams play against exactly one team in every round at the home location of one of the opponents. The goal is to find a schedule which minimizes the distance traveled by the umpire crews, taking into account the following constraints:\begin{enumerate}\item Every game in the tournament is officiated by exactly one umpire;\item an umpire officiates exactly one game per round;\item every umpire should visit the home of every team at least once;\item an umpire must wait a predefined number of rounds before revisiting a team's home; and\item an umpire must wait a predefined number of rounds before officiating the same team again.\end{enumerate}}

\dey[shift minimization personnel task scheduling]{Shift minimization personnel task scheduling}{A \rey{scheduling} problem that deals with the problem of assigning tasks with fixed start and end times to a set of multi-skilled employees whose working times have been determined beforehand. The objective is to minimize the number of employees while assigning all tasks and respecting the qualification requirements and employee availabilities. Relaxing the qualifications requirements and restricting the scheduling horizon allows the problem to be solved in polynomial time using a \nmn{forward pass maximal clique algorithm}. When the working times are part of the assignment process as well, the problem is a \rey{task and shift scheduling} problem.}

\dey[task and shift scheduling]{Task and shift scheduling}{A \rey{scheduling} problem that deals with the problem of assigning tasks with fixed start and end times to a set of multi-skilled employees with variable working times. The objective is to minimize the number of employees while assigning all tasks and respecting the qualification requirements and employee availabilities. In case the working times are determined beforehand, the problem is a \rey{shift minimization personnel task scheduling} problem.}

\dey[dial-a-ride]{Dial-a-ride}{A family of problems concerned with the design of efficient vehicle routes for the transportation of individual persons from a specific origin to a specific destination. Some problems also take into account the presence of users with special requirements.}

\dey[water distribution network design]{Water distribution network design}{The objective is to find the optimal network configuration in terms of pipe diameters. One aims to minimize the investment cost while satisfying conservation of mass and energy and the minimum and maximum of the pressure.\frml{\fcop[-]{\sumdomain[p]{P}{\sumdomain[t]{T}{l_p\cdot c_t\cdot x_{p,t}}}}{x_{p,t}\in\accl{0,1}&p\in P,t\in T\\&y_{p}\in\accl{-1,1}&p\in P\\&\sumdomain[p]{l}{\displaystyle\frac{10.67\cdot y_p\cdot q_p^{1.852}}{\sumdomain[t]{T}{x_{p,t}\cdot c_t^{1.852}\cdot d_t^{4.871}}}}=0&l\in L\\&H_{n,\mbox{\small min}}\leq H_n\leq H_{n,\mbox{\small max}}&n\in N\\&\sumdomain[t]{T}{x_{p,t}}=1&p\in P}} Where:\begin{enumerate}\item $x_{p,t}$ denotes a binary decision variable that states that pipe $p$ is of type $t$;\item $c_{t}$ is the cost per meter of a pipe of type $t$;\item $q_{i,j}$ is the flow rate from node $i$ to $j$ (in \unmps[3]);\item $q_{p}$ is the water flow rate through pipe $p$ (in \unmps[3]);\item $r_t$ is the roughness coefficient of pipe type $t$;\item $H_{n,\mbox{\small min}}$ is the minimal pressure head in node $n$ (in \unm); \item $H_{n,\mbox{\small max}}$ is the maximal pressure head in node $n$ (in \unm); \item $P$ is the set of pipes; $T$ is the set of pipe types; \item $l_p$ is the length of pipe $p$ (in \unm); \item $d_n$ is the demand of node $n$ (in \unmps[3]); \item $s_n$ is the supply of node $n$ (in \unmps[3]); \item $H_n$ is the pressure head in node $n$ (in \unm);\item $N$ is the set of nodes; and \item $L$ is the set of loops.\end{enumerate}}

\dey[matching]{Matching}{Given a \nmn{graph} $G=\tupl{V,E}$, one aims to find the \nmn{matching} with the maximum number of \nmns{edge}.\frml{\fcop{\sumdomain[e]{E}{x_e}}{x_e\in\accl{0,1}&e\in E\\&\sumdomain[e]{\fun{\delta}{v}}{x_e}\leq 1&v\in V}} A variant of this problem is the \rey{weighted matching} problem.}

\dey[weighted matching]{Weighted matching}{A variant of the \rey{matching} problem where each edge $e$ is assigned a weight $w_e$. The objective is to find the \nmn{matching} with the maximum sum of the weights of the \nmns{edge}.}

\dey[node packing]{Node packing}{Given a \nmn{graph} $G=\tupl{V,E}$, one aims to find the largest set of \nmns{node} such that for each \nmn{edge} $e\in E$ at most one \nmn{node} is selected.\frml{\fcop{\sumdomain[v]{V}{x_v}}{x_v\in\accl{0,1}&v\in V\\&x_{v_1}+x_{v_2}\leq 1&\tupl{v_1,v_2}\in E}}.}

\dey[linear programming]{Linear programming}{A generic problem where one is given an $n\times m$-matrix $A$, an $m$-vector $\vec{b}$ and an $n$-vector $\vec{c}$, the aim is to find an $n$-vector of real variables $\vec{x}$ such that the dot-product with $\vec{c}$ is maximized given that the product of $A$ with $\vec{x}$ is element-wise less than or equal to $\vec{b}$.\frml{\fcop{\vec{c}\cdot\vec{x}}{A\cdot\vec{x}\leq\vec{b}\\&\vec{x}\in\RRR^n}}Strictly spoken the problem is not a combinatorial optimization problem since the set of real values is infinite. However floating points are represented discretized on a machine. The problem can be solved in \nmn{polynomial} time in the number of variables and the inverse precision $1/\epsilon$: a parameter that determines the maximum error on the solution.}

\dey[shortest path]{Shortest path}{Given a \nmn{directed graph} $G=\tupl{V,E}$ where the \nmns{edge} $E$ are labeled with numerical values, the objective is to find a path $\pi$ between two given vertices $v_1$ and $v_2$ such that the sum of the edges in $\pi$ is minimized. The problem can be solved in \nmn{polynomial} time using \nmn{Dijkstra's algorithm}.}

\dey[max flow]{Max flow}{Given a \nmn{graph} $G=\tupl{V,E}$ where the each edge $e$ is labeled with a numerical value indicating the maximum flow $m_e$ through that edge, the objective is to assign a flow $x_e$ to each edge such that the total flow from a given vertex called the \nmn{source} $v_s$ is maximized to a given vertex called the \nmn{drain} $v_d$. Evidently the total flow entering each vertex $v$ is equal to the total flow leaving that vertex (except for the source and the drain).\frml{\fcop{\sumdomain[e]{\fun{\delta}{v_s}}{x_e}}{-m_e\leq x_e\leq m_e&e\in E\\&\sumdomain[e]{\fun{\delta}{v}}{x_e}=0&v\in V\setminus\accl{v_s,v_d}}}The \todef{} problem can be solved in \nmn{polynomial} time.}

\dey[graph coloring]{Graph coloring}{Given a graph $G=\tupl{V,E}$ the objective is to assign a color $c_v$ to each node $v\in V$ such that for each edge $\tupl{v_i,v_j}\in E$, the two vertices have a different color and the total number of used colors is minimized. \todef{} has applications in compilers for register allocation. The problem is strongly related to the \rey{node packing} problem.}

\dey[spanning forest]{Spanning forest}{Given a \nmn{graph} $G=\tupl{V,E}$ the objective is to find a subgraph that is a \nmn{forest} such that the sum of the \nmn{weight} of the \nmns{edge} is maximized.\frml{
\fcop{\sumdomain[e]{E}{x_e\cdot w_e}}{\sumdomain[e]{\fun{\delta}{i}\cap\fun{\delta}{j},i,j\in W}{x_e}\leq\abs{V}-1&V\subseteq W:2\leq\abs{V}\leq\abs{W}\\&x_e\in\accl{0,1}&e\in E}}}

\dey[frequency assignment]{Frequency assignment}{A family of problems related to wireless communication. In all problems a set of \nmns{transmitter} is given and each of these transmitters must be given \nmn{bandwidth}. Transmitters close to each other in space and bandwidth interfere with each other resulting in communication problems. The objective of all problems is to minimize some flavor of inference.}[minimum order frequency assignment,minimum span frequency assignment,minimum blocking frequency assignment,minimum inference frequency assignment]

%TODO: problems to define
\dey[minimum order frequency assignment]{Minimum order frequency assignment}{Given an \nmn{undirected graph} $G=\tupl{V,E}$ of \nmns{transmitter} $V$ such that for each $v\in V$, $\tupl{v,v}\notin E$. Each of the transmitters $v$ is annotated with a set of possible bandwidths $D_v$. Each of the edges $\tupl{v,w}$ is annotated with a set of unacceptable inferences $T_{v\;w}$. The objective is to assign a set of bandwidths $f_v$ to each of the transmitters $v$ such that no two transmitters $\tupl{v,w}\in E$ have a bandwidth that differs with a unacceptable inference $T_{v\;w}$ and the total number of used bandwidth is minimized.\frml{\fcop[-]{\abs{\cupdomain[v]{V}{f_v}}}{\abs{f_v}\leq c_v&v\in V\\&f_v\subseteq D_v\\&\abs{f_{v\;i}-f_{w\;j}}\notin T_{v\;w}&\tupl{v,w}\in E,f_{v\;i}\in f_v,f_{w\;j}\in f_w}}}
\dey[minimum span frequency assignment]{Minimum span frequency assignment}{}
\dey[minimum blocking frequency assignment]{Minimum blocking frequency assignment}{}
\dey[minimum inference frequency assignment]{Minimum inference frequency assignment}{}
\dey[major league baseball umpire scheduling]{Major league baseball umpire scheduling}{}
\dey[collapsing knapsack]{Collapsing knapsack}{}
\dey[nested knapsack]{Nested knapsack}{}
\dey[nonlinear knapsack]{Nonlinear knapsack}{}
\dey[inverse-parametric knapsack]{Inverse-parametric knapsack}{}
\dey[generalized assignment knapsack]{Generalized assignment knapsack}{}
\dey[circle positioning]{Circle positioning}{}
\dey[scheduling]{Scheduling}{}

%alternatives
\aey[edge packing]{Edge packing}{matching}
\aey[independent set]{Independent set}{node packing}
\aey[stable set]{Stable set}{node packing}

\begin{document}
\clearpage\lettergroup{1}\dictchar{Introduction}
In this dictionary, we document several combinatorial optimization problems.
\section*{Exact algorithms}
Several approaches have been developed to solve a combinatorial optimization problem exactly, regardless of the ``shape of the problem''. Some other techniques can only be applied to cases where the problem itself meets certain criteria. We enumerate the most popular approaches to solve combinatorial optimization problems exactly:
\begin{description}
 \item [Brute force] a brute force algorithm enumerates the entire configuration space by assigning every value of the domain to the respective variable. Such approach always results in computation time exponential in the number of variables. The approach is not efficient at all since in most cases -- based on a partial assignment -- one can decide if potential good solutions can be derived from such assignment.
 \item [Branch-and-bound] In case of a branch-and-bound algorithm, one enumerate the configuration space as well, but one uses a \nmn{bound}: a value for the fitness of the thus far best solution found.
 \item [Dynamic programming]
 \item [State space relaxation]
 \item [Preprocessing]
\end{description}
\section*{Approximate algorithms}
For most optimization problems, a variety of approaches exist. Some of these are specific to a certain problem, others -- like \nmn{metaheuristics} -- are generic approximate algorithms that can solve any kind of problem. The term \nmn{heuristics} is used for such algorithms. For many heuristics an \nmn{error bound} $\epsilon$ can be derived such that in case of a minimization problem:
\begin{equation}
\dfrac{z-z^{\star}}{z^{\star}}\leq\epsilon
\end{equation}
for every instance with $z$ the fitness-value of the solution proposed by the heuristic for a specific problem instance and $z^{\star}$ the fitness value of the optimal solution for that problem instance.
\section*{Computational complexity}
\section*{Resources}
This dictionary list the different problems and for each concrete optimization problem, a formal description is provided. The mathematical notation is used. This dictionary comes with a website where the problems are specified in the \nmn{MiniZinc} language.
\glsaddall
\printglossaries
\clearpage\lettergroup{@}\dictchar{Appendix}
\section*{Mathematics}
In this section we will describe mathematical structures used in the corpus of this dictionary.
\begin{description}
 \item [Bag] A collection of items such that each item can occur zero, one or more times. A bag has no inherent order: there is no $i$-th item in a bag. A bag is sometimes called a \nmn{multiset}.
 \item [Set] A collection of items. Each item can belong or not belong to a set. Multiple occurrences are not allowed. A set has no inherent order.
 \item [List] A collection of items such that each item can occur zero, one or more times. A list has an inherent order: given that a list $L$ contains $n$ items, an item $l_i$ is called the $i$-th item of the list. A list is sometimes called a \nmn{vector} or \nmn{tuple}.
\end{description}

\end{document}