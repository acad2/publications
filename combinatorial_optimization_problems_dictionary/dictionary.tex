\documentclass{../SharedData/dictionaryclass}
\usepackage{xcolor,../SharedData/brackets}
\title{Combinatorial Optimization Problems Dictionary}
\author{Willem Van Onsem\\\href{mailto:Willem.VanOnsem@cs.kuleuven.be}{Willem.VanOnsem@cs.kuleuven.be}}
\date{KU Leuven\\Department of Computer Science\\Celestijnenlaan 200A, 3001 Heverlee, Belgium\\2013-201.}
\hypersetup{pdftitle={Combinatorial Optimization Problems Dictionary},pdfauthor={Willem Van Onsem (Willem.VanOnsem@cs.kuleuven.be)}, pdfsubject={Combinatorial Optimization Problem}, pdfkeywords={Combinatorial, Optimization, Problem, Heuristics}, linktoc=none}

\definecolor{frml-bg}{RGB}{255,247,220}
\definecolor{frml-fg}{RGB}{224,220,191}

\newcommand{\nmn}[1]{\emph{#1}}
\newcommand{\frml}[1]{\begin{quote}\fcolorbox{frml-fg}{frml-bg}{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textit{formal}\\#1}}\end{quote}}
\newcommand{\fcop}[3][maximize]{\begin{eqnarray}\mbox{#1}&&#2,\\\mbox{subject to}&&#3\end{eqnarray}}
\newcommand{\ccnpcomplete}{\textsc{NP-Complete}}
\newcommand{\ccnphard}{\textsc{NP-Hard}}
\newcommand{\ccp}{\textsc{P}}

\dey[maximum satisfiability]{Maximum satisfiability}{In the maximum satisfiability problem, one is given a set of boolean functions $\phi_1,\phi_2,\ldots,\phi_n$ defined on the set of boolean variables
 $x_1,x_2,\ldots,x_n$. One aims to find the boolean configuration $\vec{x}$ such that the maximum number of boolean functions is satisfied.}
\dey[knapsack]{Knapsack}{The knapsack problem is a group of different problems. In each problem, one is given a sequence of items $x_i$. Each item has one or more weights $w_i$ and some kind of utility value\footnote{Sometimes this value depends on other objects in the bag.} $v_i$. The objective is to generate a bag of objects such that the total utility is maximized under one or more weight bounds $W$. The number of weight constraints is called the \nmn{dimension} of the problem. The most standard \todef{} problem is the so called \rey{0-1 knapsack} problem. The \todef{} problem can be solved using dynamic programming in pseudo-polynomial time, it is therefore sometimes used as a subroutine for a more complex optimization problem. All \todef{} problems are \ccnphard{}. The \todef{} problem is however considered to be an easy problem in the family of \ccnphard{} problems because there exists a \nmn{dynamic programming} approach to solve most problems in \nmn{pseudo-polynomial} time.}[0-1 knapsack,bounded knapsack,unbounded knapsack,multiple-choice knapsack]
\dey[0-1 knapsack]{0-1 knapsack}{A special form of the \rey{knapsack} problem. In this variant, a bag contains zero or one instances of every item, in other words no copies of the specified items are allowed.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\accl{0,1}}}}
\dey[bounded knapsack]{Bounded knapsack}{A special case of the \rey{knapsack} problem. In this variant, each item $x_i$ can has a bounded number of instances (specified by $c_i$).\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\accl{0,1,\ldots,c_i}}}}
\dey[unbounded knapsack]{Unbounded knapsack}{A special case of the \rey{knapsack} problem. In this variant each item $x_i$ can have an unlimited number of instances in the bag.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&&x_i\in\NNN}}}
\dey[multiple-choice knapsack]{Multiple-choice knapsack}{A special case of the \rey{knapsack} problem where items are chosen from disjoint classes. From each class only one item can be selected.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{\sumdomain[j]{}{v_{i\;j}\cdot x_{i\;j}}}\leq W\\&&x_i\in\NNN}}}
\dey[multiple knapsack]{Multiple knapsack}{A special case of the \rey{knapsack} problem where several knapsacks are filled simultaneously based on the same set of items.}
\dey[multi-constrained knapsack]{Multi-constrained knapsack}{A special case of the \rey{knapsack} problem where each item has weights $w_{i\;j}$ of several flavors $j$ and for each of these flavors $j$ there is a weight bound $W_j$. The \todef{} problem has the same representation power of a \rey{integer linear} problem with positive coefficients.}
\dey[bin packing]{Bin packing}{In the \todef{} problem, one is given a set of items $i$ each with a specific length $l_i$ together with the length of a bin $L$, the objective is to organize the given items in such a way that the number of used bins is minimized. Items belong to only one bin and thus can't be split over the several bins.\frml{\fcop[minimize]{\sumieqb[i]{1}{n}{y_i}}{\sumieqb[j]{1}{n}{l_i\cdot x_{i\,j}}\leq L\cdot y_i\\&&\sumieqb[i]{1}{n}{x_{i\,j}}=1\\&&y_i\in\accl{0,1}\\&&x_{i\,j}\in\accl{0,1}}}}
\dey[job shop scheduling]{Job shop scheduling}{In the \todef{} problem, one is given a list of tasks that must be performed...}
\dey[integer linear]{Integer linear}{}

\begin{document}
\clearpage\lettergroup{1}\dictchar{Introduction}
In this dictionary, we document several combinatorial optimization problems.
\section*{Approaches}
Several approaches have been developed to solve a combinatorial optimization problem exactly, regardless of the ``shape of the problem''. Some other techniques can only be applied to cases where the problem itself meets certain criteria. We enumerate the most popular approaches to solve combinatorial optimization problems exactly:
\begin{description}
 \item [Brute force] a brute force algorithm enumerates the entire configuration space by assigning every value of the domain to the respective variable. Such approach always results in computation time exponential in the number of variables. The approach is not efficient at all since in most cases -- based on a partial assignment -- one can decide if potential good solutions can be derived from such assignment.
 \item [Branch-and-bound] In case of a branch-and-bound algorithm, one enumerate the configuration space as well, but one uses a \nmn{bound}: a value for the fitness of the thus far best solution found.
 \item [Dynamic programming]
 \item [State space relaxation]
 \item [Preprocessing]
\end{description}
\section*{Computational complexity}
\glsaddall
\printglossaries
\end{document}