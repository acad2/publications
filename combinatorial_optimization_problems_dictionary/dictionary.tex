\documentclass{../SharedData/dictionaryclass}
\usepackage{xcolor,../SharedData/brackets}
\title{Combinatorial Optimization Problems Dictionary}
\author{Willem Van Onsem\\\href{mailto:Willem.VanOnsem@cs.kuleuven.be}{Willem.VanOnsem@cs.kuleuven.be}\and Bart Demoen\and Patrick De Causmaecker}
\date{KU Leuven\\Department of Computer Science\\Celestijnenlaan 200A, 3001 Heverlee, Belgium\\2013-201.}
\hypersetup{pdftitle={Combinatorial Optimization Problems Dictionary},pdfauthor={Willem Van Onsem (Willem.VanOnsem@cs.kuleuven.be), Bart Demoen, Patrick De Causmaecker}, pdfsubject={Combinatorial Optimization Problems}, pdfkeywords={Combinatorial, Optimization, Problem, Heuristics}, linktoc=none}

\definecolor{frml-bg}{RGB}{255,247,220}
\definecolor{frml-fg}{RGB}{224,220,191}
\definecolor{frml-tx}{RGB}{119,119,119}

\setlength{\abovedisplayshortskip}{-.5\baselineskip plus 3pt}% Original value: 0pt plus 3pt





\newcommand{\nmn}[1]{\index{#1}\emph{#1}}
\newcommand{\nmns}[1]{\index{#1}\emph{#1s}}
\newcommand{\frml}[1]{\begin{quote}\fcolorbox{frml-fg}{frml-bg}{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textcolor{frml-tx}{\textit{formal}}\\#1}}\end{quote}}
\newcommand{\fcopm}{}
\newcommand{\fcop}[3][+]{\ifthenelse{\equal{#1}{+}}{\renewcommand{\fcopm}{maximize}}{\renewcommand{\fcopm}{minimize}}\[\begin{array}{ll}\mbox{\fcopm{}}&#2,\\\mbox{subject to}&#3\end{array}\]}
\newcommand{\ccnpcomplete}{\textsc{NP-Complete}}
\newcommand{\ccnphard}{\textsc{NP-Hard}}
\newcommand{\ccp}{\textsc{P}}

\dey[maximum satisfiability]{Maximum satisfiability}{In the maximum satisfiability problem, one is given a set of boolean functions $\phi_1,\phi_2,\ldots,\phi_n$ defined on the set of boolean variables
 $x_1,x_2,\ldots,x_n$. One aims to find the boolean configuration $\vec{x}$ such that the maximum number of boolean functions is satisfied.}

 \dey[knapsack]{Knapsack}{The knapsack problem is a group of different problems. In each problem, one is given a sequence of items $x_i$. Each item has one or more weights $w_i$ and some kind of utility value\footnote{Sometimes this value depends on other objects in the bag.} $v_i$. The objective is to generate a bag of objects such that the total utility is maximized under one or more weight bounds $W$. The number of weight constraints is called the \nmn{dimension} of the problem. The most standard \todef{} problem is the so called \rey{0-1 knapsack} problem. The \todef{} problem can be solved using dynamic programming in pseudo-polynomial time, it is therefore sometimes used as a subroutine for a more complex optimization problem. All \todef{} problems are \ccnphard{}. The \todef{} problem is however considered to be an easy problem in the family of \ccnphard{} problems because there exists a \nmn{dynamic programming} approach to solve problems in \nmn{pseudo-polynomial} time.}[0-1 knapsack,bounded knapsack,unbounded knapsack,multiple-choice knapsack]

\dey[0-1 knapsack]{0-1 knapsack}{A special form of the \rey{knapsack} problem. In this variant, a bag contains zero or one instances of every item, in other words no copies of the specified items are allowed.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\accl{0,1}}}The \todef{} has many practical applications in the financial sector, for instance investing in a number of projects where each project has a return-of-investment and a cost and only a limited budget is available.}[subset-sum]

\dey[bounded knapsack]{Bounded knapsack}{A special case of the \rey{knapsack} problem. In this variant, each item $x_i$ can has a bounded number of instances (specified by $c_i$).\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\accl{0,1,\ldots,c_i}}}}

\dey[unbounded knapsack]{Unbounded knapsack}{A special case of the \rey{knapsack} problem. In this variant each item $x_i$ can have an unlimited number of instances in the bag.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\NNN}}}

\dey[multiple-choice knapsack]{Multiple-choice knapsack}{A special case of the \rey{knapsack} problem where items are chosen from disjoint classes. From each class only one item can be selected.\frml{\fcop{\sumieqb[i]{1}{n}{\sumdomain[j]{N_i}{v_{i\;j}\cdot x_{i\;j}}}}{\sumieqb[i]{1}{n}{\sumdomain[j]{N_i}{w_{i\;j}\cdot x_{i\;j}}}\leq W\\&\sumdomain[j]{N_i}{x_{i\;j}}=1\\&x_{i\;j}\in\accl{0,1}}}}

\dey[multiple knapsack]{Multiple knapsack}{A special case of the \rey{knapsack} problem where several knapsacks are filled simultaneously based on the same set of items. An item can thus assigned to maximum one knapsack. It is possible that the knapsacks have different weight limits. The objective is to maximize the total utility value in all the knapsacks together.\frml{\fcop{\sumieqb[i]{1}{m}{\sumieqb[j]{1}{n}{p_{j}\cdot x_{i\;j}}}}{\sumieqb[j]{1}{n}{w_{j}\cdot x_{i\;j}}\leq W_i\\&\sumieqb[i]{1}{m}{x_{i\;j}}\leq1\\&x_{i\;j}\in\accl{0,1}}}}

\dey[multi-constrained knapsack]{Multi-constrained knapsack}{A special case of the \rey{knapsack} problem where each item has weights $w_{i\;j}$ of several flavors $j$ and for each of these flavors $j$ there is a weight bound $W_j$. The \todef{} problem has the same representation power of a \rey{integer linear} problem with positive coefficients. This problem is the most general \rey{knapsack} problem.\frml{\fcop{\sumieqb[i]{1}{n}{p_i\cdot x_i}}{\sumieqb[j]{1}{n}{w_{i\;j}\cdot x_{j}}\leq W_i\\&x_{i}\in\NNN}}}

\dey[bin-packing]{Bin-packing}{In the \todef{} problem, one is given a set of items $i$ each with a specific size $l_i$. The objects must be organized in a number of equally sized bins with size $L$. Items belong atomically to one bin: they can't be split over the several bins.\frml{\fcop[-]{\sumieqb[i]{1}{n}{y_i}}{\sumieqb[j]{1}{n}{l_i\cdot x_{i\,j}}\leq L\cdot y_i\\&\sumieqb[i]{1}{n}{x_{i\,j}}=1\\&y_i\in\accl{0,1}\\&x_{i\,j}\in\accl{0,1}}}}

\dey[job shop scheduling]{Job shop scheduling}{In the \todef{} problem, one is given a list of tasks that must be performed...}

\dey[subset-sum]{Subset-sum}{One is given a number of integers $w_i$, the aim is to determine a subset of the given integers such that the sum is maximum but less than or equal to a given bound $W$.\frml{\fcop{\sumieqb[i]{1}{n}{w_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\accl{0,1}}}The problem is strongly connected to the \rey{0-1 knapsack} problem where the utility value $v_i$ and the weights $w_i$ of each item are equal.}[0-1 knapsack]

\dey[change-making]{Change-making}{One is given a number of \mnm{coin value} $c_i$ and one must calculate a bag of such coins such that the sum is equal to a given amount of money $C$ such that the total number of \mnms{coin} is minimized.\frml{\fcop[-]{\sumieqb[i]{1}{n}{\cdot x_i}}{\sumieqb[i]{1}{n}{c_i\cdot x_i}=C\\&x_i\in\NNN}}The problem can be seen as a minimization variant of the \rey{unbounded knapsack} problem with an equality for the capacity bound.}[unbounded knapsack]

\dey[integer linear programming]{Integer linear programming}{In the \todef{} problem, one is given a matrix $A$ and two vectors $\vec{b}$ and $\vec{c}$. The aim is to find an optimal integer values for a vector of variables $\vec{x}$ such that the dot-product of $\vec{x}$ and $\vec{c}$ is maximized and the product of $A$ and $\vec{x}$ is element-wise less than or equal to $\vec{b}$.\frml{\fcop{\vec{c}\cdot\vec{x}}{A\cdot\vec{x}\leq\vec{b}\\&\vec{x}\in\NNN^n}}The \todef{} problem is proven to be \nphard{} although there exist solvers that solve most instances efficiently. Several combinatorial optimization problems are subsets of the \todef{} problem like the \rey{knapsack} problem.}

\dey[set covering]{Set covering}{Given a set $S$ of $m$ items and $n$ subsets $S_i\in\calS$ of $S$ with for each subset $S_i$ an associated cost $c_i$. The objective is to choose a bag of subsets $S_i$ such that the union of the subsets contains all items in $S$ with minimized total cost.\frml{\fcop[-]{\sumieqb[i]{1}{n}{c_i\cdot x_i}}{\sumdomain[S_i]{\calS,j\in S_i}{x_i}\geq 1\\&x_i\in\accl{0,1}}}}

\dey[continuous 0-1 knapsack]{Continuous 0-1 knapsack}{The \todef{} problem is a special case of the \rey{0-1 knapsack} problem where it is allowed to add fractions of an item into the knapsack, as a result the variables have real values and the problem is a special case of a \rey{linear programming} problem, as a result it can be solved in \nmn{polynomial} time.\frml{\fcop{\sumieqb[i]{1}{n}{v_i\cdot x_i}}{\sumieqb[i]{1}{n}{w_i\cdot x_i}\leq W\\&x_i\in\fbrk{0,1}}}}

\dey[vertex-cover]{Vertex-cover}{The \todef{} problem is an optimization problem where given a \nmn{undirected graph}, one aims to find the \nmn{optimal vertex cover}: the \nmn{vertex cover} of minimum size.}[][kumar14]

\dey[traveling salesman]{Traveling salesman}{One is given a \nmn{undirected graph} where the \nmns{edge} have a nonnegative integer cost, one aims to find a \nmn{Hamiltonian cycle} or \nmn{tour} of $G$ where the sum of the costs of the relevant edges in minimized. \frml{\fcop{\sumieqb{1}{n}{\sumieqb[j]{1}{n}{c_{i,j}\cdot x_{i,j}}}}{\acclleft{\forall i,j\in\accl{1,2,\ldots,n}:x_{i,j}\in\accl{0,1}\\&\forall j\in\accl{1,2,\ldots,n}:\sumieqb{1}{n}{x_{i,j}}=1\\&\forall i\in\accl{1,2,\ldots,n}:\sumieqb[j]{1}{n}{x_{i,j}}=1\\&\forall S\subseteq V:\abs{S}\geq 2:\sumdomain[i]{S}{\sumdomain[j]{S}{x_{i,j}}}\leq \abs{S}-1}}}}.}[][kumar14,spieksma13]

\dey[collapsing knapsack]{Collapsing knapsack}{}

\dey[nested knapsack]{Nested knapsack}{}

\dey[nonlinear knapsack]{Nonlinear knapsack}{}

\dey[inverse-parametric knapsack]{Inverse-parametric knapsack}{}

\dey[generalized assignment knapsack]{Generalized assignment knapsack}{}

\dey[linear programming]{Linear programming}{}

\begin{document}
\clearpage\lettergroup{1}\dictchar{Introduction}
In this dictionary, we document several combinatorial optimization problems.
\section*{Exact algorithms}
Several approaches have been developed to solve a combinatorial optimization problem exactly, regardless of the ``shape of the problem''. Some other techniques can only be applied to cases where the problem itself meets certain criteria. We enumerate the most popular approaches to solve combinatorial optimization problems exactly:
\begin{description}
 \item [Brute force] a brute force algorithm enumerates the entire configuration space by assigning every value of the domain to the respective variable. Such approach always results in computation time exponential in the number of variables. The approach is not efficient at all since in most cases -- based on a partial assignment -- one can decide if potential good solutions can be derived from such assignment.
 \item [Branch-and-bound] In case of a branch-and-bound algorithm, one enumerate the configuration space as well, but one uses a \nmn{bound}: a value for the fitness of the thus far best solution found.
 \item [Dynamic programming]
 \item [State space relaxation]
 \item [Preprocessing]
\end{description}
\section*{Approximate algorithms}
For most optimization problems, a variety of approaches exist. Some of these are specific to a certain problem, others -- like \nmn{metaheuristics} -- are generic approximate algorithms that can solve any kind of problem. The term \nmn{heuristics} is used for such algorithms. For many heuristics an \nmn{error bound} $\epsilon$ can be derived such that in case of a minimization problem:
\begin{equation}
\dfrac{z-z^{\star}}{z^{\star}}\leq\epsilon
\end{equation}
for every instance with $z$ the fitness-value of the solution proposed by the heuristic for a specific problem instance and $z^{\star}$ the fitness value of the optimal solution for that problem instance.
\section*{Computational complexity}
\glsaddall
\printglossaries
\clearpage\lettergroup{@}\dictchar{Appendix}
\section*{Mathematics}
In this section we will describe mathematical structures used in the corpus of this dictionary.
\begin{description}
 \item [Bag] A collection of items such that each item can occur zero, one or more times. A bag has no inherent order: there is no $i$-th item in a bag. A bag is sometimes called a \nmn{multiset}.
 \item [Set] A collection of items. Each item can belong or not belong to a set. Multiple occurrences are not allowed. A set has no inherent order.
 \item [List] A collection of items such that each item can occur zero, one or more times. A list has an inherent order: given that a list $L$ contains $n$ items, an item $l_i$ is called the $i$-th item of the list. A list is sometimes called a \nmn{vector} or \nmn{tuple}.
\end{description}

\end{document}