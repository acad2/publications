legtal/legen/3/9.25/5 cm/Algorithm/Alg/{An \emph{algorithm} is a set of instruction that describe how to transform data into other data.},
cpm/cop/31.5/7/9 cm/{Critical path method}/{CPM}/{The \emph{critical path method} is an algorithm that can determine the \emph{scheduling time} and \emph{slack time} of each activity in a project using an \emph{activity-on-arc network}. The method works in a \emph{forward phase} and \emph{backward phase}. In the forward phase the start vertex is labeled with $0$. Other vertices are labeled if all incoming arcs originate from labeled vertices with the maximum of the label of the starting vertex plus the weight of the edge. In the backward phase, the final vertex is co-labeled with its label. Then each vertex is labeled with the minimum over all outgoing edges of the head's co-label minus the weight of the edge.},
huffman/cseq/11.75/2.5/7 cm/{Huffman's algorithm}/{Huffman}/{\emph{Huffman's algorithm} is an algorithm that takes as input a set of symbols with the relative frequency of the symbols and constructs a binary tree whose corresponding prefix code has the smallest possible average weighted length.\paragraph{}The algorithm uses a priority queue where initially the symbols are placed ordered in increasing probability. At each iteration, the items in the priority queue with the smallest probability are grouped together in a node with as probability the sum of the two items. This binary tree is placed back in the queue and so inductively a binary tree is constructed.\importalgorithmiccenter{huffman}},
bruijnalg/cseq/27.75/2.5/7 cm/{deBruijn's algorithm}/{deBruijn}/{\emph{deBruijn's algorithm} is given a positive integer $n$ and constructs a deBruijn sequence. The algorithm first constructs a deBruijn digraph and then constructs an Eulerian tour.},
hungarian/cop/62.25/2/7 cm/{Hungarian algorithm}/{Hungarian}/{The \emph{Hungarian algorithm} solves the assignment problem optimally. At each iteration, the algorithm subtracts the minimum from a row or column of the cost matrix until there are $n$ independent zeros in the matrix. The assignment is then $x_{i\,j}=1$ for each of the independent zeros.},
fordfulk/maflw/13.75/1.5/7 cm/{Ford-Fulkerson algorithm}/{Ford-Fulkerson}/{The \emph{Ford-Fulkerson algorithm} solves the maximum flow problem to optimality. The algorithm incrementally searches for a path with available capacity (called an \emph{augmenting path}) and adds the available capacity to that path. One searches such path using a \textsc{Label}ing procedure.\importalgorithmiccenter{fordfulkerson}},
edskarp/maflw/22.25/1.5/8.5 cm/{Edmonds-Karp algorithm}/{Edmonds-Karp}/{The \emph{Edmonds-Karp algorithm} is a special case of the Ford-Fulkerson algorithm that searches for an augmenting path using breadth-first search. The algorithm below either returns a tuple containing the augmenting path and the corresponding additional flow or \textbf{null} in case no such path exists.\importalgorithmiccenter{edmondskarp}},
seqclr/grcl/20.5/1.5/9 cm/{Sequential vertex coloring}/{$C\nearrow$}/{\emph{Sequential vertex coloring} is a naive approach to the vertex coloring problem. The approach iterates - in some order - over the set of vertices. For each vertex the algorithm looks which neighbors are already colored. It assigns the lowest color that is available to the vertex. The algorithm runs in $\bigoh{n}$.\importalgorithmiccenter{seqcolor}},
ldsqcl/grcl/20.5/8.25/9 cm/{Largest degree first vertex coloring}/{$\max\gamma_f$}/{\emph{Largest degree first vertex coloring} is a special case of sequential vertex coloring where at each iteration, the vertex with the lowest color degree is picked.},
ctreuler/move/32.5/5/9.5 cm/{Constructing an Eulerian tour}/{Euler}/{Given an Eulerian graph $G$, an algorithm can construct an Eulerian tour. The algorithm iteratively constructs a tour by adding adjacent edges up to a tour. For every vertex with remaining edges, subtours are inserted.\importalgorithmiccenter{eulertr}},
treegrow/tree/26.25/5.5/7 cm/{Tree-growing algorithm}/{$T\nearrow$}/{A \emph{tree-growing algorithm} is an algorithm that takes as input a graph $G$ and starts with an empty tree $T_0$. In each iteration the $\funm{nextEdge}{G,S}$ and $\funm{updateFrontier}{G,S}$ selects and updates the tree for a given set of frontier edges $S$. The algorithm terminates if all vertices are added to the tree. The \emph{discovery order} is the order in which the vertices of the graph are added to the tree and the \emph{discovery number} is the position of a vertex in the discovery-order list starting with $0$. The edges not added to the tree are either \emph{skip-edges} if the endpoints are not related with respect to the tree; or \emph{cross-edges} if the endpoints are related.}